(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("../Wolfie2D/Utils/MathUtils");
class Camera {
    constructor(point, offset) {
        this.node = point;
        this.offset = offset;
    }
    update(deltaT) {
        const offsetFollow = this.following.position.clone().add(this.offset);
        if (Math.abs(this.node.position.y - this.following.position.clone().y) >
            Math.abs(this.offset.y))
            this.node.position.y = MathUtils_1.default.lerp(this.node.position.y, offsetFollow.y, 2 * deltaT);
        this.node.position.x = offsetFollow.x;
    }
    follow(node) {
        this.following = node;
    }
}
exports.default = Camera;
},{"../Wolfie2D/Utils/MathUtils":134}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GhostAnimations = exports.GhostType = void 0;
const GhostController_1 = require("./GhostController");
const Vec2_1 = require("../../../Wolfie2D/DataTypes/Vec2");
const globals_1 = require("../../../globals");
const AABB_1 = require("../../../Wolfie2D/DataTypes/Shapes/AABB");
var GhostType;
(function (GhostType) {
    GhostType["RED"] = "red";
    GhostType["BLUE"] = "blue";
})(GhostType = exports.GhostType || (exports.GhostType = {}));
var GhostAnimations;
(function (GhostAnimations) {
    GhostAnimations["Idle"] = "Idle";
})(GhostAnimations = exports.GhostAnimations || (exports.GhostAnimations = {}));
class Ghost {
    constructor(sprite, pos, type) {
        this.node = sprite;
        this.node.addPhysics(new AABB_1.default(new Vec2_1.default(0, 0), globals_1.SpriteSizes.SOUL), new Vec2_1.default(0, 0));
        this.node.addAI(GhostController_1.default);
        this.node.setGroup(globals_1.PhysicsGroups.ENEMY_PHYS);
        this.node.position = pos;
        this.node.animation.play(GhostAnimations.Idle, true);
        this.health = 5;
        this.type = type;
    }
}
exports.default = Ghost;
},{"../../../Wolfie2D/DataTypes/Shapes/AABB":49,"../../../Wolfie2D/DataTypes/Vec2":56,"../../../globals":137,"./GhostController":3}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GState = void 0;
const StateMachineAI_1 = require("../../../Wolfie2D/AI/StateMachineAI");
const Vec2_1 = require("../../../Wolfie2D/DataTypes/Vec2");
const Drifting_1 = require("./GhostStates/Drifting");
const Following_1 = require("./GhostStates/Following");
const Knockback_1 = require("./GhostStates/Knockback");
var GState;
(function (GState) {
    GState["Drifting"] = "drifting";
    GState["Following"] = "following";
    GState["Knockback"] = "knockback";
})(GState = exports.GState || (exports.GState = {}));
class GhostController extends StateMachineAI_1.default {
    constructor() {
        super(...arguments);
        //direction_op = [new Vec2(1,1),new Vec2(1,-1),new Vec2(-1,1),new Vec2(-1,-1)]
        this.direction = Vec2_1.default.ZERO;
        this.velocity = Vec2_1.default.ZERO;
        this.driftSpeed = 10;
        this.followSpeed = 30;
        this.knockbackSpeed = 150;
        this.gravity = 0;
    }
    initializeAI(owner, config) {
        this.owner = owner;
        this.direction = this.randomDirection();
        this.initializeStates();
    }
    initializeStates() {
        this.addState(GState.Drifting, new Drifting_1.default(this, this.owner));
        this.addState(GState.Following, new Following_1.default(this, this.owner));
        this.addState(GState.Knockback, new Knockback_1.default(this, this.owner));
        this.initialize(GState.Drifting);
    }
    update(deltaT) {
        super.update(deltaT);
        this.owner.move(this.velocity);
    }
    randomDirection() {
        return Vec2_1.default.UP.rotateCCW(Math.random() * Math.PI * 2);
    }
    get state() {
        return this.stack.peek();
    }
}
exports.default = GhostController;
},{"../../../Wolfie2D/AI/StateMachineAI":37,"../../../Wolfie2D/DataTypes/Vec2":56,"./GhostStates/Drifting":4,"./GhostStates/Following":5,"./GhostStates/Knockback":7}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GhostState_1 = require("./GhostState");
const GhostController_1 = require("../GhostController");
class Drifting extends GhostState_1.default {
    onEnter(options) {
        this.parent.direction = this.parent.randomDirection();
        this.stateName = "Drifting";
        this.canFollow = false;
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.withinXBlock(6))
            this.canFollow = true;
        if (this.canFollow) {
            this.finished(GhostController_1.GState.Following);
        }
        else {
            this.parent.velocity.x =
                this.parent.direction.x * this.parent.driftSpeed * deltaT;
            this.parent.velocity.y =
                this.parent.direction.y * this.parent.driftSpeed * deltaT;
            this.owner.move(this.parent.velocity);
        }
    }
    onExit() {
        //(<AnimatedSprite>this.owner).animation.stop();
        return {};
    }
}
exports.default = Drifting;
},{"../GhostController":3,"./GhostState":6}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GhostState_1 = require("./GhostState");
const GhostController_1 = require("../GhostController");
class Following extends GhostState_1.default {
    onEnter(options) {
        this.stateName = "Following";
        this.stuckTimer.start();
        this.canFollow = true;
    }
    update(deltaT) {
        super.update(deltaT);
        if (!this.withinXBlock(6))
            this.canFollow = false;
        if (!this.canFollow) {
            this.followingCDTimer.start();
            this.finished(GhostController_1.GState.Drifting);
            return;
        }
        else if (this.owner.onWall ||
            this.owner.onCeiling ||
            this.owner.onGround) {
            if (this.stuckTimer.isStopped()) {
                this.followingCDTimer.start();
                this.finished(GhostController_1.GState.Drifting);
                return;
            }
        }
        else {
            this.stuckTimer.reset();
        }
        this.parent.direction = this.owner.position.dirTo(this.playerPos);
        this.parent.velocity.x =
            this.parent.direction.x * this.parent.followSpeed * deltaT;
        this.parent.velocity.y =
            this.parent.direction.y * this.parent.followSpeed * deltaT;
        this.owner.move(this.parent.velocity);
    }
    onExit() {
        //(<AnimatedSprite>this.owner).animation.stop();
        return {};
    }
}
exports.default = Following;
},{"../GhostController":3,"./GhostState":6}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const State_1 = require("../../../../Wolfie2D/DataTypes/State/State");
const Timer_1 = require("../../../../Wolfie2D/Timing/Timer");
const globals_1 = require("../../../../globals");
class GhostState extends State_1.default {
    constructor(parent, owner) {
        super(parent);
        this.owner = owner;
        this.followingCDTimer = new Timer_1.default(10000);
        this.stuckTimer = new Timer_1.default(5000); // check if a ghost is stuck for too long
        this.contactCooldown = new Timer_1.default(1000);
        this.knockbackTimer = new Timer_1.default(500);
    }
    handleInput(event) { }
    /**
     * check if this node is within x block of player.
     * A x by x square area with player as center
     */
    withinXBlock(x) {
        this.playerPos = this.owner.getScene().player.node.position;
        return (Math.abs(this.owner.position.x - this.playerPos.x) <= 32 * x &&
            Math.abs(this.owner.position.y - this.playerPos.y) <= 32 * x);
    }
    update(deltaT) {
        if (this.owner.onWall) {
            // Flip around
            this.parent.direction.x *= -1;
            this.owner.invertX = !this.owner
                .invertX;
        }
        if (this.contactCooldown.isStopped() &&
            this.owner.collisionShape.overlaps(this.owner.getScene().player.node.collisionShape)) {
            this.emitter.fireEvent(globals_1.Events.PLAYER_DAMAGE);
            this.contactCooldown.start();
        }
        if (this.owner.onCeiling || this.owner.onGround) {
            this.parent.direction.y *= -1;
        }
    }
}
exports.default = GhostState;
},{"../../../../Wolfie2D/DataTypes/State/State":53,"../../../../Wolfie2D/Timing/Timer":129,"../../../../globals":137}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GhostState_1 = require("./GhostState");
const GhostController_1 = require("../GhostController");
class Knockback extends GhostState_1.default {
    onEnter(options) {
        this.playerPos = this.owner.getScene().player.node.position;
        this.parent.direction.x = this.owner.position.x - this.playerPos.x > 0 ? 1 : -1;
        this.parent.direction.y = 0;
        this.stateName = GhostController_1.GState.Knockback;
        this.knockbackTimer.start();
    }
    update(deltaT) {
        super.update(deltaT);
        this.parent.velocity.x =
            this.parent.direction.x * this.parent.knockbackSpeed * deltaT;
        this.parent.velocity.y =
            this.parent.direction.y * this.parent.knockbackSpeed * deltaT;
        this.owner.move(this.parent.velocity);
        if (this.knockbackTimer.isStopped()) {
            if (this.withinXBlock(6))
                this.canFollow = true;
            else
                this.canFollow = false;
            if (this.canFollow) {
                this.finished(GhostController_1.GState.Following);
            }
            else {
                this.finished(GhostController_1.GState.Drifting);
            }
        }
    }
    onExit() {
        //(<AnimatedSprite>this.owner).animation.stop();
        return {};
    }
}
exports.default = Knockback;
},{"../GhostController":3,"./GhostState":6}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DamageType = void 0;
var DamageType;
(function (DamageType) {
    DamageType["TO_PLAYER"] = "TO_PLAYER";
    DamageType["TO_ENEMY"] = "TO_ENEMY";
    DamageType["CONTACT"] = "CONTACT";
})(DamageType = exports.DamageType || (exports.DamageType = {}));
},{}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HState = void 0;
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const AABB_1 = require("../../Wolfie2D/DataTypes/Shapes/AABB");
const HitboxController_1 = require("./HitboxController");
const globals_1 = require("../../globals");
var HState;
(function (HState) {
    HState["Active"] = "Active";
    HState["Contact"] = "Contact";
    HState["Manager"] = "Manager";
})(HState = exports.HState || (exports.HState = {}));
class Hitbox {
    constructor(owner, sprite, eventType, center, halfSize, invertX, offset) {
        this.node = sprite;
        this.node.addPhysics(new AABB_1.default(center, halfSize), new Vec2_1.default(0, 0));
        this.node.setGroup(globals_1.PhysicsGroups.HITBOX_PHYS);
        this.node.addAI(HitboxController_1.default, {
            invertX: invertX,
            offset: offset,
            eventType: eventType,
            owner: owner,
        });
    }
}
exports.default = Hitbox;
},{"../../Wolfie2D/DataTypes/Shapes/AABB":49,"../../Wolfie2D/DataTypes/Vec2":56,"../../globals":137,"./HitboxController":10}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StateMachineAI_1 = require("../../Wolfie2D/AI/StateMachineAI");
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const Active_1 = require("./HitboxStates/Active");
const Hitbox_1 = require("./Hitbox");
const ManageHitbox_1 = require("./HitboxStates/ManageHitbox");
class HitboxController extends StateMachineAI_1.default {
    constructor() {
        super(...arguments);
        this.velocity = Vec2_1.default.ZERO;
    }
    initializeAI(owner, config) {
        this.owner = owner;
        this.invertX = config.invertX;
        this.offset = config.offset;
        this.eventType = config.eventType;
        this.owningEntity = config.owner;
        // subscribe to events maybe
        this.initializeStates();
    }
    initializeStates() {
        // add states
        this.addState(Hitbox_1.HState.Active, new Active_1.default(this, this.owner));
        this.addState(Hitbox_1.HState.Manager, new ManageHitbox_1.default(this, this.owner));
        // add initial state
        this.initialize(Hitbox_1.HState.Manager);
    }
    update(deltaT) {
        super.update(deltaT);
    }
    get state() {
        return this.stack.peek();
    }
}
exports.default = HitboxController;
},{"../../Wolfie2D/AI/StateMachineAI":37,"../../Wolfie2D/DataTypes/Vec2":56,"./Hitbox":9,"./HitboxStates/Active":11,"./HitboxStates/ManageHitbox":13}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Hitbox_1 = require("../Hitbox");
const HitboxState_1 = require("./HitboxState");
const Vec2_1 = require("../../../Wolfie2D/DataTypes/Vec2");
const DamageType_1 = require("../DamageType");
const globals_1 = require("../../../globals");
const GhostController_1 = require("../../Enemy/Ghost/GhostController");
class Active extends HitboxState_1.default {
    onEnter(options) {
        this.stateName = Hitbox_1.HState.Active;
        this.owner.animation.play("animation", false);
    }
    update(deltaT) {
        super.update(deltaT);
        const player = this.owner.getScene().player.node;
        let posX = player.position.x + this.parent.offset.x;
        let posY = player.position.y + this.parent.offset.y;
        if (this.parent.invertX) {
            posX = posX - this.parent.offset.x * 2;
            posY = posY - this.parent.offset.y * 2;
            this.owner.invertX = true;
        }
        this.owner.position = new Vec2_1.default(posX, posY);
        // Hitbox damaging enemies
        if (this.hasHit) {
            if (this.parent.eventType === DamageType_1.DamageType.TO_ENEMY) {
                const enemies = this.owner.getScene().enemies;
                enemies.forEach(enemy => {
                    if (this.owner.collisionShape.overlaps(enemy.node.collisionShape)) {
                        this.emitter.fireEvent(globals_1.Events.ENEMY_DAMAGE, { enemy: enemy });
                        enemy.node._ai.changeState(GhostController_1.GState.Knockback);
                        this.hasHit = false;
                    }
                });
            }
            // Hitbox damaging player
            if (this.parent.eventType === DamageType_1.DamageType.TO_PLAYER) {
                if (this.owner.collisionShape.overlaps(player.collisionShape)) {
                    this.emitter.fireEvent(globals_1.Events.PLAYER_DAMAGE);
                    this.hasHit = false;
                }
            }
        }
        if (!this.owner.animation.isPlaying("animation")) {
            this.owner.destroy();
        }
    }
    handleInput(event) {
        // handle events here
    }
    onExit() {
        return {};
    }
}
exports.default = Active;
},{"../../../Wolfie2D/DataTypes/Vec2":56,"../../../globals":137,"../../Enemy/Ghost/GhostController":3,"../DamageType":8,"../Hitbox":9,"./HitboxState":12}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const State_1 = require("../../../Wolfie2D/DataTypes/State/State");
class HitboxState extends State_1.default {
    constructor(parent, owner) {
        super(parent);
        this.owner = owner;
        this.hasHit = true;
    }
    update(deltaT) { }
}
exports.default = HitboxState;
},{"../../../Wolfie2D/DataTypes/State/State":53}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Hitbox_1 = require("../Hitbox");
const HitboxState_1 = require("./HitboxState");
// This state tells the hitbox what type of hitbox it will end up as.
class ManageHitbox extends HitboxState_1.default {
    onEnter(options) {
        this.stateName = Hitbox_1.HState.Manager;
    }
    update(deltaT) {
        super.update(deltaT);
        this.finished(Hitbox_1.HState.Active);
    }
    handleInput(event) {
        // handle events here
    }
    onExit() {
        return {};
    }
}
exports.default = ManageHitbox;
},{"../Hitbox":9,"./HitboxState":12}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlayerAnimations = exports.ActionState = exports.MovementState = void 0;
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const AABB_1 = require("../../Wolfie2D/DataTypes/Shapes/AABB");
const StateMachine_1 = require("../../Wolfie2D/DataTypes/State/StateMachine");
const Grounded_1 = require("./States/Movement/Grounded");
const Ascending_1 = require("./States/Movement/Ascending");
const Descending_1 = require("./States/Movement/Descending");
const Dashing_1 = require("./States/Actions/Dashing");
const Idle_1 = require("./States/Actions/Idle");
const Jump_1 = require("./States/Actions/Jump");
const Attack_1 = require("./States/Actions/Attack");
const AttackDown_1 = require("./States/Actions/AttackDown");
const AttackUpper_1 = require("./States/Actions/AttackUpper");
const globals_1 = require("../../globals");
var MovementState;
(function (MovementState) {
    MovementState["Grounded"] = "grounded";
    MovementState["Ascending"] = "ascending";
    MovementState["Descending"] = "descending";
})(MovementState = exports.MovementState || (exports.MovementState = {}));
var ActionState;
(function (ActionState) {
    ActionState["Dash"] = "dash";
    ActionState["Attack"] = "attack";
    ActionState["AttackUpper"] = "attackUpper";
    ActionState["AttackDown"] = "attackDown";
    ActionState["Idle"] = "idle";
    ActionState["Jump"] = "jump";
})(ActionState = exports.ActionState || (exports.ActionState = {}));
var PlayerAnimations;
(function (PlayerAnimations) {
    PlayerAnimations["Idle"] = "Idle";
    PlayerAnimations["Walk"] = "Walk";
    PlayerAnimations["ScytheSlash"] = "Scythe Slash";
    PlayerAnimations["Jump"] = "Jump";
    PlayerAnimations["Dash"] = "Dash";
    PlayerAnimations["ScytheUpper"] = "Scythe Upper";
    PlayerAnimations["ScytheDown"] = "Scythe Down";
})(PlayerAnimations = exports.PlayerAnimations || (exports.PlayerAnimations = {}));
class Player {
    constructor(sprite) {
        this.velocity = new Vec2_1.default();
        this.speed = 300;
        this.timeToApex = 0.35;
        this.jumpHeight = 20;
        this.node = sprite;
        this.node.addPhysics(new AABB_1.default(new Vec2_1.default(0, 0), globals_1.SpriteSizes.PLAYER));
        this.node.setGroup(globals_1.PhysicsGroups.PLAYER_PHYS);
        this.node.position = new Vec2_1.default(100, 50);
        this.node.animation.play(PlayerAnimations.Idle, true);
        this.maxHealth = 10;
        this.health = 10;
        this.updateGravity();
        this.initializeAI();
    }
    initializeAI() {
        this.movementStateMachine = new StateMachine_1.default();
        this.movementStateMachine
            .addState(MovementState.Grounded, new Grounded_1.default(this.movementStateMachine, this.node, this))
            .addState(MovementState.Ascending, new Ascending_1.default(this.movementStateMachine, this.node, this))
            .addState(MovementState.Descending, new Descending_1.default(this.movementStateMachine, this.node, this))
            .initialize(MovementState.Grounded);
        this.actionStateMachine = new StateMachine_1.default();
        this.actionStateMachine
            .addState(ActionState.Dash, new Dashing_1.default(this.actionStateMachine, this.node, this))
            .addState(ActionState.Idle, new Idle_1.default(this.actionStateMachine, this.node, this))
            .addState(ActionState.Jump, new Jump_1.default(this.actionStateMachine, this.node, this))
            .addState(ActionState.Attack, new Attack_1.default(this.actionStateMachine, this.node, this))
            .addState(ActionState.AttackUpper, new AttackUpper_1.default(this.actionStateMachine, this.node, this))
            .addState(ActionState.AttackDown, new AttackDown_1.default(this.actionStateMachine, this.node, this))
            .initialize(ActionState.Idle);
    }
    updateGravity() {
        this.gravity = (2 * this.jumpHeight) / Math.pow(this.timeToApex, 2) / 10;
        this.jumpVelocity = -this.gravity * this.timeToApex;
    }
    update(deltaT) {
        this.movementStateMachine.update(deltaT);
        this.actionStateMachine.update(deltaT);
        this.node.move(this.velocity);
    }
}
exports.default = Player;
},{"../../Wolfie2D/DataTypes/Shapes/AABB":49,"../../Wolfie2D/DataTypes/State/StateMachine":54,"../../Wolfie2D/DataTypes/Vec2":56,"../../globals":137,"./States/Actions/Attack":15,"./States/Actions/AttackDown":16,"./States/Actions/AttackUpper":17,"./States/Actions/Dashing":18,"./States/Actions/Idle":19,"./States/Actions/Jump":20,"./States/Movement/Ascending":22,"./States/Movement/Descending":23,"./States/Movement/Grounded":24}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PlayerActionState_1 = require("./PlayerActionState");
const Hitbox_1 = require("../../../Hitbox/Hitbox");
const Vec2_1 = require("../../../../Wolfie2D/DataTypes/Vec2");
const Player_1 = require("../../Player");
const GameLevel_1 = require("../../../Scenes/GameLevel");
const Timer_1 = require("../../../../Wolfie2D/Timing/Timer");
const DamageType_1 = require("../../../Hitbox/DamageType");
class Attack extends PlayerActionState_1.default {
    onEnter(options) {
        this.stateName = "Attack";
        this.owner.animation.playIfNotAlready(Player_1.PlayerAnimations.ScytheSlash);
        const offset = new Vec2_1.default(60, 0);
        const sprite = this.player.node
            .getScene()
            .add.animatedSprite("ScytheSlash", GameLevel_1.Layers.Main);
        const timer = new Timer_1.default(100, () => {
            let hitbox = new Hitbox_1.default(this.player.node, sprite, DamageType_1.DamageType.TO_ENEMY, new Vec2_1.default(0, 0), new Vec2_1.default(48, 16), this.player.node.invertX, offset);
        }, false);
        timer.start();
    }
    onExit() {
        return {};
    }
    update(deltaT) {
        if (!this.owner.animation.isPlaying(Player_1.PlayerAnimations.ScytheSlash))
            this.player.actionStateMachine.changeState(Player_1.ActionState.Idle);
    }
}
exports.default = Attack;
},{"../../../../Wolfie2D/DataTypes/Vec2":56,"../../../../Wolfie2D/Timing/Timer":129,"../../../Hitbox/DamageType":8,"../../../Hitbox/Hitbox":9,"../../../Scenes/GameLevel":28,"../../Player":14,"./PlayerActionState":21}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PlayerActionState_1 = require("./PlayerActionState");
const Hitbox_1 = require("../../../Hitbox/Hitbox");
const Vec2_1 = require("../../../../Wolfie2D/DataTypes/Vec2");
const Player_1 = require("../../Player");
const GameLevel_1 = require("../../../Scenes/GameLevel");
const Timer_1 = require("../../../../Wolfie2D/Timing/Timer");
const DamageType_1 = require("../../../Hitbox/DamageType");
class AttackDown extends PlayerActionState_1.default {
    onEnter(options) {
        this.stateName = "AttackDown";
        this.owner.animation.playIfNotAlready(Player_1.PlayerAnimations.ScytheDown, false);
        const offset = new Vec2_1.default(40, 0);
        const sprite = this.player.node
            .getScene()
            .add.animatedSprite("ScytheDown", GameLevel_1.Layers.Main);
        const timer = new Timer_1.default(250, () => {
            let hitbox = new Hitbox_1.default(this.player.node, sprite, DamageType_1.DamageType.TO_ENEMY, new Vec2_1.default(0, 0), new Vec2_1.default(24, 48), this.player.node.invertX, offset);
        }, false);
        timer.start();
    }
    onExit() {
        return {};
    }
    update(deltaT) {
        if (!this.owner.animation.isPlaying(Player_1.PlayerAnimations.ScytheDown))
            this.player.actionStateMachine.changeState(Player_1.ActionState.Idle);
    }
}
exports.default = AttackDown;
},{"../../../../Wolfie2D/DataTypes/Vec2":56,"../../../../Wolfie2D/Timing/Timer":129,"../../../Hitbox/DamageType":8,"../../../Hitbox/Hitbox":9,"../../../Scenes/GameLevel":28,"../../Player":14,"./PlayerActionState":21}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PlayerActionState_1 = require("./PlayerActionState");
const Hitbox_1 = require("../../../Hitbox/Hitbox");
const Vec2_1 = require("../../../../Wolfie2D/DataTypes/Vec2");
const Player_1 = require("../../Player");
const GameLevel_1 = require("../../../Scenes/GameLevel");
const Timer_1 = require("../../../../Wolfie2D/Timing/Timer");
const DamageType_1 = require("../../../Hitbox/DamageType");
class AttackUpper extends PlayerActionState_1.default {
    onEnter(options) {
        this.stateName = "AttackUpper";
        this.owner.animation.playIfNotAlready(Player_1.PlayerAnimations.ScytheUpper);
        const offset = new Vec2_1.default(40, 0);
        const sprite = this.player.node
            .getScene()
            .add.animatedSprite("ScytheUpper", GameLevel_1.Layers.Main);
        const timer = new Timer_1.default(120, () => {
            let hitbox = new Hitbox_1.default(this.player.node, sprite, DamageType_1.DamageType.TO_ENEMY, new Vec2_1.default(0, 0), new Vec2_1.default(24, 48), this.player.node.invertX, offset);
        }, false);
        timer.start();
    }
    onExit() {
        return {};
    }
    update(deltaT) {
        if (!this.owner.animation.isPlaying(Player_1.PlayerAnimations.ScytheUpper))
            this.player.actionStateMachine.changeState(Player_1.ActionState.Idle);
    }
}
exports.default = AttackUpper;
},{"../../../../Wolfie2D/DataTypes/Vec2":56,"../../../../Wolfie2D/Timing/Timer":129,"../../../Hitbox/DamageType":8,"../../../Hitbox/Hitbox":9,"../../../Scenes/GameLevel":28,"../../Player":14,"./PlayerActionState":21}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Timer_1 = require("../../../../Wolfie2D/Timing/Timer");
const Player_1 = require("../../Player");
const PlayerActionState_1 = require("./PlayerActionState");
class Dashing extends PlayerActionState_1.default {
    onEnter(options) {
        this.stateName = "Dashing";
        this.owner.animation.playIfNotAlready(Player_1.PlayerAnimations.Dash);
        this.dashTimer = new Timer_1.default(200, () => this.finished(Player_1.ActionState.Idle), false);
        this.dashTimer.start();
    }
    update(deltaT) {
        if (!this.owner.onGround)
            this.player.canDash = false;
        this.player.velocity.y = this.player.node.onGround ? 0.00001 : 0;
        const direction = this.getInputDirection().x == 0
            ? this.owner.invertX
                ? -1
                : 1
            : this.getInputDirection().x;
        this.player.speed = 500;
    }
    onExit() {
        return { state: Player_1.ActionState.Dash };
    }
}
exports.default = Dashing;
},{"../../../../Wolfie2D/Timing/Timer":129,"../../Player":14,"./PlayerActionState":21}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PlayerActionState_1 = require("./PlayerActionState");
const Input_1 = require("../../../../Wolfie2D/Input/Input");
const Player_1 = require("../../Player");
const globals_1 = require("../../../../globals");
class Idle extends PlayerActionState_1.default {
    onEnter(options) {
        this.stateName = "Idle";
    }
    handleInput(event) {
        super.handleInput(event);
    }
    onExit() {
        return {};
    }
    update(deltaT) {
        if (Input_1.default.isJustPressed(globals_1.Action.Dash) && this.player.canDash) {
            this.finished(Player_1.ActionState.Dash);
        }
    }
}
exports.default = Idle;
},{"../../../../Wolfie2D/Input/Input":64,"../../../../globals":137,"../../Player":14,"./PlayerActionState":21}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Input_1 = require("../../../../Wolfie2D/Input/Input");
const globals_1 = require("../../../../globals");
const Player_1 = require("../../Player");
const Idle_1 = require("./Idle");
class Jump extends Idle_1.default {
    onEnter(options) {
        if (options)
            this.fromDash = options.state == Player_1.ActionState.Dash;
        this.stateName = "Jump";
        this.player.velocity.y = this.player.jumpVelocity;
        this.player.movementStateMachine.changeState(Player_1.MovementState.Ascending);
    }
    onExit() {
        return {};
    }
    update(deltaT) {
        super.update(deltaT);
        if (!Input_1.default.isPressed(globals_1.Action.Jump)) {
            if (this.player.velocity.y < 0)
                this.player.movementStateMachine.changeState(Player_1.MovementState.Descending);
            this.finished(Player_1.ActionState.Idle);
        }
    }
}
exports.default = Jump;
},{"../../../../Wolfie2D/Input/Input":64,"../../../../globals":137,"../../Player":14,"./Idle":19}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PlayerState_1 = require("../PlayerState");
class PlayerActionState extends PlayerState_1.default {
}
exports.default = PlayerActionState;
},{"../PlayerState":27}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const InAir_1 = require("./InAir");
const Player_1 = require("../../Player");
class Ascending extends InAir_1.default {
    onEnter(options) {
        super.onEnter(options);
        this.stateName = "Ascending";
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.player.velocity.y > 0)
            this.finished(Player_1.MovementState.Descending);
    }
}
exports.default = Ascending;
},{"../../Player":14,"./InAir":25}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const InAir_1 = require("./InAir");
const Player_1 = require("../../Player");
class Descending extends InAir_1.default {
    onEnter(options) {
        super.onEnter(options);
        this.stateName = "Descending";
        this.player.velocity.y = 0;
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.player.velocity.y < 0)
            this.finished(Player_1.MovementState.Ascending);
    }
}
exports.default = Descending;
},{"../../Player":14,"./InAir":25}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Input_1 = require("../../../../Wolfie2D/Input/Input");
const globals_1 = require("../../../../globals");
const Player_1 = require("../../Player");
const PlayerMovementState_1 = require("./PlayerMovementState");
const Idle_1 = require("../Actions/Idle");
const Dashing_1 = require("../Actions/Dashing");
const Vec2_1 = require("../../../../Wolfie2D/DataTypes/Vec2");
class Grounded extends PlayerMovementState_1.default {
    onEnter(options) {
        this.stateName = "Grounded";
        this.player.canDash = true;
    }
    performingAction() { }
    update(deltaT) {
        super.update(deltaT);
        const dir = this.getInputDirection();
        if (!this.isActionAnimationPlaying()) {
            if (dir.x != 0) {
                this.owner.animation.playIfNotAlready(Player_1.PlayerAnimations.Walk, true);
            }
            else {
                this.owner.animation.playIfNotAlready(Player_1.PlayerAnimations.Idle, true);
            }
        }
        if (!(this.player.actionStateMachine.getState() instanceof Dashing_1.default))
            this.player.speed = 300;
        if (Input_1.default.isJustPressed(globals_1.Action.Jump)) {
            this.player.actionStateMachine.changeState(Player_1.ActionState.Jump);
        }
        else {
            this.player.velocity.y = 0.00001;
        }
        if (Input_1.default.isJustPressed(globals_1.Action.Attack) &&
            this.player.actionStateMachine.getState() instanceof Idle_1.default) {
            this.player.actionStateMachine.changeState(Player_1.ActionState.Attack);
        }
        if (!this.owner.onGround)
            this.finished(Player_1.MovementState.Descending);
    }
    onExit() {
        this.player.lastGroundedPosition = this.owner.position
            .clone()
            .sub(new Vec2_1.default(this.getInputDirection().x * 40, 0));
        return {};
    }
}
exports.default = Grounded;
},{"../../../../Wolfie2D/DataTypes/Vec2":56,"../../../../Wolfie2D/Input/Input":64,"../../../../globals":137,"../../Player":14,"../Actions/Dashing":18,"../Actions/Idle":19,"./PlayerMovementState":26}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Player_1 = require("../../Player");
const PlayerMovementState_1 = require("./PlayerMovementState");
const Input_1 = require("../../../../Wolfie2D/Input/Input");
const globals_1 = require("../../../../globals");
const Jump_1 = require("../Actions/Jump");
const Idle_1 = require("../Actions/Idle");
const Vec2_1 = require("../../../../Wolfie2D/DataTypes/Vec2");
class InAir extends PlayerMovementState_1.default {
    onEnter(options) {
        this.stateName = "InAir";
        if (!this.isActionAnimationPlaying())
            this.owner.animation.playIfNotAlready(Player_1.PlayerAnimations.Jump);
    }
    update(deltaT) {
        super.update(deltaT);
        this.player.velocity.y = Math.min(this.player.gravity * deltaT + this.player.velocity.y, 10);
        if (Input_1.default.isJustPressed(globals_1.Action.Attack) &&
            (this.player.actionStateMachine.getState() instanceof Jump_1.default ||
                this.player.actionStateMachine.getState() instanceof Idle_1.default)) {
            if (Input_1.default.isPressed(globals_1.Action.Up))
                this.player.actionStateMachine.changeState(Player_1.ActionState.AttackUpper);
            else if (Input_1.default.isPressed(globals_1.Action.Down))
                this.player.actionStateMachine.changeState(Player_1.ActionState.AttackDown);
            else
                this.player.actionStateMachine.changeState(Player_1.ActionState.Attack);
        }
        // TODO: Remove in actual game release :)
        if (this.owner.position.y > 2000)
            this.owner.position = new Vec2_1.default(this.player.lastGroundedPosition.x, this.player.lastGroundedPosition.y - 150);
        if (this.owner.onGround) {
            this.finished(Player_1.MovementState.Grounded);
        }
    }
    onExit() {
        return {};
    }
}
exports.default = InAir;
},{"../../../../Wolfie2D/DataTypes/Vec2":56,"../../../../Wolfie2D/Input/Input":64,"../../../../globals":137,"../../Player":14,"../Actions/Idle":19,"../Actions/Jump":20,"./PlayerMovementState":26}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PlayerState_1 = require("../PlayerState");
const Player_1 = require("../../Player");
class PlayerMovementState extends PlayerState_1.default {
    update(deltaT) {
        let dir = this.getInputDirection();
        if (dir.x == -1) {
            this.owner.invertX = true;
        }
        else if (dir.x == 1) {
            this.owner.invertX = false;
        }
        this.player.velocity = this.owner.getLastVelocity();
        this.player.velocity.x = dir.x * this.player.speed * deltaT;
    }
    isActionAnimationPlaying() {
        return [
            Player_1.PlayerAnimations.ScytheSlash,
            Player_1.PlayerAnimations.Dash,
            Player_1.PlayerAnimations.ScytheUpper,
            Player_1.PlayerAnimations.ScytheDown,
        ].some(x => this.owner.animation.isPlaying(x));
    }
}
exports.default = PlayerMovementState;
},{"../../Player":14,"../PlayerState":27}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const State_1 = require("../../../Wolfie2D/DataTypes/State/State");
const Vec2_1 = require("../../../Wolfie2D/DataTypes/Vec2");
const Input_1 = require("../../../Wolfie2D/Input/Input");
class PlayerState extends State_1.default {
    constructor(parent, owner, player) {
        super(parent);
        this.owner = owner;
        this.player = player;
    }
    handleInput(event) { }
    /**
     * Get the inputs from the keyboard, or Vec2.Zero if nothing is being pressed
     */
    getInputDirection() {
        let direction = Vec2_1.default.ZERO;
        direction.x =
            (Input_1.default.isPressed("left") ? -1 : 0) + (Input_1.default.isPressed("right") ? 1 : 0);
        direction.y = Input_1.default.isJustPressed("jump") ? -1 : 0;
        return direction;
    }
}
exports.default = PlayerState;
},{"../../../Wolfie2D/DataTypes/State/State":53,"../../../Wolfie2D/DataTypes/Vec2":56,"../../../Wolfie2D/Input/Input":64}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Layers = void 0;
const Scene_1 = require("../../Wolfie2D/Scene/Scene");
const Player_1 = require("../Player/Player");
const GraphicTypes_1 = require("../../Wolfie2D/Nodes/Graphics/GraphicTypes");
const Camera_1 = require("../Camera");
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Color_1 = require("../../Wolfie2D/Utils/Color");
const globals_1 = require("../../globals");
const MainMenu_1 = require("./MainMenu");
const Input_1 = require("../../Wolfie2D/Input/Input");
const globals_2 = require("../../globals");
const Ghost_1 = require("../Enemy/Ghost/Ghost");
var Layers;
(function (Layers) {
    Layers["Main"] = "main";
    Layers["UI"] = "ui";
    Layers["Background"] = "bg";
    Layers["Hidden"] = "hidden";
    Layers["Debug"] = "debg";
    Layers["Pause"] = "pause";
})(Layers = exports.Layers || (exports.Layers = {}));
class GameLevel extends Scene_1.default {
    constructor(viewport, sceneManager, renderingManager, options) {
        super(viewport, sceneManager, renderingManager, options);
        this.textColor = new Color_1.default(231, 224, 241);
        this.healthBarColor = new Color_1.default(215, 74, 91);
        // TODO: change to type enemy when implemented
        this.enemies = new Array();
    }
    loadScene() {
        // reaper and animations
        this.load.spritesheet("reaper", "assets/spritesheets/Reaper/reaper.json");
        this.load.spritesheet("ScytheSlash", "assets/spritesheets/Reaper/ReaperVFX/ScytheSlash.json");
        this.load.spritesheet("ScytheUpper", "assets/spritesheets/Reaper/ReaperVFX/ScytheUpper.json");
        this.load.spritesheet("ScytheDown", "assets/spritesheets/Reaper/ReaperVFX/ScytheDown.json");
        // red soul enemy
        this.load.spritesheet("RedSoul", "assets/spritesheets/RedSoul/RedSoul.json");
        this.addLayer(Layers.Main, 1);
        this.addUILayer(Layers.UI);
        this.addUILayer(Layers.Pause).setHidden(true);
        this.addLayer(Layers.Debug, 2);
        this.addLayer(Layers.Hidden, 1).setHidden(true);
    }
    unloadScene() {
        this.resourceManager.keepSpritesheet("reaper");
    }
    startScene() {
        this.player = new Player_1.default(this.add.animatedSprite("reaper", Layers.Main));
        this.camera = new Camera_1.default(this.add.graphic(GraphicTypes_1.GraphicType.POINT, Layers.Hidden, {
            position: this.player.node.position.clone(),
        }), new Vec2_1.default(0, -80));
        this.camera.follow(this.player.node);
        this.playerStateLabel = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, Layers.Debug, {
            position: this.player.node.position.clone(),
            text: "",
        });
        this.playerStateLabel.font = "Mister Pixel";
        this.playerStateLabel.textColor = Color_1.default.WHITE;
        this.playerActionStateLabel = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, Layers.Debug, {
            position: this.player.node.position.clone(),
            text: "",
        });
        this.playerActionStateLabel.font = "Mister Pixel";
        this.playerActionStateLabel.textColor = Color_1.default.WHITE;
        this.viewport.follow(this.camera.node);
        this.viewport.setZoomLevel(2);
        this.viewport.setSmoothingFactor(0);
        this.initPauseLayer();
        this.initUI();
        // subscribe to events
        this.receiver.subscribe(globals_1.Events.MAIN_MENU);
        this.receiver.subscribe(globals_1.Events.ENEMY_DAMAGE);
        this.receiver.subscribe(globals_1.Events.PLAYER_DAMAGE);
        this.receiver.subscribe(globals_1.Events.ENEMY_DEATH);
        this.receiver.subscribe(globals_1.Events.PLAYER_DEATH);
        this.receiver.subscribe(globals_1.Events.PLAYER_HEAL);
        this.receiver.subscribe(globals_1.Events.LEVEL_END);
        this.receiver.subscribe(globals_1.Events.ENTER_LEVEL_END);
    }
    update(deltaT) {
        if (Input_1.default.isJustPressed(globals_2.Action.Pause)) {
            Input_1.default.disableInput();
            this.uiLayers.get(Layers.Pause).setHidden(false);
        }
        this.camera.update(deltaT);
        this.player.update(deltaT);
        super.update(deltaT);
        this.playerStateLabel.text = (this.player.movementStateMachine.getState()).stateName;
        this.playerStateLabel.position = this.player.node.position
            .clone()
            .add(new Vec2_1.default(0, -40));
        this.playerActionStateLabel.text = (this.player.actionStateMachine.getState()).stateName;
        this.playerActionStateLabel.position = this.player.node.position
            .clone()
            .add(new Vec2_1.default(0, -80));
        // handle events
        while (this.receiver.hasNextEvent()) {
            this.handleEvent(this.receiver.getNextEvent());
        }
    }
    handleEvent(event) {
        switch (event.type) {
            case globals_1.Events.MAIN_MENU: {
                this.sceneManager.changeToScene(MainMenu_1.default);
                break;
            }
            case globals_1.Events.ENEMY_DAMAGE: {
                let enemy = event.data.get("enemy");
                enemy.health -= 1;
                console.log(`Enemy: ${enemy.health}`);
                if (enemy.health <= 0)
                    this.emitter.fireEvent(globals_1.Events.ENEMY_DEATH, { enemy: enemy });
                break;
            }
            case globals_1.Events.PLAYER_DAMAGE: {
                this.player.health -= 1;
                this.healthBar.size.x = 600 * (this.player.health / 10);
                this.healthBar.position.x = 0;
                if (this.player.health <= 0)
                    this.emitter.fireEvent(globals_1.Events.PLAYER_DEATH);
                console.log(`Player: ${this.player.health}`);
                break;
            }
            case globals_1.Events.PLAYER_HEAL: {
                if (this.player.health + 1 <= this.player.maxHealth) {
                    this.player.health += 1;
                    this.healthBar.size.x = 600 * (this.player.health / 10);
                    this.healthBar.position.x = 0;
                    console.log(`Player: ${this.player.health}`);
                }
                break;
            }
            // TODO: Death animations
            case globals_1.Events.ENEMY_DEATH: {
                let enemy = event.data.get("enemy");
                // Heal player if red soul
                if (enemy.type === Ghost_1.GhostType.RED)
                    this.emitter.fireEvent(globals_1.Events.PLAYER_HEAL);
                enemy.node.destroy();
                this.enemies = this.enemies.filter(e => e !== enemy);
                break;
            }
            case globals_1.Events.PLAYER_DEATH: {
                // death anim -> some screen/main menu for now
                this.sceneManager.changeToScene(MainMenu_1.default);
                break;
            }
            case globals_1.Events.LEVEL_END: {
                /*
                  Rows in the collisions array represent each physics group by index,
                  first index of the first row is the first phys group itself,
                  second index in the second row is the second phys group itself, etc.
        
                  0 is does not collide, 1 is collide
                */
                let sceneOptions = {
                    physics: {
                        groupNames: [
                            globals_1.PhysicsGroups.PLAYER_PHYS,
                            globals_1.PhysicsGroups.ENEMY_PHYS,
                            globals_1.PhysicsGroups.HITBOX_PHYS,
                        ],
                        collisions: [
                            [0, 1, 1],
                            [0, 1, 1],
                            [0, 0, 0],
                        ],
                    },
                };
                this.sceneManager.changeToScene(this.nextLevel, {}, sceneOptions);
                break;
            }
            case globals_1.Events.ENTER_LEVEL_END: {
                if (this.enemies.length === 0)
                    this.emitter.fireEvent(globals_1.Events.LEVEL_END);
                break;
            }
        }
    }
    initUI() {
        this.healthBar = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, Layers.UI, {
            position: new Vec2_1.default(0, 30),
            text: "",
        });
        this.healthBar.size = new Vec2_1.default(600, 50);
        this.healthBar.backgroundColor = this.healthBarColor;
        this.healthBar.borderWidth = 2;
        this.healthBar.borderRadius = 0;
        const healthBarBorder = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, Layers.UI, {
            position: new Vec2_1.default(70, 30),
            text: "",
        });
        healthBarBorder.size = new Vec2_1.default(320, 50);
        healthBarBorder.borderColor = Color_1.default.WHITE;
        healthBarBorder.borderWidth = 2;
        healthBarBorder.borderRadius = 0;
    }
    initPauseLayer() {
        const buttonWidth = 450;
        const buttonHeight = 65;
        const resumeButton = this.newButton(new Vec2_1.default(100, 70), "RESUME", 52, Layers.Pause);
        resumeButton.size.x = buttonWidth;
        resumeButton.size.y = buttonHeight;
        resumeButton.onClick = () => {
            Input_1.default.enableInput();
            this.uiLayers.get(Layers.Pause).setHidden(true);
        };
        const menuButton = this.newButton(new Vec2_1.default(100, 70 + 38), "MENU", 52, Layers.Pause);
        menuButton.onClick = () => {
            Input_1.default.enableInput();
        };
        menuButton.onClickEventId = globals_1.Events.MAIN_MENU;
        menuButton.size.x = buttonWidth;
        menuButton.size.y = buttonHeight;
    }
    handleHealthChange(currentHealth, maxHealth) {
        console.log(currentHealth);
        let unit = this.healthBarBg.size.x / maxHealth;
        this.healthBar.size.set(this.healthBarBg.size.x - unit * (maxHealth - currentHealth), this.healthBarBg.size.y);
        this.healthBar.position.set(this.healthBarBg.position.x -
            (unit / 2 / this.getViewScale()) * (maxHealth - currentHealth), this.healthBarBg.position.y);
    }
    addLevelEnd(startingTile, size) {
        this.levelEndArea = this.add.graphic(GraphicTypes_1.GraphicType.RECT, Layers.Main, {
            position: startingTile,
            size: size,
        });
        this.levelEndArea.addPhysics(undefined, undefined, false, true);
        this.levelEndArea.setTrigger(globals_1.PhysicsGroups.PLAYER_PHYS, globals_1.Events.ENTER_LEVEL_END, null);
        this.levelEndArea.color = new Color_1.default(255, 255, 255, 1);
    }
    newButton(position, text, fontSize, layer) {
        const button = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, layer, {
            position: position,
            text: text,
        });
        button.borderColor = Color_1.default.WHITE;
        button.borderWidth = 2;
        button.borderRadius = 0;
        button.setPadding(new Vec2_1.default(50, 10));
        button.font = "MEGAPIX";
        button.fontSize = fontSize;
        button.textColor = this.textColor;
        button.backgroundColor = new Color_1.default(16, 14, 18, 1);
        button.scale.set(1 / this.viewport.getZoomLevel(), 1 / this.viewport.getZoomLevel());
        return button;
    }
}
exports.default = GameLevel;
},{"../../Wolfie2D/DataTypes/Vec2":56,"../../Wolfie2D/Input/Input":64,"../../Wolfie2D/Nodes/Graphics/GraphicTypes":74,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":88,"../../Wolfie2D/Scene/Scene":125,"../../Wolfie2D/Utils/Color":131,"../../globals":137,"../Camera":1,"../Enemy/Ghost/Ghost":2,"../Player/Player":14,"./MainMenu":35}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameLevel_1 = require("./GameLevel");
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const Ghost_1 = require("../Enemy/Ghost/Ghost");
const GameLevel_2 = require("./GameLevel");
const Ghost_2 = require("../Enemy/Ghost/Ghost");
const Level2_1 = require("./Level2");
const GhostPositions = [
    new Vec2_1.default(3840, 416),
    new Vec2_1.default(4160, 512),
    new Vec2_1.default(3904, 448),
];
class Level1 extends GameLevel_1.default {
    loadScene() {
        super.loadScene();
        this.load.tilemap("tilemap", "assets/tilemaps/Debug/Level1.json");
    }
    startScene() {
        super.startScene();
        this.player.node.position = new Vec2_1.default(100, 1000);
        this.camera.node.position = this.player.node.position.clone();
        this.add.tilemap("tilemap", new Vec2_1.default(1, 1));
        this.viewport.setBounds(0, 0, 6400, 1280);
        this.nextLevel = Level2_1.default;
        this.addLevelEnd(new Vec2_1.default(4576, 160), new Vec2_1.default(32, 128));
        this.initializeGhosts();
    }
    initializeGhosts() {
        for (let i = 0; i < GhostPositions.length; i++) {
            const ghost = new Ghost_1.default(this.add.animatedSprite("RedSoul", GameLevel_2.Layers.Main), GhostPositions[i], Ghost_2.GhostType.RED);
            this.enemies.push(ghost);
        }
    }
}
exports.default = Level1;
},{"../../Wolfie2D/DataTypes/Vec2":56,"../Enemy/Ghost/Ghost":2,"./GameLevel":28,"./Level2":30}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameLevel_1 = require("./GameLevel");
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
class Level2 extends GameLevel_1.default {
    loadScene() {
        super.loadScene();
        this.load.tilemap("tilemap", "assets/tilemaps/Debug/Level1.json");
    }
    startScene() {
        super.startScene();
        this.player.node.position = new Vec2_1.default(100, 1000);
        this.camera.node.position = this.player.node.position.clone();
        this.add.tilemap("tilemap", new Vec2_1.default(1, 1));
        this.viewport.setBounds(0, 0, 6400, 1280);
    }
}
exports.default = Level2;
},{"../../Wolfie2D/DataTypes/Vec2":56,"./GameLevel":28}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameLevel_1 = require("./GameLevel");
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
class Level3 extends GameLevel_1.default {
    loadScene() {
        super.loadScene();
        this.load.tilemap("tilemap", "assets/tilemaps/Debug/Level1.json");
    }
    startScene() {
        super.startScene();
        this.player.node.position = new Vec2_1.default(100, 1000);
        this.camera.node.position = this.player.node.position.clone();
        this.add.tilemap("tilemap", new Vec2_1.default(1, 1));
        this.viewport.setBounds(0, 0, 6400, 1280);
    }
}
exports.default = Level3;
},{"../../Wolfie2D/DataTypes/Vec2":56,"./GameLevel":28}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameLevel_1 = require("./GameLevel");
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
class Level4 extends GameLevel_1.default {
    loadScene() {
        super.loadScene();
        this.load.tilemap("tilemap", "assets/tilemaps/Debug/Level1.json");
    }
    startScene() {
        super.startScene();
        this.player.node.position = new Vec2_1.default(100, 1000);
        this.camera.node.position = this.player.node.position.clone();
        this.add.tilemap("tilemap", new Vec2_1.default(1, 1));
        this.viewport.setBounds(0, 0, 6400, 1280);
    }
}
exports.default = Level4;
},{"../../Wolfie2D/DataTypes/Vec2":56,"./GameLevel":28}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameLevel_1 = require("./GameLevel");
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
class Level5 extends GameLevel_1.default {
    loadScene() {
        super.loadScene();
        this.load.tilemap("tilemap", "assets/tilemaps/Debug/Level1.json");
    }
    startScene() {
        super.startScene();
        this.player.node.position = new Vec2_1.default(100, 1000);
        this.camera.node.position = this.player.node.position.clone();
        this.add.tilemap("tilemap", new Vec2_1.default(1, 1));
        this.viewport.setBounds(0, 0, 6400, 1280);
    }
}
exports.default = Level5;
},{"../../Wolfie2D/DataTypes/Vec2":56,"./GameLevel":28}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameLevel_1 = require("./GameLevel");
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
class Level6 extends GameLevel_1.default {
    loadScene() {
        super.loadScene();
        this.load.tilemap("tilemap", "assets/tilemaps/Debug/Level1.json");
    }
    startScene() {
        super.startScene();
        this.player.node.position = new Vec2_1.default(100, 1000);
        this.camera.node.position = this.player.node.position.clone();
        this.add.tilemap("tilemap", new Vec2_1.default(1, 1));
        this.viewport.setBounds(0, 0, 6400, 1280);
    }
}
exports.default = Level6;
},{"../../Wolfie2D/DataTypes/Vec2":56,"./GameLevel":28}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scene_1 = require("../../Wolfie2D/Scene/Scene");
const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const Color_1 = require("../../Wolfie2D/Utils/Color");
const Label_1 = require("../../Wolfie2D/Nodes/UIElements/Label");
const globals_1 = require("../../globals");
const Level1_1 = require("./Level1");
const Level2_1 = require("./Level2");
const Level3_1 = require("./Level3");
const Level4_1 = require("./Level4");
const Level5_1 = require("./Level5");
const Level6_1 = require("./Level6");
var Layers;
(function (Layers) {
    Layers["Main"] = "main";
    Layers["Levels"] = "level";
    Layers["Controls"] = "control";
    Layers["Help"] = "help";
    Layers["Back"] = "back";
})(Layers || (Layers = {}));
class MainMenu extends Scene_1.default {
    constructor() {
        super(...arguments);
        this.textColor = new Color_1.default(231, 224, 241);
    }
    loadScene() {
        this.load.image("logo", "/assets/images/autopsy_logo.png");
        this.screens = {
            [Layers.Main]: this.addUILayer(Layers.Main),
            [Layers.Levels]: this.addUILayer(Layers.Levels),
            [Layers.Controls]: this.addUILayer(Layers.Controls),
            [Layers.Help]: this.addUILayer(Layers.Help),
            [Layers.Back]: this.addUILayer(Layers.Back),
        };
    }
    startScene() {
        // Center the viewport
        const halfSize = this.viewport.getHalfSize();
        this.viewport.setFocus(halfSize);
        this.viewport.setZoomLevel(1);
        this.currentScreen = Layers.Main;
        for (const screensKey in this.screens)
            this.screens[screensKey].setHidden(true);
        this.initMainMenu();
        this.initLevelsLayer();
        this.initHelpLayer();
        this.initControlsMenu();
        this.initBackLayer();
        this.screens[Layers.Main].setHidden(false);
    }
    changeLayer(newLayer) {
        this.screens[this.currentScreen].disable();
        this.screens[newLayer].enable();
        this.currentScreen = newLayer;
        this.screens[Layers.Back].setHidden(this.currentScreen == Layers.Main);
    }
    initBackLayer() {
        const buttonWidth = 120;
        const backButton = this.newButton(new Vec2_1.default(buttonWidth / 2, this.viewport.getHalfSize().y * 2 - 100), "BACK", 40, Layers.Back);
        backButton.size.x = buttonWidth;
        backButton.size.y = 70;
        backButton.onClick = () => {
            this.changeLayer(Layers.Main);
        };
    }
    initHelpLayer() {
        [
            "You play as an undertaker and have to hunt souls that",
            " have escaped from hell using an arsenal of weapons. ",
        ].forEach((value, index) => {
            const helpLine = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, Layers.Help, {
                position: new Vec2_1.default(this.viewport.getCenter().x, 100 + index * 40),
                text: value,
            });
            helpLine.textColor = this.textColor;
            helpLine.font = "Mister Pixel";
        });
        const authorLineWidth = 500;
        const authorLine = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, Layers.Help, {
            position: new Vec2_1.default(this.viewport.getHalfSize().x * 2 - authorLineWidth / 2 - 10, this.viewport.getHalfSize().y * 2 - 20),
            text: "By Alvin Mei, Yu-Xiang Zheng, Andrew Ton",
        });
        authorLine.size.x = authorLineWidth;
        authorLine.setHAlign(Label_1.HAlign.RIGHT);
        authorLine.textColor = this.textColor;
        authorLine.font = "Mister Pixel";
    }
    initLevelsLayer() {
        const fontSize = 40;
        const buttonSize = new Vec2_1.default(70, 70);
        const paddingSize = new Vec2_1.default(15, 15);
        const levelOne = this.newButton(new Vec2_1.default(240, 590), "1", fontSize, Layers.Levels);
        const levelTwo = this.newButton(new Vec2_1.default(380, 290), "2", fontSize, Layers.Levels);
        const levelThree = this.newButton(new Vec2_1.default(560, 480), "3", fontSize, Layers.Levels);
        const levelFour = this.newButton(new Vec2_1.default(780, 550), "4", fontSize, Layers.Levels);
        const levelFive = this.newButton(new Vec2_1.default(950, 350), "5", fontSize, Layers.Levels);
        const levelSix = this.newButton(new Vec2_1.default(820, 120), "6", fontSize, Layers.Levels);
        levelOne.font = "Mister Pixel";
        levelOne.setPadding(paddingSize);
        levelOne.size = buttonSize;
        levelOne.onClick = () => {
            this.sceneManager.changeToScene(Level1_1.default);
        };
        levelTwo.font = "Mister Pixel";
        levelTwo.setPadding(paddingSize);
        levelTwo.size = buttonSize;
        levelTwo.onClick = () => {
            this.sceneManager.changeToScene(Level2_1.default);
        };
        levelThree.font = "Mister Pixel";
        levelThree.setPadding(paddingSize);
        levelThree.size = buttonSize;
        levelThree.onClick = () => {
            this.sceneManager.changeToScene(Level3_1.default);
        };
        levelFour.font = "Mister Pixel";
        levelFour.setPadding(paddingSize);
        levelFour.size = buttonSize;
        levelFour.onClick = () => {
            this.sceneManager.changeToScene(Level4_1.default);
        };
        levelFive.font = "Mister Pixel";
        levelFive.setPadding(paddingSize);
        levelFive.size = buttonSize;
        levelFive.onClick = () => {
            this.sceneManager.changeToScene(Level5_1.default);
        };
        levelSix.font = "Mister Pixel";
        levelSix.setPadding(paddingSize);
        levelSix.size = buttonSize;
        levelSix.onClick = () => {
            this.sceneManager.changeToScene(Level6_1.default);
        };
    }
    initControlsMenu() {
        [
            "(A), (D): Move left and right respectively.",
            "(Space): Jump.",
            "(J): Attack.",
            "(Shift): Dash.",
            "(ESC): Pause game.",
        ].forEach((value, index) => {
            const controlLine = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, Layers.Controls, {
                position: new Vec2_1.default(600, 200 + 40 * index),
                text: value,
            });
            controlLine.textColor = this.textColor;
            controlLine.font = "Mister Pixel";
            controlLine.size.x = 1000;
            controlLine.setHAlign(Label_1.HAlign.LEFT);
        });
    }
    initMainMenu() {
        this.add.sprite("logo", Layers.Main).position = new Vec2_1.default(this.viewport.getHalfSize().x, 200);
        const buttonWidth = 500;
        const playButton = this.newButton(new Vec2_1.default(buttonWidth / 2, 400), "PLAY", 60, Layers.Main);
        playButton.setHAlign(Label_1.HAlign.LEFT);
        playButton.size.x = buttonWidth;
        playButton.size.y = 80;
        playButton.onClick = () => {
            let sceneOptions = {
                physics: {
                    groupNames: [
                        globals_1.PhysicsGroups.PLAYER_PHYS,
                        globals_1.PhysicsGroups.ENEMY_PHYS,
                        globals_1.PhysicsGroups.HITBOX_PHYS,
                    ],
                    collisions: [
                        [0, 1, 1],
                        [0, 1, 1],
                        [0, 0, 0],
                    ],
                },
            };
            this.sceneManager.changeToScene(Level1_1.default, {}, sceneOptions);
        };
        const levelsButton = this.newButton(new Vec2_1.default(buttonWidth / 2, 400 + 90), "LEVELS", 60, Layers.Main);
        levelsButton.setHAlign(Label_1.HAlign.LEFT);
        levelsButton.size.x = buttonWidth;
        levelsButton.size.y = 80;
        levelsButton.onClick = () => this.changeLayer(Layers.Levels);
        const controlsButton = this.newButton(new Vec2_1.default(buttonWidth / 2, 400 + 90 * 2), "CONTROLS", 60, Layers.Main);
        controlsButton.setHAlign(Label_1.HAlign.LEFT);
        controlsButton.size.x = buttonWidth;
        controlsButton.size.y = 80;
        controlsButton.onClick = () => this.changeLayer(Layers.Controls);
        const helpButtonWidth = 130;
        const helpButton = this.newButton(new Vec2_1.default(this.viewport.getHalfSize().x * 2 - helpButtonWidth / 2, 700), "HELP", 50, Layers.Main);
        helpButton.setHAlign(Label_1.HAlign.CENTER);
        helpButton.size.x = helpButtonWidth;
        helpButton.size.y = 80;
        helpButton.onClick = () => this.changeLayer(Layers.Help);
    }
    newButton(position, text, fontSize, layer) {
        const button = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, layer, {
            position: position,
            text: text,
        });
        button.backgroundColor = Color_1.default.TRANSPARENT;
        button.borderColor = Color_1.default.WHITE;
        button.borderWidth = 2;
        button.borderRadius = 0;
        button.setPadding(new Vec2_1.default(50, 10));
        button.font = "MEGAPIX";
        button.fontSize = fontSize;
        button.textColor = this.textColor;
        const transWhite = new Color_1.default(255, 255, 255, 0.1);
        const invisibleWhite = new Color_1.default(255, 255, 255, 0);
        button.onEnter = () => {
            button.backgroundColor = transWhite;
        };
        button.onLeave = () => {
            button.backgroundColor = invisibleWhite;
        };
        return button;
    }
}
exports.default = MainMenu;
},{"../../Wolfie2D/DataTypes/Vec2":56,"../../Wolfie2D/Nodes/UIElements/Label":85,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":88,"../../Wolfie2D/Scene/Scene":125,"../../Wolfie2D/Utils/Color":131,"../../globals":137,"./Level1":29,"./Level2":30,"./Level3":31,"./Level4":32,"./Level5":33,"./Level6":34}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * A manager class for all of the AI in a scene.
 * Keeps a list of registered actors and handles AI generation for actors.
 */
class AIManager {
    constructor() {
        this.actors = new Array();
        this.registeredAI = new Map_1.default();
    }
    /**
     * Registers an actor with the AIManager
     * @param actor The actor to register
     */
    registerActor(actor) {
        this.actors.push(actor);
    }
    removeActor(actor) {
        let index = this.actors.indexOf(actor);
        if (index !== -1) {
            this.actors.splice(index, 1);
        }
    }
    /**
     * Registers an AI with the AIManager for use later on
     * @param name The name of the AI to register
     * @param constr The constructor for the AI
     */
    registerAI(name, constr) {
        this.registeredAI.add(name, constr);
    }
    /**
     * Generates an AI instance from its name
     * @param name The name of the AI to add
     * @returns A new AI instance
     */
    generateAI(name) {
        if (this.registeredAI.has(name)) {
            return new (this.registeredAI.get(name))();
        }
        else {
            throw `Cannot create AI with name ${name}, no AI with that name is registered`;
        }
    }
    update(deltaT) {
        // Run the ai for every active actor
        this.actors.forEach(actor => {
            if (actor.aiActive)
                actor.ai.update(deltaT);
        });
    }
}
exports.default = AIManager;
},{"../DataTypes/Map":43}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StateMachine_1 = require("../DataTypes/State/StateMachine");
/**
 * A version of a @reference[StateMachine] that is configured to work as an AI controller for a @reference[GameNode]
 */
class StateMachineAI extends StateMachine_1.default {
    // @implemented
    initializeAI(owner, config) { }
    // @implemented
    destroy() {
        // Get rid of our reference to the owner
        delete this.owner;
        this.receiver.destroy();
    }
    // @implemented
    activate(options) { }
}
exports.default = StateMachineAI;
},{"../DataTypes/State/StateMachine":54}],38:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A placeholder function for No Operation. Does nothing
 */
const NullFunc = () => { };
exports.default = NullFunc;
},{}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A linked-list for the edges in a @reference[Graph].
 */
class EdgeNode {
    /**
     * Creates a new EdgeNode
     * @param index The index of the node this edge connects to
     * @param weight The weight of this edge
     */
    constructor(index, weight) {
        this.y = index;
        this.next = null;
        this.weight = weight ? weight : 1;
    }
}
exports.default = EdgeNode;
},{}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_V = void 0;
const EdgeNode_1 = require("./EdgeNode");
exports.MAX_V = 100;
/**
 * An implementation of a graph data structure using edge lists. Inspired by The Algorithm Design Manual.
 */
class Graph {
    /**
     * Constructs a new graph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        this.directed = directed;
        this.weighted = false;
        this.numVertices = 0;
        this.numEdges = 0;
        this.edges = new Array(exports.MAX_V);
        this.degree = new Array(exports.MAX_V);
    }
    /** Adds a node to this graph and returns the index of it
     * @returns The index of the new node
     */
    addNode() {
        this.numVertices++;
        return this.numVertices;
    }
    /** Adds an edge between node x and y, with an optional weight
     * @param x The index of the start of the edge
     * @param y The index of the end of the edge
     * @param weight The optional weight of the new edge
     */
    addEdge(x, y, weight) {
        let edge = new EdgeNode_1.default(y, weight);
        if (this.edges[x]) {
            edge.next = this.edges[x];
        }
        this.edges[x] = edge;
        if (!this.directed) {
            edge = new EdgeNode_1.default(x, weight);
            if (this.edges[y]) {
                edge.next = this.edges[y];
            }
            this.edges[y] = edge;
        }
        this.numEdges += 1;
    }
    /**
     * Checks whether or not an edge exists between two nodes.
     * This check is directional if this is a directed graph.
     * @param x The first node
     * @param y The second node
     * @returns true if an edge exists, false otherwise
     */
    edgeExists(x, y) {
        let edge = this.edges[x];
        while (edge !== null) {
            if (edge.y === y) {
                return true;
            }
            edge = edge.next;
        }
    }
    /**
     * Gets the edge list associated with node x
     * @param x The index of the node
     * @returns The head of a linked-list of edges
     */
    getEdges(x) {
        return this.edges[x];
    }
    /**
     * Gets the degree associated with node x
     * @param x The index of the node
     */
    getDegree(x) {
        return this.degree[x];
    }
    /**
     * Converts the specifed node into a string
     * @param index The index of the node to convert to a string
     * @returns The string representation of the node: "Node x"
     */
    nodeToString(index) {
        return "Node " + index;
    }
    /**
     * Converts the Graph into a string format
     * @returns The graph as a string
     */
    toString() {
        let retval = "";
        for (let i = 0; i < this.numVertices; i++) {
            let edge = this.edges[i];
            let edgeStr = "";
            while (edge !== undefined && edge !== null) {
                edgeStr += edge.y.toString();
                if (this.weighted) {
                    edgeStr += " (" + edge.weight + ")";
                }
                if (edge.next !== null) {
                    edgeStr += ", ";
                }
                edge = edge.next;
            }
            retval += this.nodeToString(i) + ": " + edgeStr + "\n";
        }
        return retval;
    }
}
exports.default = Graph;
},{"./EdgeNode":39}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graph_1 = require("./Graph");
/**
 * An extension of Graph that has nodes with positions in 2D space.
 * This is a weighted graph (though not inherently directd)
 */
class PositionGraph extends Graph_1.default {
    /**
     * Createes a new PositionGraph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        super(directed);
        this.debugRender = () => {
            // for(let point of this.positions){
            // 	ctx.fillRect((point.x - origin.x - 4)*zoom, (point.y - origin.y - 4)*zoom, 8, 8);
            // }
        };
        this.positions = new Array(Graph_1.MAX_V);
    }
    /**
     * Adds a positioned node to this graph
     * @param position The position of the node to add
     * @returns The index of the added node
     */
    addPositionedNode(position) {
        this.positions[this.numVertices] = position;
        return this.addNode();
    }
    /**
     * Changes the position of a node.
     * Automatically adjusts the weights of the graph tied to this node.
     * As such, be warned that this function has an O(n + m) running time, and use it sparingly.
     * @param index The index of the node
     * @param position The new position of the node
     */
    setNodePosition(index, position) {
        this.positions[index] = position;
        // Recalculate all weights associated with this index
        for (let i = 0; i < this.numEdges; i++) {
            let edge = this.edges[i];
            while (edge !== null) {
                // If this node is on either side of the edge, recalculate weight
                if (i === index || edge.y === index) {
                    edge.weight = this.positions[i].distanceTo(this.positions[edge.y]);
                }
                edge = edge.next;
            }
        }
    }
    /**
     * Gets the position of a node
     * @param index The index of the node
     * @returns The position of the node
     */
    getNodePosition(index) {
        return this.positions[index];
    }
    /**
     * Adds an edge to this graph between node x and y.
     * Automatically calculates the weight of the edge as the distance between the nodes.
     * @param x The beginning of the edge
     * @param y The end of the edge
     */
    addEdge(x, y) {
        if (!this.positions[x] || !this.positions[y]) {
            throw "Can't add edge to un-positioned node!";
        }
        // Weight is the distance between the nodes
        let weight = this.positions[x].distanceTo(this.positions[y]);
        super.addEdge(x, y, weight);
    }
    // @override
    nodeToString(index) {
        return "Node " + index + " - " + this.positions[index].toString();
    }
}
exports.default = PositionGraph;
},{"./Graph":40}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRegion = void 0;
function isRegion(arg) {
    return arg && arg.size && arg.scale && arg.boundary;
}
exports.isRegion = isRegion;
},{}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Associates strings with elements of type T
 */
class Map {
    /** Creates a new map */
    constructor() {
        this.map = {};
    }
    /**
     * Adds a value T stored at a key.
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    add(key, value) {
        this.map[key] = value;
    }
    /**
     * Get the value associated with a key.
     * @param key The key of the item
     * @returns The item at the key or undefined
     */
    get(key) {
        return this.map[key];
    }
    /**
     * An alias of add. Sets the value stored at key to the new specified value
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    set(key, value) {
        this.add(key, value);
    }
    /**
     * Returns true if there is a value stored at the specified key, false otherwise.
     * @param key The key to check
     * @returns A boolean representing whether or not there is an item at the given key.
     */
    has(key) {
        return this.map[key] !== undefined;
    }
    /**
     * Returns an array of all of the keys in this map.
     * @returns An array containing all keys in the map.
     */
    keys() {
        return Object.keys(this.map);
    }
    // @implemented
    forEach(func) {
        Object.keys(this.map).forEach(key => func(key));
    }
    /**
     * Deletes an item associated with a key
     * @param key The key at which to delete an item
     */
    delete(key) {
        delete this.map[key];
    }
    // @implemented
    clear() {
        this.forEach(key => delete this.map[key]);
    }
    /**
     * Converts this map to a string representation.
     * @returns The string representation of this map.
     */
    toString() {
        let str = "";
        this.forEach(key => (str += key + " -> " + this.get(key).toString() + "\n"));
        return str;
    }
}
exports.default = Map;
},{}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("./Vec2");
/** A 4x4 matrix0 */
class Mat4x4 {
    constructor() {
        this.mat = new Float32Array([
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ]);
    }
    // Static members
    static get IDENTITY() {
        return new Mat4x4().identity();
    }
    static get ZERO() {
        return new Mat4x4().zero();
    }
    // Accessors
    set _00(x) {
        this.mat[0] = x;
    }
    set(col, row, value) {
        if (col < 0 || col > 3 || row < 0 || row > 3) {
            throw `Error - index (${col}, ${row}) is out of bounds for Mat4x4`;
        }
        this.mat[row * 4 + col] = value;
        return this;
    }
    get(col, row) {
        return this.mat[row * 4 + col];
    }
    setAll(...items) {
        this.mat.set(items);
        return this;
    }
    identity() {
        return this.setAll(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    zero() {
        return this.setAll(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    /**
     * Makes this Mat4x4 a rotation matrix of the specified number of radians ccw
     * @param zRadians The number of radians to rotate
     * @returns this Mat4x4
     */
    rotate(zRadians) {
        return this.setAll(Math.cos(zRadians), -Math.sin(zRadians), 0, 0, Math.sin(zRadians), Math.cos(zRadians), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Turns this Mat4x4 into a translation matrix of the specified translation
     * @param translation The translation in x and y
     * @returns this Mat4x4
     */
    translate(translation) {
        // If translation is a vec, get its array
        if (translation instanceof Vec2_1.default) {
            translation = translation.toArray();
        }
        return this.setAll(1, 0, 0, translation[0], 0, 1, 0, translation[1], 0, 0, 1, 0, 0, 0, 0, 1);
    }
    scale(scale) {
        // Make sure scale is a float32Array
        if (scale instanceof Vec2_1.default) {
            scale = scale.toArray();
        }
        else if (!(scale instanceof Float32Array)) {
            scale = new Float32Array([scale, scale]);
        }
        return this.setAll(scale[0], 0, 0, 0, 0, scale[1], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Returns a new Mat4x4 that represents the right side multiplication THIS x OTHER
     * @param other The other Mat4x4 to multiply by
     * @returns a new Mat4x4 containing the product of these two Mat4x4s
     */
    mult(other, out) {
        let temp = new Float32Array(16);
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
                let value = 0;
                for (let k = 0; k < 4; k++) {
                    value += this.get(k, i) * other.get(j, k);
                }
                temp[j * 4 + i] = value;
            }
        }
        if (out !== undefined) {
            return out.setAll(...temp);
        }
        else {
            return new Mat4x4().setAll(...temp);
        }
    }
    /**
     * Multiplies all given matricies in order. e.g. MULT(A, B, C) -> A*B*C
     * @param mats A list of Mat4x4s to multiply in order
     * @returns A new Mat4x4 holding the result of the operation
     */
    static MULT(...mats) {
        // Create a new array
        let temp = Mat4x4.IDENTITY;
        // Multiply by every array in order, in place
        for (let i = 0; i < mats.length; i++) {
            temp.mult(mats[i], temp);
        }
        return temp;
    }
    toArray() {
        return this.mat;
    }
    toString() {
        return (`|${this.mat[0].toFixed(2)}, ${this.mat[1].toFixed(2)}, ${this.mat[2].toFixed(2)}, ${this.mat[3].toFixed(2)}|\n` +
            `|${this.mat[4].toFixed(2)}, ${this.mat[5].toFixed(2)}, ${this.mat[6].toFixed(2)}, ${this.mat[7].toFixed(2)}|\n` +
            `|${this.mat[8].toFixed(2)}, ${this.mat[9].toFixed(2)}, ${this.mat[10].toFixed(2)}, ${this.mat[11].toFixed(2)}|\n` +
            `|${this.mat[12].toFixed(2)}, ${this.mat[13].toFixed(2)}, ${this.mat[14].toFixed(2)}, ${this.mat[15].toFixed(2)}|`);
    }
}
exports.default = Mat4x4;
},{"./Vec2":56}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A class that contains the area of overlap of two colliding objects to allow for sorting by the physics system.
 */
class AreaCollision {
    /**
     * Creates a new AreaCollision object
     * @param area The area of the collision
     * @param collider The other collider
     */
    constructor(area, collider, other, type, tile) {
        this.area = area;
        this.collider = collider;
        this.other = other;
        this.type = type;
        this.tile = tile;
    }
}
exports.default = AreaCollision;
},{}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
/**
 * An object representing the data collected from a physics hit between two geometric objects.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class Hit {
    constructor() {
        /** The near times of the collision */
        this.nearTimes = Vec2_1.default.ZERO;
        /** The position of the collision */
        this.pos = Vec2_1.default.ZERO;
        /** The overlap distance of the hit */
        this.delta = Vec2_1.default.ZERO;
        /** The normal vector of the hit */
        this.normal = Vec2_1.default.ZERO;
    }
}
exports.default = Hit;
},{"../Vec2":56}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A FIFO queue with elements of type T
 */
class Queue {
    /**
     * Constructs a new queue
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.q = new Array(this.MAX_ELEMENTS);
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }
    /**
     * Adds an item to the back of the queue
     * @param item The item to add to the back of the queue
     */
    enqueue(item) {
        if ((this.tail + 1) % this.MAX_ELEMENTS === this.head) {
            throw new Error("Queue full - cannot add element");
        }
        this.size += 1;
        this.q[this.tail] = item;
        this.tail = (this.tail + 1) % this.MAX_ELEMENTS;
    }
    /**
     * Retrieves an item from the front of the queue
     * @returns The item at the front of the queue
     */
    dequeue() {
        if (this.head === this.tail) {
            throw new Error("Queue empty - cannot remove element");
        }
        this.size -= 1;
        let item = this.q[this.head];
        // Now delete the item
        delete this.q[this.head];
        this.head = (this.head + 1) % this.MAX_ELEMENTS;
        return item;
    }
    /**
     * Returns the item at the front of the queue, but does not remove it
     * @returns The item at the front of the queue
     */
    peekNext() {
        if (this.head === this.tail) {
            throw "Queue empty - cannot get element";
        }
        let item = this.q[this.head];
        return item;
    }
    /**
     * Returns true if the queue has items in it, false otherwise
     * @returns A boolean representing whether or not this queue has items
     */
    hasItems() {
        return this.head !== this.tail;
    }
    /**
     * Returns the number of elements in the queue.
     * @returns The size of the queue
     */
    getSize() {
        return this.size;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.q[index]);
        this.size = 0;
        this.head = this.tail;
    }
    // @implemented
    forEach(func) {
        let i = this.head;
        while (i !== this.tail) {
            func(this.q[i], i);
            i = (i + 1) % this.MAX_ELEMENTS;
        }
    }
    /**
     * Converts this queue into a string format
     * @returns A string representing this queue
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Queue;
},{}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A container for info about a webGL shader program */
class WebGLProgramType {
    /**
     * Deletes this shader program
     */
    delete(gl) {
        // Clean up all aspects of this program
        if (this.program) {
            gl.deleteProgram(this.program);
        }
        if (this.vertexShader) {
            gl.deleteShader(this.vertexShader);
        }
        if (this.fragmentShader) {
            gl.deleteShader(this.fragmentShader);
        }
    }
}
exports.default = WebGLProgramType;
},{}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Shape_1 = require("./Shape");
const Vec2_1 = require("../Vec2");
const MathUtils_1 = require("../../Utils/MathUtils");
const Circle_1 = require("./Circle");
const Hit_1 = require("../Physics/Hit");
/**
 * An Axis-Aligned Bounding Box. In other words, a rectangle that is always aligned to the x-y grid.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class AABB extends Shape_1.default {
    /**
     * Creates a new AABB
     * @param center The center of the AABB
     * @param halfSize The half size of the AABB - The distance from the center to an edge in x and y
     */
    constructor(center, halfSize) {
        super();
        this.center = center ? center : new Vec2_1.default(0, 0);
        this.halfSize = halfSize ? halfSize : new Vec2_1.default(0, 0);
    }
    /** Returns a point representing the top left corner of the AABB */
    get topLeft() {
        return new Vec2_1.default(this.left, this.top);
    }
    /** Returns a point representing the top right corner of the AABB */
    get topRight() {
        return new Vec2_1.default(this.right, this.top);
    }
    /** Returns a point representing the bottom left corner of the AABB */
    get bottomLeft() {
        return new Vec2_1.default(this.left, this.bottom);
    }
    /** Returns a point representing the bottom right corner of the AABB */
    get bottomRight() {
        return new Vec2_1.default(this.right, this.bottom);
    }
    // @override
    getBoundingRect() {
        return this.clone();
    }
    // @override
    getBoundingCircle() {
        let r = Math.max(this.hw, this.hh);
        return new Circle_1.default(this.center.clone(), r);
    }
    // @deprecated
    getHalfSize() {
        return this.halfSize;
    }
    // @deprecated
    setHalfSize(halfSize) {
        this.halfSize = halfSize;
    }
    // TODO - move these all to the Shape class
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return (point.x >= this.x - this.hw &&
            point.x <= this.x + this.hw &&
            point.y >= this.y - this.hh &&
            point.y <= this.y + this.hh);
    }
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    intersectPoint(point) {
        let dx = point.x - this.x;
        let px = this.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = point.y - this.y;
        let py = this.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * A boolean check of whether this AABB contains a point with soft left and top boundaries.
     * In other words, if the top left is (0, 0), the point (0, 0) is not in the AABB
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPointSoft(point) {
        return (point.x > this.x - this.hw &&
            point.x <= this.x + this.hw &&
            point.y > this.y - this.hh &&
            point.y <= this.y + this.hh);
    }
    /**
     * Returns the data from the intersection of this AABB with a line segment from a point in a direction
     * @param point The point that the line segment starts from
     * @param delta The direction and distance of the segment
     * @param padding Pads the AABB to make it wider for the intersection test
     * @returns The Hit object representing the intersection, or null if there was no intersection
     */
    intersectSegment(point, delta, padding) {
        let paddingX = padding ? padding.x : 0;
        let paddingY = padding ? padding.y : 0;
        let scaleX = 1 / delta.x;
        let scaleY = 1 / delta.y;
        let signX = MathUtils_1.default.sign(scaleX);
        let signY = MathUtils_1.default.sign(scaleY);
        let tnearx = scaleX * (this.x - signX * (this.hw + paddingX) - point.x);
        let tneary = scaleY * (this.y - signY * (this.hh + paddingY) - point.y);
        let tfarx = scaleX * (this.x + signX * (this.hw + paddingX) - point.x);
        let tfary = scaleY * (this.y + signY * (this.hh + paddingY) - point.y);
        if (tnearx > tfary || tneary > tfarx) {
            // We aren't colliding - we clear one axis before intersecting another
            return null;
        }
        let tnear = Math.max(tnearx, tneary);
        // Double check for NaNs
        if (tnearx !== tnearx) {
            tnear = tneary;
        }
        else if (tneary !== tneary) {
            tnear = tnearx;
        }
        let tfar = Math.min(tfarx, tfary);
        if (tnear === -Infinity) {
            return null;
        }
        if (tnear >= 1 || tfar <= 0) {
            return null;
        }
        // We are colliding
        let hit = new Hit_1.default();
        hit.time = MathUtils_1.default.clamp01(tnear);
        hit.nearTimes.x = tnearx;
        hit.nearTimes.y = tneary;
        if (tnearx > tneary) {
            // We hit on the left or right size
            hit.normal.x = -signX;
            hit.normal.y = 0;
        }
        else if (Math.abs(tnearx - tneary) < 0.0001) {
            // We hit on the corner
            hit.normal.x = -signX;
            hit.normal.y = -signY;
            hit.normal.normalize();
        }
        else {
            // We hit on the top or bottom
            hit.normal.x = 0;
            hit.normal.y = -signY;
        }
        hit.delta.x = (1.0 - hit.time) * -delta.x;
        hit.delta.y = (1.0 - hit.time) * -delta.y;
        hit.pos.x = point.x + delta.x * hit.time;
        hit.pos.y = point.y + delta.y * hit.time;
        return hit;
    }
    // @override
    overlaps(other) {
        if (other instanceof AABB) {
            return this.overlapsAABB(other);
        }
        throw "Overlap not defined between these shapes.";
    }
    /**
     * A simple boolean check of whether this AABB overlaps another
     * @param other The other AABB to check against
     * @returns True if this AABB overlaps the other, false otherwise
     */
    overlapsAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The collision sides stored in a Vec2 if the AABBs are touching, null otherwise
     */
    touchesAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is just touching and the other is overlapping, true
        if ((px === 0 && py >= 0) || (py === 0 && px >= 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            if (py === 0) {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Also, if they are only touching corners, they are considered not touching.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The side of the touch, stored as a Vec2, or null if there is no touch
     */
    touchesAABBWithoutCorners(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is touching, and the other is strictly overlapping
        if ((px === 0 && py > 0) || (py === 0 && px > 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            else {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Calculates the area of the overlap between this AABB and another
     * @param other The other AABB
     * @returns The area of the overlap between the AABBs
     */
    overlapArea(other) {
        let leftx = Math.max(this.x - this.hw, other.x - other.hw);
        let rightx = Math.min(this.x + this.hw, other.x + other.hw);
        let dx = rightx - leftx;
        let lefty = Math.max(this.y - this.hh, other.y - other.hh);
        let righty = Math.min(this.y + this.hh, other.y + other.hh);
        let dy = righty - lefty;
        if (dx < 0 || dy < 0)
            return 0;
        return dx * dy;
    }
    /**
     * Moves and resizes this rect from its current position to the position specified
     * @param velocity The movement of the rect from its position
     * @param fromPosition A position specified to be the starting point of sweeping
     * @param halfSize The halfSize of the sweeping rect
     */
    sweep(velocity, fromPosition, halfSize) {
        if (!fromPosition) {
            fromPosition = this.center;
        }
        if (!halfSize) {
            halfSize = this.halfSize;
        }
        let centerX = fromPosition.x + velocity.x / 2;
        let centerY = fromPosition.y + velocity.y / 2;
        let minX = Math.min(fromPosition.x - halfSize.x, fromPosition.x + velocity.x - halfSize.x);
        let minY = Math.min(fromPosition.y - halfSize.y, fromPosition.y + velocity.y - halfSize.y);
        this.center.set(centerX, centerY);
        this.halfSize.set(centerX - minX, centerY - minY);
    }
    // @override
    clone() {
        return new AABB(this.center.clone(), this.halfSize.clone());
    }
    /**
     * Converts this AABB to a string format
     * @returns (center: (x, y), halfSize: (x, y))
     */
    toString() {
        return ("(center: " +
            this.center.toString() +
            ", half-size: " +
            this.halfSize.toString() +
            ")");
    }
}
exports.default = AABB;
},{"../../Utils/MathUtils":134,"../Physics/Hit":46,"../Vec2":56,"./Circle":50,"./Shape":51}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
const AABB_1 = require("./AABB");
const Shape_1 = require("./Shape");
/**
 * A Circle
 */
class Circle extends Shape_1.default {
    /**
     * Creates a new Circle
     * @param center The center of the circle
     * @param radius The radius of the circle
     */
    constructor(center, radius) {
        super();
        this._center = center ? center : new Vec2_1.default(0, 0);
        this.radius = radius ? radius : 0;
    }
    get center() {
        return this._center;
    }
    set center(center) {
        this._center = center;
    }
    get halfSize() {
        return new Vec2_1.default(this.radius, this.radius);
    }
    get r() {
        return this.radius;
    }
    set r(radius) {
        this.radius = radius;
    }
    // @override
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return this.center.distanceSqTo(point) <= this.radius * this.radius;
    }
    // @override
    getBoundingRect() {
        return new AABB_1.default(this._center.clone(), new Vec2_1.default(this.radius, this.radius));
    }
    // @override
    getBoundingCircle() {
        return this.clone();
    }
    // @override
    overlaps(other) {
        throw new Error("Method not implemented.");
    }
    // @override
    clone() {
        return new Circle(this._center.clone(), this.radius);
    }
    toString() {
        return ("(center: " + this.center.toString() + ", radius: " + this.radius + ")");
    }
}
exports.default = Circle;
},{"../Vec2":56,"./AABB":49,"./Shape":51}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
const AABB_1 = require("./AABB");
/**
 * An abstract Shape class that acts as an interface for better interactions with subclasses.
 */
class Shape {
    get x() {
        return this.center.x;
    }
    get y() {
        return this.center.y;
    }
    get hw() {
        return this.halfSize.x;
    }
    get hh() {
        return this.halfSize.y;
    }
    get top() {
        return this.y - this.hh;
    }
    get bottom() {
        return this.y + this.hh;
    }
    get left() {
        return this.x - this.hw;
    }
    get right() {
        return this.x + this.hw;
    }
    static getTimeOfCollision(A, velA, B, velB) {
        if (A instanceof AABB_1.default && B instanceof AABB_1.default) {
            return Shape.getTimeOfCollision_AABB_AABB(A, velA, B, velB);
        }
    }
    static getTimeOfCollision_AABB_AABB(A, velA, B, velB) {
        let posSmaller = A.center;
        let posLarger = B.center;
        let sizeSmaller = A.halfSize;
        let sizeLarger = B.halfSize;
        let firstContact = new Vec2_1.default(0, 0);
        let lastContact = new Vec2_1.default(0, 0);
        let collidingX = false;
        let collidingY = false;
        // Sort by position
        if (posLarger.x < posSmaller.x) {
            // Swap, because smaller is further right than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is left, B is right
        firstContact.x = Infinity;
        lastContact.x = Infinity;
        if (posLarger.x - sizeLarger.x >= posSmaller.x + sizeSmaller.x) {
            // If we aren't currently colliding
            let relVel = velA.x - velB.x;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.x =
                    (posLarger.x - sizeLarger.x - (posSmaller.x + sizeSmaller.x)) /
                        relVel;
                lastContact.x =
                    (posLarger.x + sizeLarger.x - (posSmaller.x - sizeSmaller.x)) /
                        relVel;
            }
        }
        else {
            collidingX = true;
        }
        if (posLarger.y < posSmaller.y) {
            // Swap, because smaller is further up than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is top, B is bottom
        firstContact.y = Infinity;
        lastContact.y = Infinity;
        if (posLarger.y - sizeLarger.y >= posSmaller.y + sizeSmaller.y) {
            // If we aren't currently colliding
            let relVel = velA.y - velB.y;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.y =
                    (posLarger.y - sizeLarger.y - (posSmaller.y + sizeSmaller.y)) /
                        relVel;
                lastContact.y =
                    (posLarger.y + sizeLarger.y - (posSmaller.y - sizeSmaller.y)) /
                        relVel;
            }
        }
        else {
            collidingY = true;
        }
        return [firstContact, lastContact, collidingX, collidingY];
    }
}
exports.default = Shape;
},{"../Vec2":56,"./AABB":49}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A LIFO stack with items of type T
 */
class Stack {
    /**
     * Constructs a new stack
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.stack = new Array(this.MAX_ELEMENTS);
        this.head = -1;
    }
    /**
     * Adds an item to the top of the stack
     * @param item The new item to add to the stack
     */
    push(item) {
        if (this.head + 1 === this.MAX_ELEMENTS) {
            throw "Stack full - cannot add element";
        }
        this.head += 1;
        this.stack[this.head] = item;
    }
    /**
     * Removes an item from the top of the stack
     * @returns The item at the top of the stack
     */
    pop() {
        if (this.head === -1) {
            throw "Stack empty - cannot remove element";
        }
        this.head -= 1;
        return this.stack[this.head + 1];
    }
    /**
     * Returns the element currently at the top of the stack
     * @returns The item at the top of the stack
     */
    peek() {
        if (this.head === -1) {
            throw "Stack empty - cannot get element";
        }
        return this.stack[this.head];
    }
    /** Returns true if this stack is empty
     * @returns A boolean that represents whether or not the stack is empty
     */
    isEmpty() {
        return this.head === -1;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.stack[index]);
        this.head = -1;
    }
    /**
     * Returns the number of items currently in the stack
     * @returns The number of items in the stack
     */
    size() {
        return this.head + 1;
    }
    // @implemented
    forEach(func) {
        let i = 0;
        while (i <= this.head) {
            func(this.stack[i], i);
            i += 1;
        }
    }
    /**
     * Converts this stack into a string format
     * @returns A string representing this stack
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Stack;
},{}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Emitter_1 = require("../../Events/Emitter");
/**
 * An abstract implementation of a state for a @reference[StateMachine].
 * This class should be extended to allow for custom state behaviors.
 */
class State {
    /**
     * Constructs a new State
     * @param parent The parent StateMachine of this state
     */
    constructor(parent) {
        this.parent = parent;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Tells the state machine that this state has ended, and makes it transition to the new state specified
     * @param stateName The name of the state to transition to
     */
    finished(stateName) {
        this.parent.changeState(stateName);
    }
}
exports.default = State;
},{"../../Events/Emitter":59}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = require("../Stack");
const Map_1 = require("../Map");
const Receiver_1 = require("../../Events/Receiver");
const Emitter_1 = require("../../Events/Emitter");
/**
 * An implementation of a Push Down Automata State machine. States can also be hierarchical
 * for more flexibility, as described in @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/state.html).
 */
class StateMachine {
    /**
     * Creates a new StateMachine
     */
    constructor() {
        this.stack = new Stack_1.default();
        this.stateMap = new Map_1.default();
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.emitEventOnStateChange = false;
    }
    subscribe(eventTypes) {
        this.receiver.subscribe(eventTypes);
        return this;
    }
    getState() {
        return this.currentState;
    }
    isState(state) {
        return this.stateMap.get(state) == this.currentState;
    }
    /**
     * Sets the activity state of this state machine
     * @param flag True if you want to set this machine running, false otherwise
     */
    setActive(flag) {
        this.active = flag;
    }
    /**
     * Makes this state machine emit an event any time its state changes
     * @param stateChangeEventName The name of the event to emit
     */
    setEmitEventOnStateChange(stateChangeEventName) {
        this.emitEventOnStateChange = true;
        this.stateChangeEventName = stateChangeEventName;
    }
    /**
     * Stops this state machine from emitting events on state change.
     */
    cancelEmitEventOnStateChange() {
        this.emitEventOnStateChange = false;
    }
    /**
     * Initializes this state machine with an initial state and sets it running
     * @param initialState The name of initial state of the state machine
     */
    initialize(initialState, options) {
        this.stack.push(this.stateMap.get(initialState));
        this.currentState = this.stack.peek();
        this.currentState.onEnter(options);
        this.setActive(true);
    }
    /**
     * Adds a state to this state machine
     * @param stateName The name of the state to add
     * @param state The state to add
     */
    addState(stateName, state) {
        this.stateMap.add(stateName, state);
        return this;
    }
    /**
     * Changes the state of this state machine to the provided string
     * @param state The string name of the state to change to
     */
    changeState(state) {
        // Exit the current state
        let options = this.currentState.onExit();
        // Make sure the correct state is at the top of the stack
        if (state === "previous") {
            // Pop the current state off the stack
            this.stack.pop();
        }
        else {
            // Retrieve the new state from the statemap and put it at the top of the stack
            this.stack.pop();
            this.stack.push(this.stateMap.get(state));
        }
        // Retreive the new state from the stack
        this.currentState = this.stack.peek();
        // Emit an event if turned on
        if (this.emitEventOnStateChange) {
            this.emitter.fireEvent(this.stateChangeEventName, {
                state: this.currentState,
            });
        }
        // Enter the new state
        this.currentState.onEnter(options);
    }
    /**
     * Handles input. This happens at the very beginning of this state machine's update cycle.
     * @param event The game event to process
     */
    handleEvent(event) {
        if (this.active) {
            this.currentState.handleInput(event);
        }
    }
    // @implemented
    update(deltaT) {
        // Distribute events
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            this.handleEvent(event);
        }
        // Delegate the update to the current state
        this.currentState.update(deltaT);
    }
}
exports.default = StateMachine;
},{"../../Events/Emitter":59,"../../Events/Receiver":63,"../Map":43,"../Stack":52}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../Vec2");
/**
 * The data representation of a Tileset for the game engine. This represents one image,
 * with a startIndex if required (as it is with Tiled using two images in one tilset).
 */
class Tileset {
    // TODO: Change this to be more general and work with other tileset formats
    constructor(tilesetData) {
        // Defer handling of the data to a helper class
        this.initFromTiledData(tilesetData);
    }
    /**
     * Initialize the tileset from the data from a Tiled json file
     * @param tiledData The parsed object from a Tiled json file
     */
    initFromTiledData(tiledData) {
        this.numRows = tiledData.tilecount / tiledData.columns;
        this.numCols = tiledData.columns;
        this.startIndex = tiledData.firstgid;
        this.endIndex = this.startIndex + tiledData.tilecount - 1;
        this.tileSize = new Vec2_1.default(tiledData.tilewidth, tiledData.tilewidth);
        this.imageKey = tiledData.image;
        this.imageSize = new Vec2_1.default(tiledData.imagewidth, tiledData.imageheight);
    }
    /**
     * Gets the image key associated with this tilemap
     * @returns The image key of this tilemap
     */
    getImageKey() {
        return this.imageKey;
    }
    /**
     * Returns a Vec2 containing the left and top offset from the image origin for this tile.
     * @param tileIndex The index of the tile from startIndex to endIndex of this tileset
     * @returns A Vec2 containing the offset for the specified tile.
     */
    getImageOffsetForTile(tileIndex) {
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        return new Vec2_1.default(left, top);
    }
    /**
     * Gets the start index
     * @returns The start index
     */
    getStartIndex() {
        return this.startIndex;
    }
    /**
     * Gets the tile set
     * @returns A Vec2 containing the tile size
     */
    getTileSize() {
        return this.tileSize;
    }
    /**
     * Gets the number of rows in the tileset
     * @returns The number of rows
     */
    getNumRows() {
        return this.numRows;
    }
    /**
     * Gets the number of columns in the tilset
     * @returns The number of columns
     */
    getNumCols() {
        return this.numCols;
    }
    getTileCount() {
        return this.endIndex - this.startIndex + 1;
    }
    /**
     * Checks whether or not this tilset contains the specified tile index. This is used for rendering.
     * @param tileIndex The index of the tile to check
     * @returns A boolean representing whether or not this tilset uses the specified index
     */
    hasTile(tileIndex) {
        return tileIndex >= this.startIndex && tileIndex <= this.endIndex;
    }
    /**
     * Render a singular tile with index tileIndex from the tileset located at position dataIndex
     * @param ctx The rendering context
     * @param tileIndex The value of the tile to render
     * @param dataIndex The index of the tile in the data array
     * @param worldSize The size of the world
     * @param origin The viewport origin in the current layer
     * @param scale The scale of the tilemap
     */
    renderTile(ctx, tileIndex, dataIndex, maxCols, origin, scale, zoom) {
        let image = ResourceManager_1.default.getInstance().getImage(this.imageKey);
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor((dataIndex % maxCols) * width * scale.x);
        let y = Math.floor(Math.floor(dataIndex / maxCols) * height * scale.y);
        ctx.drawImage(image, left, top, width, height, Math.floor((x - origin.x) * zoom), Math.floor((y - origin.y) * zoom), Math.ceil(width * scale.x * zoom), Math.ceil(height * scale.y * zoom));
    }
}
exports.default = Tileset;
},{"../../ResourceManager/ResourceManager":115,"../Vec2":56}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("../Utils/MathUtils");
/**
 * A two-dimensional vector (x, y)
 */
class Vec2 {
    /**
     * Creates a new Vec2
     * @param x The x value of the vector
     * @param y The y value of the vector
     */
    constructor(x = 0, y = 0) {
        /**
         * When this vector changes its value, do something
         */
        this.onChange = () => { };
        this.vec = new Float32Array(2);
        this.vec[0] = x;
        this.vec[1] = y;
    }
    // Expose x and y with getters and setters
    get x() {
        return this.vec[0];
    }
    set x(x) {
        this.vec[0] = x;
        if (this.onChange) {
            this.onChange();
        }
    }
    get y() {
        return this.vec[1];
    }
    set y(y) {
        this.vec[1] = y;
        if (this.onChange) {
            this.onChange();
        }
    }
    static get ZERO() {
        return new Vec2(0, 0);
    }
    static get INF() {
        return new Vec2(Infinity, Infinity);
    }
    static get UP() {
        return new Vec2(0, -1);
    }
    static get DOWN() {
        return new Vec2(0, 1);
    }
    static get LEFT() {
        return new Vec2(-1, 0);
    }
    static get RIGHT() {
        return new Vec2(1, 0);
    }
    /**
     * The squared magnitude of the vector. This tends to be faster, so use it in situations where taking the
     * square root doesn't matter, like for comparing distances.
     * @returns The squared magnitude of the vector
     */
    magSq() {
        return this.x * this.x + this.y * this.y;
    }
    /**
     * The magnitude of the vector.
     * @returns The magnitude of the vector.
     */
    mag() {
        return Math.sqrt(this.magSq());
    }
    /**
     * Divdes x and y by the magnitude to obtain the unit vector in the direction of this vector.
     * @returns This vector as a unit vector.
     */
    normalize() {
        if (this.x === 0 && this.y === 0)
            return this;
        let mag = this.mag();
        this.x /= mag;
        this.y /= mag;
        return this;
    }
    /**
     * Works like normalize(), but returns a new Vec2
     * @returns A new vector that is the unit vector for this one
     */
    normalized() {
        if (this.isZero()) {
            return this;
        }
        let mag = this.mag();
        return new Vec2(this.x / mag, this.y / mag);
    }
    /**
     * Sets the x and y elements of this vector to zero.
     * @returns This vector, with x and y set to zero.
     */
    zero() {
        return this.set(0, 0);
    }
    /**
     * Sets the vector's x and y based on the angle provided. Goes counter clockwise.
     * @param angle The angle in radians
     * @param radius The magnitude of the vector at the specified angle
     * @returns This vector.
     */
    setToAngle(angle, radius = 1) {
        this.x = MathUtils_1.default.floorToPlace(Math.cos(angle) * radius, 5);
        this.y = MathUtils_1.default.floorToPlace(-Math.sin(angle) * radius, 5);
        return this;
    }
    /**
     * Returns a vector that point from this vector to another one
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided
     */
    vecTo(other) {
        return new Vec2(other.x - this.x, other.y - this.y);
    }
    /**
     * Returns a vector containing the direction from this vector to another
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided. This new Vec2 will be a unit vector.
     */
    dirTo(other) {
        return this.vecTo(other).normalize();
    }
    /**
     * Keeps the vector's direction, but sets its magnitude to be the provided magnitude
     * @param magnitude The magnitude the vector should be
     * @returns This vector with its magnitude set to the new magnitude
     */
    scaleTo(magnitude) {
        return this.normalize().scale(magnitude);
    }
    /**
     * Scales x and y by the number provided, or if two number are provided, scales them individually.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns This vector after scaling
     */
    scale(factor, yFactor = null) {
        if (yFactor !== null) {
            this.x *= factor;
            this.y *= yFactor;
            return this;
        }
        this.x *= factor;
        this.y *= factor;
        return this;
    }
    /**
     * Returns a scaled version of this vector without modifying it.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns A new vector that has the values of this vector after scaling
     */
    scaled(factor, yFactor = null) {
        return this.clone().scale(factor, yFactor);
    }
    /**
     * Rotates the vector counter-clockwise by the angle amount specified
     * @param angle The angle to rotate by in radians
     * @returns This vector after rotation.
     */
    rotateCCW(angle) {
        let cs = Math.cos(angle);
        let sn = Math.sin(angle);
        let tempX = this.x * cs - this.y * sn;
        let tempY = this.x * sn + this.y * cs;
        this.x = tempX;
        this.y = tempY;
        return this;
    }
    /**
     * Sets the vectors coordinates to be the ones provided
     * @param x The new x value for this vector
     * @param y The new y value for this vector
     * @returns This vector
     */
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    /**
     * Copies the values of the other Vec2 into this one.
     * @param other The Vec2 to copy
     * @returns This vector with its values set to the vector provided
     */
    copy(other) {
        return this.set(other.x, other.y);
    }
    /**
     * Adds this vector the another vector
     * @param other The Vec2 to add to this one
     * @returns This vector after adding the one provided
     */
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    /**
     * Increments the fields of this vector. Both are incremented with a, if only a is provided.
     * @param a The first number to increment by
     * @param b The second number to increment by
     * @returnss This vector after incrementing
     */
    inc(a, b) {
        if (b === undefined) {
            this.x += a;
            this.y += a;
        }
        else {
            this.x += a;
            this.y += b;
        }
        return this;
    }
    /**
     * Subtracts another vector from this vector
     * @param other The Vec2 to subtract from this one
     * @returns This vector after subtracting the one provided
     */
    sub(other) {
        this.x -= other.x;
        this.y -= other.y;
        return this;
    }
    /**
     * Multiplies this vector with another vector element-wise. In other words, this.x *= other.x and this.y *= other.y
     * @param other The Vec2 to multiply this one by
     * @returns This vector after multiplying its components by this one
     */
    mult(other) {
        this.x *= other.x;
        this.y *= other.y;
        return this;
    }
    /**
     * Divides this vector with another vector element-wise. In other words, this.x /= other.x and this.y /= other.y
     * @param other The vector to divide this one by
     * @returns This vector after division
     */
    div(other) {
        if (other.x === 0 || other.y === 0)
            throw "Divide by zero error";
        this.x /= other.x;
        this.y /= other.y;
        return this;
    }
    /**
     * Does an element wise remainder operation on this vector. this.x %= other.x and this.y %= other.y
     * @param other The other vector
     * @returns this vector
     */
    remainder(other) {
        this.x = this.x % other.x;
        this.y = this.y % other.y;
        return this;
    }
    /**
     * Returns the squared distance between this vector and another vector
     * @param other The vector to compute distance squared to
     * @returns The squared distance between this vector and the one provided
     */
    distanceSqTo(other) {
        return ((this.x - other.x) * (this.x - other.x) +
            (this.y - other.y) * (this.y - other.y));
    }
    /**
     * Returns the distance between this vector and another vector
     * @param other The vector to compute distance to
     * @returns The distance between this vector and the one provided
     */
    distanceTo(other) {
        return Math.sqrt(this.distanceSqTo(other));
    }
    /**
     * Returns the dot product of this vector and another
     * @param other The vector to compute the dot product with
     * @returns The dot product of this vector and the one provided.
     */
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    /**
     * Returns the angle counter-clockwise in radians from this vector to another vector
     * @param other The vector to compute the angle to
     * @returns The angle, rotating CCW, from this vector to the other vector
     */
    angleToCCW(other) {
        let dot = this.dot(other);
        let det = this.x * other.y - this.y * other.x;
        let angle = -Math.atan2(det, dot);
        if (angle < 0) {
            angle += 2 * Math.PI;
        }
        return angle;
    }
    /**
     * Returns a string representation of this vector rounded to 1 decimal point
     * @returns This vector as a string
     */
    toString() {
        return this.toFixed();
    }
    /**
     * Returns a string representation of this vector rounded to the specified number of decimal points
     * @param numDecimalPoints The number of decimal points to create a string to
     * @returns This vector as a string
     */
    toFixed(numDecimalPoints = 1) {
        return ("(" +
            this.x.toFixed(numDecimalPoints) +
            ", " +
            this.y.toFixed(numDecimalPoints) +
            ")");
    }
    /**
     * Returns a new vector with the same coordinates as this one.
     * @returns A new Vec2 with the same values as this one
     */
    clone() {
        return new Vec2(this.x, this.y);
    }
    /**
     * Returns true if this vector and other have the EXACT same x and y (not assured to be safe for floats)
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    strictEquals(other) {
        return this.x === other.x && this.y === other.y;
    }
    /**
     * Returns true if this vector and other have the same x and y
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    equals(other) {
        let xEq = Math.abs(this.x - other.x) < 0.0000001;
        let yEq = Math.abs(this.y - other.y) < 0.0000001;
        return xEq && yEq;
    }
    /**
     * Returns true if this vector is the zero vector exactly (not assured to be safe for floats).
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    strictIsZero() {
        return this.x === 0 && this.y === 0;
    }
    /**
     * Returns true if this x and y for this vector are both zero.
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    isZero() {
        return Math.abs(this.x) < 0.0000001 && Math.abs(this.y) < 0.0000001;
    }
    /**
     * Sets the function that is called whenever this vector is changed.
     * @param f The function to be called
     */
    setOnChange(f) {
        this.onChange = f;
    }
    toArray() {
        return this.vec;
    }
    /**
     * Performs linear interpolation between two vectors
     * @param a The first vector
     * @param b The second vector
     * @param t The time of the lerp, with 0 being vector A, and 1 being vector B
     * @returns A new Vec2 representing the lerp between vector a and b.
     */
    static lerp(a, b, t) {
        return new Vec2(MathUtils_1.default.lerp(a.x, b.x, t), MathUtils_1.default.lerp(a.y, b.y, t));
    }
}
exports.default = Vec2;
Vec2.ZERO_STATIC = new Vec2(0, 0);
},{"../Utils/MathUtils":134}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const Vec2_1 = require("../DataTypes/Vec2");
const Color_1 = require("../Utils/Color");
/**
 * A util class for rendering Debug.json messages to the canvas.
 */
class Debug {
    /**
     * Add a message to display on the debug screen
     * @param id A unique ID for this message
     * @param messages The messages to print to the debug screen
     */
    static log(id, ...messages) {
        // let message = "";
        // for(let i = 0; i < messages.length; i++){
        // 	message += messages[i].toString();
        // }
        // Join all messages with spaces
        let message = messages.map((m) => m.toString()).join(" ");
        this.logMessages.add(id, message);
    }
    /**
     * Deletes a a key from the log and stops it from keeping up space on the screen
     * @param id The id of the log item to clear
     */
    static clearLogItem(id) {
        this.logMessages.delete(id);
    }
    /**
     * Sets the list of nodes to render with the debugger
     * @param nodes The new list of nodes
     */
    static setNodes(nodes) {
        this.nodes = nodes;
    }
    /**
     * Draws a box at the specified position
     * @param center The center of the box
     * @param halfSize The dimensions of the box
     * @param filled A boolean for whether or not the box is filled
     * @param color The color of the box to draw
     */
    static drawBox(center, halfSize, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.fillRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.strokeRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a circle at the specified position
     * @param center The center of the circle
     * @param radius The dimensions of the box
     * @param filled A boolean for whether or not the circle is filled
     * @param color The color of the circle
     */
    static drawCircle(center, radius, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.fill();
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.stroke();
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a ray at the specified position
     * @param from The starting position of the ray
     * @param to The ending position of the ray
     * @param color The color of the ray
     */
    static drawRay(from, to, color) {
        this.debugRenderingContext.lineWidth = 2;
        this.debugRenderingContext.strokeStyle = color.toString();
        this.debugRenderingContext.beginPath();
        this.debugRenderingContext.moveTo(from.x, from.y);
        this.debugRenderingContext.lineTo(to.x, to.y);
        this.debugRenderingContext.closePath();
        this.debugRenderingContext.stroke();
    }
    /**
     * Draws a point at the specified position
     * @param pos The position of the point
     * @param color The color of the point
     */
    static drawPoint(pos, color) {
        let pointSize = 6;
        this.debugRenderingContext.fillStyle = color.toString();
        this.debugRenderingContext.fillRect(pos.x - pointSize / 2, pos.y - pointSize / 2, pointSize, pointSize);
    }
    /**
     * Sets the default rendering color for text for the debugger
     * @param color The color to render the text
     */
    static setDefaultTextColor(color) {
        this.defaultTextColor = color;
    }
    /**
     * Performs any necessary setup operations on the Debug.json canvas
     * @param canvas The debug canvas
     * @param width The desired width of the canvas
     * @param height The desired height of the canvas
     * @returns The rendering context extracted from the canvas
     */
    static initializeDebugCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.debugCanvasSize = new Vec2_1.default(width, height);
        this.debugRenderingContext = canvas.getContext("2d");
        return this.debugRenderingContext;
    }
    /** Clears the debug canvas */
    static clearCanvas() {
        this.debugRenderingContext.clearRect(0, 0, this.debugCanvasSize.x, this.debugCanvasSize.y);
    }
    /** Renders the text and nodes sent to the Debug.json system */
    static render() {
        this.renderText();
        this.renderNodes();
    }
    /** Renders the text sent to the Debug.json canvas */
    static renderText() {
        let y = 20;
        this.debugRenderingContext.font = "20px Arial";
        this.debugRenderingContext.fillStyle = this.defaultTextColor.toString();
        // Draw all of the text
        this.logMessages.forEach((key) => {
            this.debugRenderingContext.fillText(this.logMessages.get(key), 10, y);
            y += 30;
        });
    }
    /** Renders the nodes registered with the debug canvas */
    static renderNodes() {
        if (this.nodes) {
            this.nodes.forEach(node => {
                node.debugRender();
            });
        }
    }
}
exports.default = Debug;
/** A map of log messages to display on the screen */
Debug.logMessages = new Map_1.default();
/** The rendering color for text */
Debug.defaultTextColor = Color_1.default.WHITE;
},{"../DataTypes/Map":43,"../DataTypes/Vec2":56,"../Utils/Color":131}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = require("../Utils/Color");
// @ignorePage
class Stats extends Object {
    static initStats() {
        let canvas = document.getElementById("stats-canvas");
        canvas.width = this.CANVAS_WIDTH;
        canvas.height = this.CANVAS_HEIGHT;
        this.ctx = canvas.getContext("2d");
        this.statsDiv = document.getElementById("stats-display");
        this.prevfps = new Array();
        this.prevClearTimes = new Array();
        this.SGClearTimes = new Array();
        this.avgSGClearTime = 0;
        this.prevFillTimes = new Array();
        this.SGFillTimes = new Array();
        this.avgSGFillTime = 0;
        this.prevUpdateTimes = new Array();
        this.SGUpdateTimes = new Array();
        this.avgSGUpdateTime = 0;
        this.prevQueryTimes = new Array();
        this.SGQueryTimes = new Array();
        this.avgSGQueryTime = 0;
        let clearTime = document.createElement("span");
        clearTime.setAttribute("id", "sgclear");
        let fillTime = document.createElement("span");
        fillTime.setAttribute("id", "sgfill");
        let updateTime = document.createElement("span");
        updateTime.setAttribute("id", "sgupdate");
        let queryTime = document.createElement("span");
        queryTime.setAttribute("id", "sgquery");
        let br1 = document.createElement("br");
        let br2 = document.createElement("br");
        let br3 = document.createElement("br");
        this.statsDiv.append(clearTime, br1, fillTime, br2, updateTime, br3, queryTime);
        this.graphChoices = (document.getElementById("chart-option"));
        let option1 = document.createElement("option");
        option1.value = "prevfps";
        option1.label = "FPS";
        let option2 = document.createElement("option");
        option2.value = "prevClearTimes";
        option2.label = "Clear Time";
        let option3 = document.createElement("option");
        option3.value = "prevFillTimes";
        option3.label = "Fill time";
        let option4 = document.createElement("option");
        option4.value = "prevUpdateTimes";
        option4.label = "Update time";
        let option5 = document.createElement("option");
        option5.value = "prevQueryTimes";
        option5.label = "Query Time";
        let optionAll = document.createElement("option");
        optionAll.value = "all";
        optionAll.label = "All";
        this.graphChoices.append(option1, option2, option3, option4, option5, optionAll);
    }
    static updateFPS(fps) {
        this.prevfps.push(fps);
        if (this.prevfps.length > Stats.NUM_POINTS) {
            this.prevfps.shift();
        }
        if (this.SGClearTimes.length > 0) {
            this.prevClearTimes.push(this.avgSGClearTime);
            if (this.prevClearTimes.length > this.NUM_POINTS) {
                this.prevClearTimes.shift();
            }
        }
        if (this.SGFillTimes.length > 0) {
            this.prevFillTimes.push(this.avgSGFillTime);
            if (this.prevFillTimes.length > this.NUM_POINTS) {
                this.prevFillTimes.shift();
            }
        }
        if (this.SGUpdateTimes.length > 0) {
            this.prevUpdateTimes.push(this.avgSGUpdateTime);
            if (this.prevUpdateTimes.length > this.NUM_POINTS) {
                this.prevUpdateTimes.shift();
            }
        }
        if (this.SGQueryTimes.length > 0) {
            this.prevQueryTimes.push(this.avgSGQueryTime);
            if (this.prevQueryTimes.length > this.NUM_POINTS) {
                this.prevQueryTimes.shift();
            }
        }
        this.updateSGStats();
    }
    static log(key, data) {
        if (key === "sgclear") {
            this.SGClearTimes.push(data);
            if (this.SGClearTimes.length > 100) {
                this.SGClearTimes.shift();
            }
        }
        else if (key === "sgfill") {
            this.SGFillTimes.push(data);
            if (this.SGFillTimes.length > 100) {
                this.SGFillTimes.shift();
            }
        }
        else if (key === "sgupdate") {
            this.SGUpdateTimes.push(data);
            if (this.SGUpdateTimes.length > 100) {
                this.SGUpdateTimes.shift();
            }
        }
        else if (key === "sgquery") {
            this.SGQueryTimes.push(data);
            if (this.SGQueryTimes.length > 1000) {
                this.SGQueryTimes.shift();
            }
        }
    }
    static render() {
        // Display stats
        this.drawCharts();
    }
    static drawCharts() {
        this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT);
        let paramString = this.graphChoices.value;
        if (paramString === "prevfps" || paramString === "all") {
            let param = this.prevfps;
            let color = Color_1.default.BLUE.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevClearTimes" || paramString === "all") {
            let param = this.prevClearTimes;
            let color = Color_1.default.RED.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevFillTimes" || paramString === "all") {
            let param = this.prevFillTimes;
            let color = Color_1.default.GREEN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevUpdateTimes" || paramString === "all") {
            let param = this.prevUpdateTimes;
            let color = Color_1.default.CYAN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevQueryTimes" || paramString === "all") {
            let param = this.prevQueryTimes;
            let color = Color_1.default.ORANGE.toString();
            this.drawChart(param, color);
        }
    }
    static drawChart(param, color) {
        this.ctx.strokeStyle = Color_1.default.BLACK.toString();
        this.ctx.beginPath();
        this.ctx.moveTo(10, 10);
        this.ctx.lineTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.moveTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.lineTo(this.CANVAS_WIDTH - 10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        let max = Math.max(...param);
        let prevX = 10;
        let prevY = this.CANVAS_HEIGHT - 10 - (param[0] / max) * (this.CANVAS_HEIGHT - 20);
        this.ctx.strokeStyle = color;
        for (let i = 1; i < param.length; i++) {
            let fps = param[i];
            let x = 10 + (i * (this.CANVAS_WIDTH - 20)) / this.NUM_POINTS;
            let y = this.CANVAS_HEIGHT - 10 - (fps / max) * (this.CANVAS_HEIGHT - 20);
            this.ctx.beginPath();
            this.ctx.moveTo(prevX, prevY);
            this.ctx.lineTo(x, y);
            this.ctx.closePath();
            this.ctx.stroke();
            prevX = x;
            prevY = y;
        }
    }
    static updateSGStats() {
        if (this.SGClearTimes.length > 0) {
            this.avgSGClearTime =
                this.SGClearTimes.reduce((acc, val) => acc + val) /
                    this.SGClearTimes.length;
        }
        if (this.SGFillTimes.length > 0) {
            this.avgSGFillTime =
                this.SGFillTimes.reduce((acc, val) => acc + val) /
                    this.SGFillTimes.length;
        }
        if (this.SGUpdateTimes.length > 0) {
            this.avgSGUpdateTime =
                this.SGUpdateTimes.reduce((acc, val) => acc + val) /
                    this.SGUpdateTimes.length;
        }
        if (this.SGQueryTimes.length > 0) {
            this.avgSGQueryTime =
                this.SGQueryTimes.reduce((acc, val) => acc + val) /
                    this.SGQueryTimes.length;
        }
        document.getElementById("sgclear").innerHTML =
            "Avg SG clear time: " + this.avgSGClearTime;
        document.getElementById("sgfill").innerHTML =
            "Avg SG fill time: " + this.avgSGFillTime;
        document.getElementById("sgupdate").innerHTML =
            "Avg SG update time: " + this.avgSGUpdateTime;
        document.getElementById("sgquery").innerHTML =
            "Avg SG query time: " + this.avgSGQueryTime;
    }
}
exports.default = Stats;
Stats.NUM_POINTS = 60;
Stats.CANVAS_WIDTH = 300;
Stats.CANVAS_HEIGHT = 300;
},{"../Utils/Color":131}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("./EventQueue");
const GameEvent_1 = require("./GameEvent");
/**
 * An event emitter object other systems can use to hook into the EventQueue.
 * Provides an easy interface for firing off events.
 */
class Emitter {
    /** Creates a new Emitter */
    constructor() {
        this.eventQueue = EventQueue_1.default.getInstance();
    }
    /**
     * Emit and event of type eventType with the data packet data
     * @param eventType The name of the event to fire off
     * @param data A @reference[Map] or record containing any data about the event
     */
    fireEvent(eventType, data = null) {
        this.eventQueue.addEvent(new GameEvent_1.default(eventType, data));
    }
}
exports.default = Emitter;
},{"./EventQueue":60,"./GameEvent":61}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const Map_1 = require("../DataTypes/Map");
const GameEventType_1 = require("./GameEventType");
/**
 * The main event system of the game engine.
 * Events are sent to the EventQueue, which handles distribution to any systems that are listening for those events.
 * This allows for handling of input without having classes directly hook into javascript event handles,
 * and allows otherwise separate classes to communicate with each other cleanly, such as a Player object
 * requesting a sound be played by the audio system.
 *
 * The distribution of @reference[GameEvent]s happens as follows:
 *
 * Events are recieved throughout a frame and are queued up by the EventQueue.
 * At the beginning of the next frame, events are sent out to any receivers that are hooked into the event type.
 * @reference[Receiver]s are then free to process events as they see fit.
 *
 * Overall, the EventQueue can be considered as something similar to an email server,
 * and the @reference[Receiver]s can be considered as the client inboxes.
 *
 * See @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/event-queue.html) for more discussion on EventQueues
 */
class EventQueue {
    constructor() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1.default(this.MAX_SIZE);
        this.receivers = new Map_1.default();
    }
    /** Retrieves the instance of the Singleton EventQueue */
    static getInstance() {
        if (this.instance === null) {
            this.instance = new EventQueue();
        }
        return this.instance;
    }
    /** Adds an event to the EventQueue.
     * This is exposed to the rest of the game engine through the @reference[Emitter] class */
    addEvent(event) {
        this.q.enqueue(event);
    }
    /**
     * Associates a receiver with a type of event. Every time this event appears in the future,
     * it will be given to the receiver (and any others watching that type).
     * This is exposed to the rest of the game engine through the @reference[Receiver] class
     * @param receiver The event receiver
     * @param type The type or types of events to subscribe to
     */
    subscribe(receiver, type) {
        if (type instanceof Array) {
            // If it is an array, subscribe to all event types
            for (let t of type) {
                this.addListener(receiver, t);
            }
        }
        else {
            this.addListener(receiver, type);
        }
    }
    /**
     * Unsubscribes the specified receiver from all events, or from whatever events are provided
     * @param receiver The receiver to unsubscribe
     * @param keys The events to unsubscribe from. If none are provided, unsubscribe from all
     */
    unsubscribe(receiver, ...events) {
        this.receivers.forEach(eventName => {
            // If keys were provided, only continue if this key is one of them
            if (events.length > 0 && events.indexOf(eventName) === -1)
                return;
            // Find the index of our receiver for this key
            let index = this.receivers.get(eventName).indexOf(receiver);
            // If an index was found, remove the receiver
            if (index !== -1) {
                this.receivers.get(eventName).splice(index, 1);
            }
        });
    }
    // Associate the receiver and the type
    addListener(receiver, type) {
        if (this.receivers.has(type)) {
            this.receivers.get(type).push(receiver);
        }
        else {
            this.receivers.add(type, [receiver]);
        }
    }
    update(deltaT) {
        while (this.q.hasItems()) {
            // Retrieve each event
            let event = this.q.dequeue();
            // If a receiver has this event type, send it the event
            if (this.receivers.has(event.type)) {
                for (let receiver of this.receivers.get(event.type)) {
                    receiver.receive(event);
                }
            }
            // If a receiver is subscribed to all events, send it the event
            if (this.receivers.has(GameEventType_1.GameEventType.ALL)) {
                for (let receiver of this.receivers.get(GameEventType_1.GameEventType.ALL)) {
                    receiver.receive(event);
                }
            }
        }
    }
}
exports.default = EventQueue;
EventQueue.instance = null;
},{"../DataTypes/Map":43,"../DataTypes/Queue":47,"./GameEventType":62}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * A representation of an in-game event that is passed through the @reference[EventQueue]
 */
class GameEvent {
    /**
     * Creates a new GameEvent.
     * This is handled implicitly through the @reference[Emitter] class
     * @param type The type of the GameEvent
     * @param data The data contained by the GameEvent
     */
    constructor(type, data = null) {
        // Parse the game event data
        if (data === null) {
            this.data = new Map_1.default();
        }
        else if (!(data instanceof Map_1.default)) {
            // data is a raw object, unpack
            this.data = new Map_1.default();
            for (let key in data) {
                this.data.add(key, data[key]);
            }
        }
        else {
            this.data = data;
        }
        this.type = type;
        this.time = Date.now();
    }
    /**
     * Checks the type of the GameEvent
     * @param type The type to check
     * @returns True if the GameEvent is the specified type, false otherwise.
     */
    isType(type) {
        return this.type === type;
    }
    /**
     * Returns this GameEvent as a string
     * @returns The string representation of the GameEvent
     */
    toString() {
        return this.type + ": @" + this.time;
    }
}
exports.default = GameEvent;
},{"../DataTypes/Map":43}],62:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.GameEventType = void 0;
var GameEventType;
(function (GameEventType) {
    /**
     * Mouse Down event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_DOWN"] = "mouse_down";
    /**
     * Mouse Up event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_UP"] = "mouse_up";
    /**
     * Mouse Move event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_MOVE"] = "mouse_move";
    /**
     * Key Down event. Has data: {key: string - The key that is down}
     */
    GameEventType["KEY_DOWN"] = "key_down";
    /**
     * Key Up event. Has data: {key: string - The key that is up}
     */
    GameEventType["KEY_UP"] = "key_up";
    /**
     * Canvas Blur event. Has data: {}
     */
    GameEventType["CANVAS_BLUR"] = "canvas_blur";
    /**
     * Mouse wheel up event. Has data: {}
     */
    GameEventType["WHEEL_UP"] = "wheel_up";
    /**
     * Mouse wheel down event. Has data: {}
     */
    GameEventType["WHEEL_DOWN"] = "wheel_down";
    /**
     * Start Recording event. Has data: {}
     */
    GameEventType["START_RECORDING"] = "start_recording";
    /**
     * Stop Recording event. Has data: {}
     */
    GameEventType["STOP_RECORDING"] = "stop_recording";
    /**
     * Play Recording event. Has data: {}
     */
    GameEventType["PLAY_RECORDING"] = "play_recording";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_SOUND"] = "play_sound";
    /**
     * Play Sound event. Has data: {key: string}
     */
    GameEventType["STOP_SOUND"] = "stop_sound";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean, channel: AudioChannelType }
     */
    GameEventType["PLAY_SFX"] = "play_sfx";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_MUSIC"] = "play_music";
    /**
     * Mute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["MUTE_CHANNEL"] = "mute_channel";
    /**
     * Unmute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["UNMUTE_CHANNEL"] = "unmute_channel";
    /**
     * Encompasses all event types. Used for receivers only.
     */
    GameEventType["ALL"] = "all";
})(GameEventType = exports.GameEventType || (exports.GameEventType = {}));
},{}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const EventQueue_1 = require("./EventQueue");
/**
 * Receives subscribed events from the EventQueue.
 */
class Receiver {
    /** Creates a new Receiver */
    constructor() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1.default(this.MAX_SIZE);
    }
    destroy() {
        EventQueue_1.default.getInstance().unsubscribe(this);
    }
    /**
     * Adds these types of events to this receiver's queue every update.
     * @param eventTypes The types of events this receiver will be subscribed to
     */
    subscribe(eventTypes) {
        EventQueue_1.default.getInstance().subscribe(this, eventTypes);
        this.q.clear();
    }
    /**
     * Adds an event to the queue of this reciever. This is used by the @reference[EventQueue] to distribute events
     * @param event The event to receive
     */
    receive(event) {
        try {
            this.q.enqueue(event);
        }
        catch (e) {
            console.warn("Receiver overflow for event " + event.toString());
            throw e;
        }
    }
    /**
     * Retrieves the next event from the receiver's queue
     * @returns The next GameEvent
     */
    getNextEvent() {
        return this.q.dequeue();
    }
    /**
     * Looks at the next event in the receiver's queue, but doesn't remove it from the queue
     * @returns The next GameEvent
     */
    peekNextEvent() {
        return this.q.peekNext();
    }
    /**
     * Returns true if the receiver has any events in its queue
     * @returns True if the receiver has another event, false otherwise
     */
    hasNextEvent() {
        return this.q.hasItems();
    }
    /**
     * Ignore all events this frame
     */
    ignoreEvents() {
        this.q.clear();
    }
}
exports.default = Receiver;
},{"../DataTypes/Queue":47,"./EventQueue":60}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = require("../Events/Receiver");
const Map_1 = require("../DataTypes/Map");
const Vec2_1 = require("../DataTypes/Vec2");
const EventQueue_1 = require("../Events/EventQueue");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Receives input events from the @reference[EventQueue] and allows for easy access of information about input by other systems
 */
class Input {
    /**
     * Initializes the Input object
     * @param viewport A reference to the viewport of the game
     * @param keyMap List of keys
     */
    static initialize(viewport, keyMap) {
        Input.viewport = viewport;
        Input.mousePressed = false;
        Input.mouseJustPressed = false;
        Input.receiver = new Receiver_1.default();
        Input.keyJustPressed = new Map_1.default();
        Input.keyPressed = new Map_1.default();
        Input.mousePosition = new Vec2_1.default(0, 0);
        Input.mousePressPosition = new Vec2_1.default(0, 0);
        Input.scrollDirection = 0;
        Input.justScrolled = false;
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
        // Initialize the keymap
        Input.keyMap = new Map_1.default();
        // Add all keys to the keymap
        for (let entry in keyMap) {
            let name = keyMap[entry].name;
            let keys = keyMap[entry].keys;
            Input.keyMap.add(name, keys);
        }
        Input.eventQueue = EventQueue_1.default.getInstance();
        // Subscribe to all input events
        Input.eventQueue.subscribe(Input.receiver, [
            GameEventType_1.GameEventType.MOUSE_DOWN,
            GameEventType_1.GameEventType.MOUSE_UP,
            GameEventType_1.GameEventType.MOUSE_MOVE,
            GameEventType_1.GameEventType.KEY_DOWN,
            GameEventType_1.GameEventType.KEY_UP,
            GameEventType_1.GameEventType.CANVAS_BLUR,
            GameEventType_1.GameEventType.WHEEL_UP,
            GameEventType_1.GameEventType.WHEEL_DOWN,
        ]);
    }
    static changeKeyMap(keyMap) {
        Input.keyMap = new Map_1.default();
        for (const entry in keyMap) {
            const name = keyMap[entry].name;
            const keys = keyMap[entry].keys;
            Input.keyMap.add(name, keys);
        }
    }
    static update(deltaT) {
        // Reset the justPressed values to false
        Input.mouseJustPressed = false;
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.justScrolled = false;
        Input.scrollDirection = 0;
        while (Input.receiver.hasNextEvent()) {
            let event = Input.receiver.getNextEvent();
            // Handle each event type
            if (event.type === GameEventType_1.GameEventType.MOUSE_DOWN) {
                Input.mouseJustPressed = true;
                Input.mousePressed = true;
                Input.mousePressPosition = event.data.get("position");
                Input.mouseButtonPressed = event.data.get("button");
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_UP) {
                Input.mousePressed = false;
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_MOVE) {
                Input.mousePosition = event.data.get("position");
            }
            if (event.type === GameEventType_1.GameEventType.KEY_DOWN) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                if (!Input.keyPressed.get(key)) {
                    Input.keyJustPressed.set(key, true);
                    Input.keyPressed.set(key, true);
                }
            }
            if (event.type === GameEventType_1.GameEventType.KEY_UP) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                Input.keyPressed.set(key, false);
            }
            if (event.type === GameEventType_1.GameEventType.CANVAS_BLUR) {
                Input.clearKeyPresses();
            }
            if (event.type === GameEventType_1.GameEventType.WHEEL_UP) {
                Input.scrollDirection = -1;
                Input.justScrolled = true;
            }
            else if (event.type === GameEventType_1.GameEventType.WHEEL_DOWN) {
                Input.scrollDirection = 1;
                Input.justScrolled = true;
            }
        }
    }
    static clearKeyPresses() {
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.keyPressed.forEach((key) => Input.keyPressed.set(key, false));
    }
    /**
     * Returns whether or not a key was newly pressed Input frame.
     * If the key is still pressed from last frame and wasn't re-pressed, Input will return false.
     * @param key The key
     * @returns True if the key was just pressed, false otherwise
     */
    static isKeyJustPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyJustPressed.has(key)) {
            return Input.keyJustPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Returns an array of all of the keys that are newly pressed Input frame.
     * If a key is still pressed from last frame and wasn't re-pressed, it will not be in Input list.
     * @returns An array of all of the newly pressed keys.
     */
    static getKeysJustPressed() {
        if (Input.keysDisabled)
            return [];
        let keys = Array();
        Input.keyJustPressed.forEach(key => {
            if (Input.keyJustPressed.get(key)) {
                keys.push(key);
            }
        });
        return keys;
    }
    /**
     * Returns whether or not a key is being pressed.
     * @param key The key
     * @returns True if the key is currently pressed, false otherwise
     */
    static isKeyPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyPressed.has(key)) {
            return Input.keyPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Changes the binding of an input name to keys
     * @param inputName The name of the input
     * @param keys The corresponding keys
     */
    static changeKeyBinding(inputName, keys) {
        Input.keyMap.set(inputName, keys);
    }
    /**
     * Clears all key bindings
     */
    static clearAllKeyBindings() {
        Input.keyMap.clear();
    }
    /**
     * Returns whether or not an input was just pressed this frame
     * @param inputName The name of the input
     * @returns True if the input was just pressed, false otherwise
     */
    static isJustPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let justPressed = false;
            for (let key of keys) {
                justPressed = justPressed || Input.isKeyJustPressed(key);
            }
            return justPressed;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether or not an input is currently pressed
     * @param inputName The name of the input
     * @returns True if the input is pressed, false otherwise
     */
    static isPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let pressed = false;
            for (let key of keys) {
                pressed = pressed || Input.isKeyPressed(key);
            }
            return pressed;
        }
        else {
            return false;
        }
    }
    /**
     *
     * Returns whether or not the mouse was newly pressed Input frame.
     * @param mouseButton Optionally specify which mouse click you want to know was pressed.
     * 0 for left click, 1 for middle click, 2 for right click.
     * @returns True if the mouse was just pressed, false otherwise
     */
    static isMouseJustPressed(mouseButton) {
        if (mouseButton) {
            return (Input.mouseJustPressed &&
                !Input.mouseDisabled &&
                mouseButton == this.mouseButtonPressed);
        }
        return Input.mouseJustPressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether or not the mouse is currently pressed
     * @param mouseButton Optionally specify which mouse click you want to know was pressed.
     * 0 for left click, 1 for middle click, 2 for right click.
     * @returns True if the mouse is currently pressed, false otherwise
     */
    static isMousePressed(mouseButton) {
        if (mouseButton) {
            return (Input.mousePressed &&
                !Input.mouseDisabled &&
                mouseButton == this.mouseButtonPressed);
        }
        return Input.mousePressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether the user scrolled or not
     * @returns True if the user just scrolled Input frame, false otherwise
     */
    static didJustScroll() {
        return Input.justScrolled && !Input.mouseDisabled;
    }
    /**
     * Gets the direction of the scroll
     * @returns -1 if the user scrolled up, 1 if they scrolled down
     */
    static getScrollDirection() {
        return Input.scrollDirection;
    }
    /**
     * Gets the position of the player's mouse
     * @returns The mouse position stored as a Vec2
     */
    static getMousePosition() {
        return Input.mousePosition.scaled(1 / this.viewport.getZoomLevel());
    }
    /**
     * Gets the position of the player's mouse in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePosition() {
        return Input.mousePosition
            .clone()
            .scale(1 / this.viewport.getZoomLevel())
            .add(Input.viewport.getOrigin());
    }
    /**
     * Gets the position of the last mouse press
     * @returns The mouse position stored as a Vec2
     */
    static getMousePressPosition() {
        return Input.mousePressPosition;
    }
    /**
     * Gets the position of the last mouse press in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePressPosition() {
        return Input.mousePressPosition.clone().add(Input.viewport.getOrigin());
    }
    /**
     * Disables all keypress and mouse click inputs
     */
    static disableInput() {
        // changed to only disable keyboard input
        Input.keysDisabled = true;
    }
    /**
     * Enables all keypress and mouse click inputs
     */
    static enableInput() {
        // changed to only enable keyboard input
        Input.keysDisabled = false;
    }
}
exports.default = Input;
},{"../DataTypes/Map":43,"../DataTypes/Vec2":56,"../Events/EventQueue":60,"../Events/GameEventType":62,"../Events/Receiver":63}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("../Events/EventQueue");
const Vec2_1 = require("../DataTypes/Vec2");
const GameEvent_1 = require("../Events/GameEvent");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Handles communication with the web browser to receive asynchronous events and send them to the @reference[EventQueue]
 */
class InputHandler {
    /**
     * Creates a new InputHandler
     * @param canvas The game canvas
     */
    constructor(canvas) {
        this.handleMouseDown = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let button = event.button;
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_DOWN, {
                position: pos,
                button: button,
            });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseUp = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_UP, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseMove = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_MOVE, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyDown = (event) => {
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_DOWN, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyUp = (event) => {
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_UP, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleBlur = (event) => {
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.CANVAS_BLUR, {});
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleContextMenu = (event) => {
            event.preventDefault();
            event.stopPropagation();
        };
        this.handleWheel = (event) => {
            event.preventDefault();
            event.stopPropagation();
            let gameEvent;
            if (event.deltaY < 0) {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_UP, {});
            }
            else {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_DOWN, {});
            }
            this.eventQueue.addEvent(gameEvent);
        };
        this.eventQueue = EventQueue_1.default.getInstance();
        canvas.onmousedown = event => this.handleMouseDown(event, canvas);
        canvas.onmouseup = event => this.handleMouseUp(event, canvas);
        canvas.oncontextmenu = this.handleContextMenu;
        canvas.onmousemove = event => this.handleMouseMove(event, canvas);
        document.onkeydown = this.handleKeyDown;
        document.onkeyup = this.handleKeyUp;
        document.onblur = this.handleBlur;
        document.oncontextmenu = this.handleBlur;
        document.onwheel = this.handleWheel;
    }
    getKey(keyEvent) {
        return keyEvent.key.toLowerCase();
    }
    getMousePosition(mouseEvent, canvas) {
        let rect = canvas.getBoundingClientRect();
        let x = mouseEvent.clientX - rect.left;
        let y = mouseEvent.clientY - rect.top;
        return new Vec2_1.default(x, y);
    }
}
exports.default = InputHandler;
},{"../DataTypes/Vec2":56,"../Events/EventQueue":60,"../Events/GameEvent":61,"../Events/GameEventType":62}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * Sets up the environment of the game engine
 */
class EnvironmentInitializer {
    static setup() {
        CanvasRenderingContext2D.prototype.roundedRect = function (x, y, w, h, r) {
            // Clamp the radius between 0 and the min of the width or height
            if (r < 0)
                r = 0;
            if (r > Math.min(w, h))
                r = Math.min(w, h);
            // Draw the rounded rect
            this.beginPath();
            // Top
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.arcTo(x + w, y, x + w, y + r, r);
            // Right
            this.lineTo(x + w, y + h - r);
            this.arcTo(x + w, y + h, x + w - r, y + h, r);
            // Bottom
            this.lineTo(x + r, y + h);
            this.arcTo(x, y + h, x, y + h - r, r);
            // Left
            this.lineTo(x, y + r);
            this.arcTo(x, y, x + r, y, r);
            this.closePath();
        };
        CanvasRenderingContext2D.prototype.strokeRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.stroke();
        };
        CanvasRenderingContext2D.prototype.fillRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.fill();
        };
    }
}
exports.default = EnvironmentInitializer;
},{}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameLoop_1 = require("./GameLoop");
const Debug_1 = require("../Debug/Debug");
const Stats_1 = require("../Debug/Stats");
/**
 * A game loop with a fixed update time and a variable render time.
 * Every frame, the game updates until all time since the last frame has been processed.
 * If too much time has passed, such as if the last update was too slow,
 * or if the browser was put into the background, the loop will panic and discard time.
 * A render happens at the end of every frame. This happens as fast as possible unless specified.
 * A loop of this type allows for deterministic behavior - No matter what the frame rate is, the update should behave the same,
 * as it is occuring in a fixed interval.
 */
class FixedUpdateGameLoop extends GameLoop_1.default {
    constructor() {
        super();
        /**
         * The main loop of the game. Updates until the current time is reached. Renders once
         * @param timestamp The current time in ms
         */
        this.doFrame = (timestamp) => {
            // If a pause was executed, stop doing the loop.
            if (this.paused) {
                return;
            }
            // Request animation frame to prepare for another update or render
            window.requestAnimationFrame(t => this.doFrame(t));
            // If we are trying to render too soon, do nothing.
            if (timestamp < this.lastFrameTime + this.minFrameDelay) {
                return;
            }
            // A frame is actually happening
            this.startFrame(timestamp);
            // Update while there is still time to make up. If we do too many update steps, panic and exit the loop.
            this.numUpdateSteps = 0;
            let panic = false;
            while (this.frameDelta >= this.updateTimestep) {
                // Do an update
                this._doUpdate(this.updateTimestep / 1000);
                // Remove the update step time from the time we have to process
                this.frameDelta -= this.updateTimestep;
                // Increment steps and check if we've done too many
                this.numUpdateSteps++;
                if (this.numUpdateSteps > 100) {
                    panic = true;
                    break;
                }
            }
            // Updates are done, render
            this._doRender();
            // Wrap up the frame
            this.finishFrame(panic);
        };
        this.maxUpdateFPS = 60;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
        this.frameDelta = 0;
        this.lastFrameTime = 0;
        this.minFrameDelay = 0;
        this.frame = 0;
        this.fps = this.maxUpdateFPS; // Initialize the fps to the max allowed fps
        this.fpsUpdateInterval = 1000;
        this.lastFpsUpdate = 0;
        this.framesSinceLastFpsUpdate = 0;
        this.started = false;
        this.paused = false;
        this.running = false;
        this.numUpdateSteps = 0;
    }
    getFPS() {
        return 0;
    }
    /**
     * Updates the frame count and sum of time for the framerate of the game
     * @param timestep The current time in ms
     */
    updateFPS(timestamp) {
        this.fps =
            (0.9 * this.framesSinceLastFpsUpdate * 1000) /
                (timestamp - this.lastFpsUpdate) +
                (1 - 0.9) * this.fps;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        Debug_1.default.log("fps", "FPS: " + this.fps.toFixed(1));
        Stats_1.default.updateFPS(this.fps);
    }
    /**
     * Changes the maximum allowed physics framerate of the game
     * @param initMax The max framerate
     */
    setMaxUpdateFPS(initMax) {
        this.maxUpdateFPS = initMax;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
    }
    /**
     * Sets the maximum rendering framerate
     * @param maxFPS The max framerate
     */
    setMaxFPS(maxFPS) {
        this.minFrameDelay = 1000 / maxFPS;
    }
    /**
     * This function is called when the game loop panics, i.e. it tries to process too much time in an entire frame.
     * This will reset the amount of time back to zero.
     * @returns The amount of time we are discarding from processing.
     */
    resetFrameDelta() {
        let oldFrameDelta = this.frameDelta;
        this.frameDelta = 0;
        return oldFrameDelta;
    }
    /**
     * Starts up the game loop and calls the first requestAnimationFrame
     */
    start() {
        if (!this.started) {
            this.started = true;
            window.requestAnimationFrame(timestamp => this.doFirstFrame(timestamp));
        }
    }
    pause() {
        this.paused = true;
    }
    resume() {
        this.paused = false;
    }
    /**
     * The first game frame - initializes the first frame time and begins the render
     * @param timestamp The current time in ms
     */
    doFirstFrame(timestamp) {
        this.running = true;
        this._doRender();
        this.lastFrameTime = timestamp;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        window.requestAnimationFrame(t => this.doFrame(t));
    }
    /**
     * Handles any processing that needs to be done at the start of the frame
     * @param timestamp The time of the frame in ms
     */
    startFrame(timestamp) {
        // Update the amount of time we need our update to process
        this.frameDelta += timestamp - this.lastFrameTime;
        // Set the new time of the last frame
        this.lastFrameTime = timestamp;
        // Update the estimate of the framerate
        if (timestamp > this.lastFpsUpdate + this.fpsUpdateInterval) {
            this.updateFPS(timestamp);
        }
        // Increment the number of frames
        this.frame++;
        this.framesSinceLastFpsUpdate++;
    }
    /**
     * Wraps up the frame and handles the panic state if there is one
     * @param panic Whether or not the loop panicked
     */
    finishFrame(panic) {
        if (panic) {
            var discardedTime = Math.round(this.resetFrameDelta());
            console.warn("Main loop panicked, probably because the browser tab was put in the background. Discarding " +
                discardedTime +
                "ms");
        }
    }
}
exports.default = FixedUpdateGameLoop;
},{"../Debug/Debug":57,"../Debug/Stats":58,"./GameLoop":69}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("../Events/EventQueue");
const Input_1 = require("../Input/Input");
const InputHandler_1 = require("../Input/InputHandler");
const Recorder_1 = require("../Playback/Recorder");
const Debug_1 = require("../Debug/Debug");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const Viewport_1 = require("../SceneGraph/Viewport");
const SceneManager_1 = require("../Scene/SceneManager");
const AudioManager_1 = require("../Sound/AudioManager");
const Stats_1 = require("../Debug/Stats");
const CanvasRenderer_1 = require("../Rendering/CanvasRenderer");
const Color_1 = require("../Utils/Color");
const GameOptions_1 = require("./GameOptions");
const FixedUpdateGameLoop_1 = require("./FixedUpdateGameLoop");
const EnvironmentInitializer_1 = require("./EnvironmentInitializer");
const Vec2_1 = require("../DataTypes/Vec2");
const RegistryManager_1 = require("../Registry/RegistryManager");
const WebGLRenderer_1 = require("../Rendering/WebGLRenderer");
/**
 * The main loop of the game engine.
 * Handles the update order, and initializes all subsystems.
 * The Game manages the update cycle, and requests animation frames to render to the browser.
 */
class Game {
    /**
     * Creates a new Game
     * @param options The options for Game initialization
     */
    constructor(options) {
        // Before anything else, build the environment
        EnvironmentInitializer_1.default.setup();
        // Typecast the config object to a GameConfig object
        this.gameOptions = GameOptions_1.default.parse(options);
        this.showDebug = this.gameOptions.showDebug;
        this.showStats = this.gameOptions.showStats;
        // Create an instance of a game loop
        this.loop = new FixedUpdateGameLoop_1.default();
        // Get the game canvas and give it a background color
        this.GAME_CANVAS = (document.getElementById("game-canvas"));
        this.DEBUG_CANVAS = (document.getElementById("debug-canvas"));
        // Give the canvas a size and get the rendering context
        this.WIDTH = this.gameOptions.canvasSize.x;
        this.HEIGHT = this.gameOptions.canvasSize.y;
        // This step MUST happen before the resource manager does anything
        if (this.gameOptions.useWebGL) {
            this.renderingManager = new WebGLRenderer_1.default();
        }
        else {
            this.renderingManager = new CanvasRenderer_1.default();
        }
        this.initializeGameWindow();
        this.ctx = this.renderingManager.initializeCanvas(this.GAME_CANVAS, this.WIDTH, this.HEIGHT);
        this.clearColor = new Color_1.default(this.gameOptions.clearColor.r, this.gameOptions.clearColor.g, this.gameOptions.clearColor.b);
        // Initialize debugging and stats
        Debug_1.default.initializeDebugCanvas(this.DEBUG_CANVAS, this.WIDTH, this.HEIGHT);
        Stats_1.default.initStats();
        if (this.gameOptions.showStats) {
            // Find the stats output and make it no longer hidden
            document.getElementById("stats").hidden = false;
        }
        // Size the viewport to the game canvas
        const canvasSize = new Vec2_1.default(this.WIDTH, this.HEIGHT);
        this.viewport = new Viewport_1.default(canvasSize, this.gameOptions.zoomLevel);
        // Initialize all necessary game subsystems
        this.eventQueue = EventQueue_1.default.getInstance();
        this.inputHandler = new InputHandler_1.default(this.GAME_CANVAS);
        Input_1.default.initialize(this.viewport, this.gameOptions.inputs);
        this.recorder = new Recorder_1.default();
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.sceneManager = new SceneManager_1.default(this.viewport, this.renderingManager);
        this.audioManager = AudioManager_1.default.getInstance();
    }
    /**
     * Set up the game window that holds the canvases
     */
    initializeGameWindow() {
        const gameWindow = document.getElementById("game-window");
        // Set the height of the game window
        gameWindow.style.width = this.WIDTH + "px";
        gameWindow.style.height = this.HEIGHT + "px";
    }
    /**
     * Retreives the SceneManager from the Game
     * @returns The SceneManager
     */
    getSceneManager() {
        return this.sceneManager;
    }
    /**
     * Starts the game
     */
    start(InitialScene, options) {
        // Set the update function of the loop
        this.loop.doUpdate = (deltaT) => this.update(deltaT);
        // Set the render function of the loop
        this.loop.doRender = () => this.render();
        // Preload registry items
        RegistryManager_1.default.preload();
        // Load the items with the resource manager
        this.resourceManager.loadResourcesFromQueue(() => {
            // When we're done loading, start the loop
            console.log("Finished Preload - loading first scene");
            this.sceneManager.changeToScene(InitialScene, {}, options);
            this.loop.start();
        });
    }
    /**
     * Updates all necessary subsystems of the game. Defers scene updates to the sceneManager
     * @param deltaT The time sine the last update
     */
    update(deltaT) {
        try {
            // Handle all events that happened since the start of the last loop
            this.eventQueue.update(deltaT);
            // Update the input data structures so game objects can see the input
            Input_1.default.update(deltaT);
            // Update the recording of the game
            this.recorder.update(deltaT);
            // Update all scenes
            this.sceneManager.update(deltaT);
            // Update all sounds
            this.audioManager.update(deltaT);
            // Load or unload any resources if needed
            this.resourceManager.update(deltaT);
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Update - Crashing gracefully");
            console.error(e);
        }
    }
    /**
     * Clears the canvas and defers scene rendering to the sceneManager. Renders the debug canvas
     */
    render() {
        try {
            // Clear the canvases
            Debug_1.default.clearCanvas();
            this.renderingManager.clear(this.clearColor);
            this.sceneManager.render();
            // Hacky debug mode
            if (Input_1.default.isKeyJustPressed("g")) {
                this.showDebug = !this.showDebug;
            }
            // Debug.json render
            if (this.showDebug) {
                Debug_1.default.render();
            }
            if (this.showStats) {
                Stats_1.default.render();
            }
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Render - Crashing gracefully");
            console.error(e);
        }
    }
}
exports.default = Game;
},{"../DataTypes/Vec2":56,"../Debug/Debug":57,"../Debug/Stats":58,"../Events/EventQueue":60,"../Input/Input":64,"../Input/InputHandler":65,"../Playback/Recorder":94,"../Registry/RegistryManager":97,"../Rendering/CanvasRenderer":103,"../Rendering/WebGLRenderer":108,"../ResourceManager/ResourceManager":115,"../Scene/SceneManager":126,"../SceneGraph/Viewport":118,"../Sound/AudioManager":128,"../Utils/Color":131,"./EnvironmentInitializer":66,"./FixedUpdateGameLoop":67,"./GameOptions":70}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NullFunc_1 = require("../DataTypes/Functions/NullFunc");
/**
 * The main game loop of the game. Keeps track of fps and handles scheduling of updates and rendering.
 * This class is left abstract, so that a subclass can handle exactly how the loop is scheduled.
 * For an example of different types of game loop scheduling, check out @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/game-loop.html)
 */
class GameLoop {
    constructor() {
        /** The function to call when an update occurs */
        this._doUpdate = NullFunc_1.default;
        /** The function to call when a render occurs */
        this._doRender = NullFunc_1.default;
    }
    set doUpdate(update) {
        this._doUpdate = update;
    }
    set doRender(render) {
        this._doRender = render;
    }
}
exports.default = GameLoop;
},{"../DataTypes/Functions/NullFunc":38}],70:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/** The options for initializing the @reference[GameLoop] */
class GameOptions {
    /**
     * Parses the data in the raw options object
     * @param options The game options as a Record
     * @returns A version of the options converted to a GameOptions object
     */
    static parse(options) {
        let gOpt = new GameOptions();
        gOpt.canvasSize = options.canvasSize
            ? options.canvasSize
            : { x: 800, y: 600 };
        gOpt.zoomLevel = options.zoomLevel ? options.zoomLevel : 1;
        gOpt.clearColor = options.clearColor
            ? options.clearColor
            : { r: 255, g: 255, b: 255 };
        gOpt.inputs = options.inputs ? options.inputs : [];
        gOpt.showDebug = !!options.showDebug;
        gOpt.showStats = !!options.showStats;
        gOpt.useWebGL = !!options.useWebGL;
        return gOpt;
    }
}
exports.default = GameOptions;
},{}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameNode_1 = require("./GameNode");
const Vec2_1 = require("../DataTypes/Vec2");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const Debug_1 = require("../Debug/Debug");
const Color_1 = require("../Utils/Color");
/**
 * The representation of an object in the game world that can be drawn to the screen
 */
class CanvasNode extends GameNode_1.default {
    constructor() {
        super();
        /** A flag for whether or not the CanvasNode is visible */
        this.visible = true;
        this._size = new Vec2_1.default(0, 0);
        this._size.setOnChange(() => this.sizeChanged());
        this._scale = new Vec2_1.default(1, 1);
        this._scale.setOnChange(() => this.scaleChanged());
        this._boundary = new AABB_1.default();
        this.updateBoundary();
        this._hasCustomShader = false;
    }
    get alpha() {
        return this._alpha;
    }
    set alpha(a) {
        this._alpha = a;
    }
    get size() {
        return this._size;
    }
    set size(size) {
        this._size = size;
        // Enter as a lambda to bind "this"
        this._size.setOnChange(() => this.sizeChanged());
        this.sizeChanged();
    }
    get scale() {
        return this._scale;
    }
    set scale(scale) {
        this._scale = scale;
        // Enter as a lambda to bind "this"
        this._scale.setOnChange(() => this.scaleChanged());
        this.scaleChanged();
    }
    set scaleX(value) {
        this.scale.x = value;
    }
    set scaleY(value) {
        this.scale.y = value;
    }
    get hasCustomShader() {
        return this._hasCustomShader;
    }
    get customShaderKey() {
        return this._customShaderKey;
    }
    // @override
    positionChanged() {
        super.positionChanged();
        this.updateBoundary();
    }
    /** Called if the size vector is changed or replaced. */
    sizeChanged() {
        this.updateBoundary();
    }
    /** Called if the scale vector is changed or replaced */
    scaleChanged() {
        this.updateBoundary();
    }
    // @docIgnore
    /** Called if the position, size, or scale of the CanvasNode is changed. Updates the boundary. */
    updateBoundary() {
        this._boundary.center.set(this.position.x, this.position.y);
        this._boundary.halfSize.set((this.size.x * this.scale.x) / 2, (this.size.y * this.scale.y) / 2);
    }
    get boundary() {
        return this._boundary;
    }
    get sizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.boundary.halfSize.clone().scaled(zoom, zoom);
    }
    /**
     * Adds a custom shader to this CanvasNode
     * @param key The registry key of the ShaderType
     */
    useCustomShader(key) {
        this._hasCustomShader = true;
        this._customShaderKey = key;
    }
    /**
     * Returns true if the point (x, y) is inside of this canvas object
     * @param x The x position of the point
     * @param y The y position of the point
     * @returns A flag representing whether or not this node contains the point.
     */
    contains(x, y) {
        return this._boundary.containsPoint(new Vec2_1.default(x, y));
    }
    // @implemented
    debugRender() {
        Debug_1.default.drawBox(this.relativePosition, this.sizeWithZoom, false, Color_1.default.BLUE);
        super.debugRender();
    }
}
exports.default = CanvasNode;
},{"../DataTypes/Shapes/AABB":49,"../DataTypes/Vec2":56,"../Debug/Debug":57,"../Utils/Color":131,"./GameNode":72}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenableProperties = void 0;
const Vec2_1 = require("../DataTypes/Vec2");
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const Region_1 = require("../DataTypes/Interfaces/Region");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const TweenController_1 = require("../Rendering/Animations/TweenController");
const Debug_1 = require("../Debug/Debug");
const Color_1 = require("../Utils/Color");
const Circle_1 = require("../DataTypes/Shapes/Circle");
/**
 * The representation of an object in the game world.
 * To construct GameNodes, see the @reference[Scene] documentation.
 */
class GameNode {
    // Constructor docs are ignored, as the user should NOT create new GameNodes with a raw constructor
    constructor() {
        /*---------- PHYSICAL ----------*/
        this.hasPhysics = false;
        this.moving = false;
        this.frozen = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isColliding = false;
        this.pathfinding = false;
        this._position = new Vec2_1.default(0, 0);
        this._position.setOnChange(() => this.positionChanged());
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tweens = new TweenController_1.default(this);
        this.rotation = 0;
    }
    destroy() {
        this.tweens.destroy();
        this.receiver.destroy();
        if (this.hasPhysics) {
            this.removePhysics();
        }
        if (this._ai) {
            this._ai.destroy();
            delete this._ai;
            this.scene.getAIManager().removeActor(this);
        }
        this.scene.remove(this);
        this.layer.removeNode(this);
    }
    /*---------- POSITIONED ----------*/
    get position() {
        return this._position;
    }
    set position(pos) {
        this._position = pos;
        this._position.setOnChange(() => this.positionChanged());
        this.positionChanged();
    }
    get relativePosition() {
        return this.inRelativeCoordinates(this.position);
    }
    /**
     * Converts a point to coordinates relative to the zoom and origin of this node
     * @param point The point to conver
     * @returns A new Vec2 representing the point in relative coordinates
     */
    inRelativeCoordinates(point) {
        let origin = this.scene.getViewTranslation(this);
        let zoom = this.scene.getViewScale();
        return point.clone().sub(origin).scale(zoom);
    }
    /*---------- UNIQUE ----------*/
    get id() {
        return this._id;
    }
    set id(id) {
        // id can only be set once
        if (this._id === undefined) {
            this._id = id;
        }
        else {
            throw "Attempted to assign id to object that already has id.";
        }
    }
    /*---------- PHYSICAL ----------*/
    // @implemented
    /**
     * @param velocity The velocity with which to move the object.
     */
    move(velocity) {
        if (this.frozen)
            return;
        this.moving = true;
        this._velocity = velocity;
    }
    moveOnPath(speed, path) {
        if (this.frozen)
            return;
        this.path = path;
        let dir = path.getMoveDirection(this);
        this.moving = true;
        this.pathfinding = true;
        this._velocity = dir.scale(speed);
    }
    // @implemented
    /**
     * @param velocity The velocity with which the object will move.
     */
    finishMove() {
        this.moving = false;
        this.position.add(this._velocity);
        if (this.pathfinding) {
            this.path.handlePathProgress(this);
            this.path = null;
            this.pathfinding = false;
        }
    }
    // @implemented
    /**
     * @param collisionShape The collider for this object. If this has a region (implements Region),
     * it will be used when no collision shape is specified (or if collision shape is null).
     * @param isCollidable Whether this is collidable or not. True by default.
     * @param isStatic Whether this is static or not. False by default
     */
    addPhysics(collisionShape, colliderOffset, isCollidable = true, isStatic = false) {
        // Initialize the physics variables
        this.hasPhysics = true;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = true;
        this.isCollidable = isCollidable;
        this.isStatic = isStatic;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = new Array(32);
        this.triggerExits = new Array(32);
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = new AABB_1.default();
        this.collidedWithTilemap = false;
        this.group = -1; // The default group, collides with everything
        // Set the collision shape if provided, or simply use the the region if there is one.
        if (collisionShape) {
            this.collisionShape = collisionShape;
            this.collisionShape.center = this.position;
        }
        else if (Region_1.isRegion(this)) {
            // If the gamenode has a region and no other is specified, use that
            this.collisionShape = this.boundary.clone();
        }
        else {
            throw "No collision shape specified for physics object.";
        }
        // If we were provided with a collider offset, set it. Otherwise there is no offset, so use the zero vector
        if (colliderOffset) {
            this.colliderOffset = colliderOffset;
        }
        else {
            this.colliderOffset = Vec2_1.default.ZERO;
        }
        // Initialize the swept rect
        this.sweptRect = this.collisionShape.getBoundingRect();
        // Register the object with physics
        this.scene.getPhysicsManager().registerObject(this);
    }
    /** Removes this object from the physics system */
    removePhysics() {
        // Remove this from the physics manager
        this.scene.getPhysicsManager().deregisterObject(this);
        // Nullify all physics fields
        this.hasPhysics = false;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isCollidable = false;
        this.isStatic = false;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = null;
        this.triggerExits = null;
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = null;
        this.collidedWithTilemap = false;
        this.group = -1;
        this.collisionShape = null;
        this.colliderOffset = Vec2_1.default.ZERO;
        this.sweptRect = null;
    }
    /** Disables physics movement for this node */
    freeze() {
        this.frozen = true;
    }
    /** Reenables physics movement for this node */
    unfreeze() {
        this.frozen = false;
    }
    /** Prevents this object from participating in all collisions and triggers. It can still move. */
    disablePhysics() {
        this.active = false;
    }
    /** Enables this object to participate in collisions and triggers. This is only necessary if disablePhysics was called */
    enablePhysics() {
        this.active = true;
    }
    /**
     * Sets the collider for this GameNode
     * @param collider The new collider to use
     */
    setCollisionShape(collider) {
        this.collisionShape = collider;
        this.collisionShape.center.copy(this.position);
    }
    // @implemented
    /**
     * Sets this object to be a trigger for a specific group
     * @param group The name of the group that activates the trigger
     * @param onEnter The name of the event to send when this trigger is activated
     * @param onExit The name of the event to send when this trigger stops being activated
     */
    setTrigger(group, onEnter, onExit) {
        // Make this object a trigger
        this.isTrigger = true;
        // Get the number of the physics layer
        let layerNumber = this.scene.getPhysicsManager().getGroupNumber(group);
        if (layerNumber === 0) {
            console.warn(`Trigger for GameNode ${this.id} not set - group "${group}" was not recognized by the physics manager.`);
            return;
        }
        // Add this to the trigger mask
        this.triggerMask |= layerNumber;
        // Layer numbers are bits, so get which bit it is
        let index = Math.log2(layerNumber);
        // Set the event names
        this.triggerEnters[index] = onEnter;
        this.triggerExits[index] = onExit;
    }
    // @implemented
    /**
     * @param group The physics group this node should belong to
     */
    setGroup(group) {
        this.scene.getPhysicsManager().setGroup(this, group);
    }
    // @implemened
    getLastVelocity() {
        return this._velocity;
    }
    /*---------- ACTOR ----------*/
    get ai() {
        return this._ai;
    }
    set ai(ai) {
        if (!this._ai) {
            // If we haven't been previously had an ai, register us with the ai manager
            this.scene.getAIManager().registerActor(this);
        }
        this._ai = ai;
        this.aiActive = true;
    }
    // @implemented
    addAI(ai, options, type) {
        if (!this._ai) {
            this.scene.getAIManager().registerActor(this);
        }
        if (typeof ai === "string") {
            this._ai = this.scene.getAIManager().generateAI(ai);
        }
        else {
            this._ai = new ai();
        }
        // Question, how much do we want different type of AI to be handled the same, i.e. should GoapAI and AI similar methods and signatures for the sake of unity
        this._ai.initializeAI(this, options);
        this.aiActive = true;
    }
    // @implemented
    setAIActive(active, options) {
        this.aiActive = active;
        if (this.aiActive) {
            this.ai.activate(options);
        }
    }
    /*---------- TWEENABLE PROPERTIES ----------*/
    set positionX(value) {
        this.position.x = value;
    }
    set positionY(value) {
        this.position.y = value;
    }
    /*---------- GAME NODE ----------*/
    /**
     * Sets the scene for this object.
     * @param scene The scene this object belongs to.
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Gets the scene this object is in.
     * @returns The scene this object belongs to
     */
    getScene() {
        return this.scene;
    }
    /**
     * Sets the layer of this object.
     * @param layer The layer this object will be on.
     */
    setLayer(layer) {
        this.layer = layer;
    }
    /**
     * Returns the layer this object is on.
     * @returns This layer this object is on.
     */
    getLayer() {
        return this.layer;
    }
    /** Called if the position vector is modified or replaced */
    positionChanged() {
        if (this.collisionShape) {
            if (this.colliderOffset) {
                this.collisionShape.center = this.position
                    .clone()
                    .add(this.colliderOffset);
            }
            else {
                this.collisionShape.center = this.position.clone();
            }
        }
    }
    /**
     * Updates this GameNode
     * @param deltaT The timestep of the update.
     */
    update(deltaT) {
        // Defer event handling to AI.
        while (this.receiver.hasNextEvent()) {
            this._ai.handleEvent(this.receiver.getNextEvent());
        }
    }
    // @implemented
    debugRender() {
        // Draw the position of this GameNode
        Debug_1.default.drawPoint(this.relativePosition, Color_1.default.BLUE);
        // If velocity is not zero, draw a vector for it
        if (this._velocity && !this._velocity.isZero()) {
            Debug_1.default.drawRay(this.relativePosition, this._velocity.clone().scaleTo(20).add(this.relativePosition), Color_1.default.BLUE);
        }
        // If this has a collider, draw it
        if (this.collisionShape) {
            let color = this.isColliding ? Color_1.default.RED : Color_1.default.GREEN;
            if (this.isTrigger) {
                color = Color_1.default.MAGENTA;
            }
            color.a = 0.2;
            if (this.collisionShape instanceof AABB_1.default) {
                Debug_1.default.drawBox(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.halfSize.scaled(this.scene.getViewScale()), true, color);
            }
            else if (this.collisionShape instanceof Circle_1.default) {
                Debug_1.default.drawCircle(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.hw * this.scene.getViewScale(), true, color);
            }
        }
    }
}
exports.default = GameNode;
var TweenableProperties;
(function (TweenableProperties) {
    TweenableProperties["posX"] = "positionX";
    TweenableProperties["posY"] = "positionY";
    TweenableProperties["scaleX"] = "scaleX";
    TweenableProperties["scaleY"] = "scaleY";
    TweenableProperties["rotation"] = "rotation";
    TweenableProperties["alpha"] = "alpha";
})(TweenableProperties = exports.TweenableProperties || (exports.TweenableProperties = {}));
},{"../DataTypes/Interfaces/Region":42,"../DataTypes/Shapes/AABB":49,"../DataTypes/Shapes/Circle":50,"../DataTypes/Vec2":56,"../Debug/Debug":57,"../Events/Emitter":59,"../Events/Receiver":63,"../Rendering/Animations/TweenController":101,"../Utils/Color":131}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("./CanvasNode");
const Color_1 = require("../Utils/Color");
/**
 * The representation of a game object that doesn't rely on any resources to render - it is drawn to the screen by the canvas
 */
class Graphic extends CanvasNode_1.default {
    constructor() {
        super();
        this.color = Color_1.default.RED;
    }
    get alpha() {
        return this.color.a;
    }
    set alpha(a) {
        this.color.a = a;
    }
    // @deprecated
    /**
     * Sets the color of the Graphic. DEPRECATED
     * @param color The new color of the Graphic.
     */
    setColor(color) {
        this.color = color;
    }
    set colorR(r) {
        this.color.r = r;
    }
    get colorR() {
        return this.color.r;
    }
    set colorG(g) {
        this.color.g = g;
    }
    get colorG() {
        return this.color.g;
    }
    set colorB(b) {
        this.color.b = b;
    }
    get colorB() {
        return this.color.b;
    }
}
exports.default = Graphic;
},{"../Utils/Color":131,"./CanvasNode":71}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphicType = void 0;
var GraphicType;
(function (GraphicType) {
    GraphicType["POINT"] = "POINT";
    GraphicType["RECT"] = "RECT";
    GraphicType["LINE"] = "LINE";
    GraphicType["PARTICLE"] = "PARTICLE";
})(GraphicType = exports.GraphicType || (exports.GraphicType = {}));
},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
class Line extends Graphic_1.default {
    constructor(start, end) {
        super();
        this.start = start;
        this.end = end;
        this.thickness = 2;
        // Does this really have a meaning for lines?
        this.size.set(5, 5);
    }
    set start(pos) {
        this.position = pos;
    }
    get start() {
        return this.position;
    }
    set end(pos) {
        this._end = pos;
    }
    get end() {
        return this._end;
    }
}
exports.default = Line;
},{"../Graphic":73}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = require("./Point");
/**
 * - Position X
- Velocity (speed and direction) X
- Color X
- Lifetime
- Age can be handled as lifetime
- Shape X
- Size X
- Transparency X
 */
class Particle extends Point_1.default {
    constructor(position, size, mass) {
        // Are we making this a circle?
        super(position);
        this.inUse = false;
        this.mass = mass;
    }
    setParticleActive(lifetime, position) {
        this.age = lifetime;
        this.inUse = true;
        this.visible = true;
        this.position = position;
    }
    decrementAge(decay) {
        this.age -= decay;
    }
    setParticleInactive() {
        this.inUse = false;
        this.visible = false;
    }
    set velY(y) {
        this.vel.y = y;
    }
    get velY() {
        return this.vel.y;
    }
}
exports.default = Particle;
},{"./Point":77}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
/** A basic point to be drawn on the screen. */
class Point extends Graphic_1.default {
    constructor(position) {
        // Are we making this a circle?
        super();
        this.position = position;
        this.size.set(5, 5);
    }
}
exports.default = Point;
},{"../Graphic":73}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
const Color_1 = require("../../Utils/Color");
/** A basic rectangle to be drawn on the screen. */
class Rect extends Graphic_1.default {
    constructor(position, size) {
        super();
        this.position = position;
        this.size = size;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.borderWidth = 0;
    }
    /**
     * Sets the border color of this rectangle
     * @param color The border color
     */
    setBorderColor(color) {
        this.borderColor = color;
    }
    // @deprecated
    getBorderColor() {
        return this.borderColor;
    }
    /**
     * Sets the border width of this rectangle
     * @param width The width of the rectangle in pixels
     */
    setBorderWidth(width) {
        this.borderWidth = width;
    }
    getBorderWidth() {
        return this.borderWidth;
    }
}
exports.default = Rect;
},{"../../Utils/Color":131,"../Graphic":73}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = require("./Sprite");
const AnimationManager_1 = require("../../Rendering/Animations/AnimationManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/** A sprite with specified animation frames. */
class AnimatedSprite extends Sprite_1.default {
    constructor(spritesheet) {
        super(spritesheet.name);
        this.numCols = spritesheet.columns;
        this.numRows = spritesheet.rows;
        // Set the size of the sprite to the sprite size specified by the spritesheet
        this.size.set(spritesheet.spriteWidth, spritesheet.spriteHeight);
        this.animation = new AnimationManager_1.default(this);
        // Add the animations to the animated sprite
        for (let animation of spritesheet.animations) {
            this.animation.add(animation.name, animation);
        }
    }
    get cols() {
        return this.numCols;
    }
    get rows() {
        return this.numRows;
    }
    /**
     * Gets the image offset for the current index of animation
     * @param index The index we're at in the animation
     * @returns A Vec2 containing the image offset
     */
    getAnimationOffset(index) {
        // return new Vec2(
        //   (index % this.numCols) * this.size.x,
        //   Math.floor(index / this.numCols) * this.size.y,
        // );
        const frameData = this.animation.getAnimationData();
        return new Vec2_1.default(frameData.x, frameData.y);
    }
}
exports.default = AnimatedSprite;
},{"../../DataTypes/Vec2":56,"../../Rendering/Animations/AnimationManager":98,"./Sprite":80}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("../CanvasNode");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/**
 * The representation of a sprite - an in-game image
 */
class Sprite extends CanvasNode_1.default {
    constructor(imageId) {
        super();
        this.imageId = imageId;
        let image = ResourceManager_1.default.getInstance().getImage(this.imageId);
        this.size = new Vec2_1.default(image.width, image.height);
        this.imageOffset = Vec2_1.default.ZERO;
        this.invertX = false;
        this.invertY = false;
    }
    /**
     * Sets the offset of the sprite from (0, 0) in the image's coordinates
     * @param offset The offset of the sprite from (0, 0) in image coordinates
     */
    setImageOffset(offset) {
        this.imageOffset = offset;
    }
}
exports.default = Sprite;
},{"../../DataTypes/Vec2":56,"../../ResourceManager/ResourceManager":115,"../CanvasNode":71}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const CanvasNode_1 = require("./CanvasNode");
/**
 * The representation of a tilemap - this can consist of a combination of tilesets in one layer
 */
class Tilemap extends CanvasNode_1.default {
    // TODO: Make this no longer be specific to Tiled
    constructor(tilemapData, layer, tilesets, scale) {
        super();
        this.tilesets = tilesets;
        this.tileSize = new Vec2_1.default(0, 0);
        this.name = layer.name;
        let tilecount = 0;
        for (let tileset of tilesets) {
            tilecount += tileset.getTileCount() + 1;
        }
        this.collisionMap = new Array(tilecount);
        for (let i = 0; i < this.collisionMap.length; i++) {
            this.collisionMap[i] = false;
        }
        // Defer parsing of the data to child classes - this allows for isometric vs. orthographic tilemaps and handling of Tiled data or other data
        this.parseTilemapData(tilemapData, layer);
        this.scale.set(scale.x, scale.y);
    }
    /**
     * Returns an array of the tilesets associated with this tilemap
     * @returns An array of all of the tilesets assocaited with this tilemap.
     */
    getTilesets() {
        return this.tilesets;
    }
    /**
     * Returns the size of tiles in this tilemap as they appear in the game world after scaling
     * @returns A vector containing the size of tiles in this tilemap as they appear in the game world after scaling.
     */
    getTileSize() {
        return this.tileSize.scaled(this.scale.x, this.scale.y);
    }
    /**
     * Gets the tile size taking zoom into account
     * @returns The tile size with zoom
     */
    getTileSizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.getTileSize().scale(zoom);
    }
    /**
     * Adds this tilemap to the physics system
     */
    addPhysics() {
        this.hasPhysics = true;
        this.active = true;
        this.group = -1;
        this.scene.getPhysicsManager().registerTilemap(this);
    }
}
exports.default = Tilemap;
},{"../DataTypes/Vec2":56,"./CanvasNode":71}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Tilemap_1 = require("../Tilemap");
const Vec2_1 = require("../../DataTypes/Vec2");
const Debug_1 = require("../../Debug/Debug");
const Color_1 = require("../../Utils/Color");
/**
 * The representation of an orthogonal tilemap - i.e. a top down or platformer tilemap
 */
class OrthogonalTilemap extends Tilemap_1.default {
    // @override
    parseTilemapData(tilemapData, layer) {
        // The size of the tilemap in local space
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        // The size of tiles
        this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
        // The size of the tilemap on the canvas
        this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
        this.position.copy(this.size.scaled(0.5));
        this.data = layer.data;
        this.visible = layer.visible;
        // Whether the tilemap is collidable or not
        this.isCollidable = false;
        if (layer.properties) {
            for (let item of layer.properties) {
                if (item.name === "Collidable") {
                    this.isCollidable = item.value;
                    // Set all tiles besides "empty: 0" to be collidable
                    for (let i = 1; i < this.collisionMap.length; i++) {
                        this.collisionMap[i] = true;
                    }
                }
            }
        }
    }
    /**
     * Gets the dimensions of the tilemap
     * @returns A Vec2 containing the number of columns and the number of rows in the tilemap.
     */
    getDimensions() {
        return new Vec2_1.default(this.numCols, this.numRows);
    }
    /**
     * Gets the data value of the tile at the specified world position
     * @param worldCoords The coordinates in world space
     * @returns The data value of the tile
     */
    getTileAtWorldPosition(worldCoords) {
        let localCoords = this.getColRowAt(worldCoords);
        return this.getTileAtRowCol(localCoords);
    }
    /**
     * Get the tile at the specified row and column
     * @param rowCol The coordinates in tilemap space
     * @returns The data value of the tile
     */
    getTileAtRowCol(rowCol) {
        if (rowCol.x < 0 ||
            rowCol.x >= this.numCols ||
            rowCol.y < 0 ||
            rowCol.y >= this.numRows) {
            return -1;
        }
        return this.data[rowCol.y * this.numCols + rowCol.x];
    }
    /**
     * Gets the world position of the tile at the specified index
     * @param index The index of the tile
     * @returns A Vec2 containing the world position of the tile
     */
    getTileWorldPosition(index) {
        // Get the local position
        let col = index % this.numCols;
        let row = Math.floor(index / this.numCols);
        // Get the world position
        let x = col * this.tileSize.x;
        let y = row * this.tileSize.y;
        return new Vec2_1.default(x, y);
    }
    /**
     * Gets the data value of the tile at the specified index
     * @param index The index of the tile
     * @returns The data value of the tile
     */
    getTile(index) {
        return this.data[index];
    }
    // @override
    setTile(index, type) {
        this.data[index] = type;
    }
    /**
     * Sets the tile at the specified row and column
     * @param rowCol The position of the tile in tilemap space
     * @param type The new data value of the tile
     */
    setTileAtRowCol(rowCol, type) {
        let index = rowCol.y * this.numCols + rowCol.x;
        this.setTile(index, type);
    }
    /**
     * Returns true if the tile at the specified row and column of the tilemap is collidable
     * @param indexOrCol The index of the tile or the column it is in
     * @param row The row the tile is in
     * @returns A flag representing whether or not the tile is collidable.
     */
    isTileCollidable(indexOrCol, row) {
        // The value of the tile
        let tile = 0;
        if (row) {
            // We have a column and a row
            tile = this.getTileAtRowCol(new Vec2_1.default(indexOrCol, row));
            if (tile < 0) {
                return false;
            }
        }
        else {
            if (indexOrCol < 0 || indexOrCol >= this.data.length) {
                // Tiles that don't exist aren't collidable
                return false;
            }
            // We have an index
            tile = this.getTile(indexOrCol);
        }
        return this.collisionMap[tile];
    }
    /**
     * Takes in world coordinates and returns the row and column of the tile at that position
     * @param worldCoords The coordinates of the potential tile in world space
     * @returns A Vec2 containing the coordinates of the potential tile in tilemap space
     */
    getColRowAt(worldCoords) {
        let col = Math.floor(worldCoords.x / this.tileSize.x / this.scale.x);
        let row = Math.floor(worldCoords.y / this.tileSize.y / this.scale.y);
        return new Vec2_1.default(col, row);
    }
    // @override
    update(deltaT) { }
    // @override
    debugRender() {
        // Half of the tile size
        let zoomedHalfTileSize = this.getTileSizeWithZoom().scaled(0.5);
        let halfTileSize = this.getTileSize().scaled(0.5);
        // The center of the top left tile
        let topLeft = this.position.clone().sub(this.size.scaled(0.5));
        // A vec to store the center
        let center = Vec2_1.default.ZERO;
        for (let col = 0; col < this.numCols; col++) {
            // Calculate the x-position
            center.x = topLeft.x + col * 2 * halfTileSize.x + halfTileSize.x;
            for (let row = 0; row < this.numRows; row++) {
                if (this.isCollidable && this.isTileCollidable(col, row)) {
                    // Calculate the y-position
                    center.y = topLeft.y + row * 2 * halfTileSize.y + halfTileSize.y;
                    // Draw a box for this tile
                    Debug_1.default.drawBox(this.inRelativeCoordinates(center), zoomedHalfTileSize, false, Color_1.default.BLUE);
                }
            }
        }
    }
}
exports.default = OrthogonalTilemap;
},{"../../DataTypes/Vec2":56,"../../Debug/Debug":57,"../../Utils/Color":131,"../Tilemap":81}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("./CanvasNode");
const Color_1 = require("../Utils/Color");
const Vec2_1 = require("../DataTypes/Vec2");
const Input_1 = require("../Input/Input");
/**
 * The representation of a UIElement - the parent class of things like buttons
 */
class UIElement extends CanvasNode_1.default {
    constructor(position) {
        super();
        this.position = position;
        this.backgroundColor = new Color_1.default(0, 0, 0, 0);
        this.borderColor = new Color_1.default(0, 0, 0, 0);
        this.borderRadius = 5;
        this.borderWidth = 1;
        this.padding = Vec2_1.default.ZERO;
        this.onClick = null;
        this.onClickEventId = null;
        this.onRelease = null;
        this.onReleaseEventId = null;
        this.onEnter = null;
        this.onEnterEventId = null;
        this.onLeave = null;
        this.onLeaveEventId = null;
        this.isClicked = false;
        this.isEntered = false;
    }
    // @deprecated
    setBackgroundColor(color) {
        this.backgroundColor = color;
    }
    // @deprecated
    setPadding(padding) {
        this.padding.copy(padding);
    }
    update(deltaT) {
        super.update(deltaT);
        // See of this object was just clicked
        if (Input_1.default.isMouseJustPressed()) {
            // Changed from Input.getMousePressPosition()
            let clickPos = Input_1.default.getMousePosition();
            if (this.contains(clickPos.x, clickPos.y) &&
                this.visible &&
                !this.layer.isHidden()) {
                this.isClicked = true;
                if (this.onClick !== null) {
                    this.onClick();
                }
                if (this.onClickEventId !== null) {
                    let data = {};
                    this.emitter.fireEvent(this.onClickEventId, data);
                }
            }
        }
        // If the mouse wasn't just pressed, then we definitely weren't clicked
        if (!Input_1.default.isMousePressed()) {
            if (this.isClicked) {
                this.isClicked = false;
            }
        }
        // Check if the mouse is hovering over this element
        let mousePos = Input_1.default.getMousePosition();
        if (mousePos && this.contains(mousePos.x, mousePos.y)) {
            this.isEntered = true;
            if (this.onEnter !== null) {
                this.onEnter();
            }
            if (this.onEnterEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onEnterEventId, data);
            }
        }
        else if (this.isEntered) {
            this.isEntered = false;
            if (this.onLeave !== null) {
                this.onLeave();
            }
            if (this.onLeaveEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onLeaveEventId, data);
            }
        }
        else if (this.isClicked) {
            // If mouse is dragged off of element while down, it is not clicked anymore
            this.isClicked = false;
        }
    }
    /**
     * Overridable method for calculating background color - useful for elements that want to be colored on different after certain events
     * @returns The background color of the UIElement
     */
    calculateBackgroundColor() {
        return this.backgroundColor;
    }
    /**
     * Overridable method for calculating border color - useful for elements that want to be colored on different after certain events
     * @returns The border color of the UIElement
     */
    calculateBorderColor() {
        return this.borderColor;
    }
}
exports.default = UIElement;
},{"../DataTypes/Vec2":56,"../Input/Input":64,"../Utils/Color":131,"./CanvasNode":71}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Label_1 = require("./Label");
const Color_1 = require("../../Utils/Color");
/** A clickable button UIElement */
class Button extends Label_1.default {
    constructor(position, text) {
        super(position, text);
        this.backgroundColor = new Color_1.default(150, 75, 203);
        this.borderColor = new Color_1.default(41, 46, 30);
        this.textColor = new Color_1.default(255, 255, 255);
    }
    // @override
    calculateBackgroundColor() {
        // Change the background color if clicked or hovered
        if (this.isEntered && !this.isClicked) {
            return this.backgroundColor.lighten();
        }
        else if (this.isClicked) {
            return this.backgroundColor.darken();
        }
        else {
            return this.backgroundColor;
        }
    }
}
exports.default = Button;
},{"../../Utils/Color":131,"./Label":85}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HAlign = exports.VAlign = void 0;
const Vec2_1 = require("../../DataTypes/Vec2");
const Color_1 = require("../../Utils/Color");
const UIElement_1 = require("../UIElement");
/** A basic text-containing label */
class Label extends UIElement_1.default {
    constructor(position, text) {
        super(position);
        this.text = text;
        this.textColor = new Color_1.default(0, 0, 0, 1);
        this.font = "Arial";
        this.fontSize = 30;
        this.hAlign = "center";
        this.vAlign = "center";
        this.sizeAssigned = false;
    }
    // @deprecated
    setText(text) {
        this.text = text;
    }
    // @deprecated
    setTextColor(color) {
        this.textColor = color;
    }
    /**
     * Gets a string containg the font details for rendering
     * @returns A string containing the font details
     */
    getFontString() {
        return this.fontSize + "px " + this.font;
    }
    /**
     * Overridable method for calculating text color - useful for elements that want to be colored on different after certain events
     * @returns a string containg the text color
     */
    calculateTextColor() {
        return this.textColor.toStringRGBA();
    }
    /**
     * Uses the canvas to calculate the width of the text
     * @param ctx The rendering context
     * @returns A number representing the rendered text width
     */
    calculateTextWidth(ctx) {
        ctx.font = this.fontSize + "px " + this.font;
        return ctx.measureText(this.text).width;
    }
    setHAlign(align) {
        this.hAlign = align;
    }
    setVAlign(align) {
        this.vAlign = align;
    }
    /**
     * Calculate the offset of the text - this is used for rendering text with different alignments
     * @param ctx The rendering context
     * @returns The offset of the text in a Vec2
     */
    calculateTextOffset(ctx) {
        let textWidth = this.calculateTextWidth(ctx);
        let offset = new Vec2_1.default(0, 0);
        let hDiff = this.size.x - textWidth;
        if (this.hAlign === HAlign.CENTER) {
            offset.x = hDiff / 2;
        }
        else if (this.hAlign === HAlign.RIGHT) {
            offset.x = hDiff - this.padding.x;
        }
        else {
            offset.x = this.padding.x;
        }
        if (this.vAlign === VAlign.TOP) {
            ctx.textBaseline = "top";
            offset.y = 0;
        }
        else if (this.vAlign === VAlign.BOTTOM) {
            ctx.textBaseline = "bottom";
            offset.y = this.size.y;
        }
        else {
            ctx.textBaseline = "middle";
            offset.y = this.size.y / 2;
        }
        return offset;
    }
    sizeChanged() {
        super.sizeChanged();
        this.sizeAssigned = true;
    }
    /**
     * Automatically sizes the element to the text within it
     * @param ctx The rendering context
     */
    autoSize(ctx) {
        let width = this.calculateTextWidth(ctx);
        let height = this.fontSize;
        this.size.set(width + this.padding.x * 2, height + this.padding.y * 2);
        this.sizeAssigned = true;
    }
    /**
     * Initially assigns a size to the UIElement if none is provided
     * @param ctx The rendering context
     */
    handleInitialSizing(ctx) {
        if (!this.sizeAssigned) {
            this.autoSize(ctx);
        }
    }
    /** On the next render, size this element to it's current text using its current font size */
    sizeToText() {
        this.sizeAssigned = false;
    }
}
exports.default = Label;
var VAlign;
(function (VAlign) {
    VAlign["TOP"] = "top";
    VAlign["CENTER"] = "center";
    VAlign["BOTTOM"] = "bottom";
})(VAlign = exports.VAlign || (exports.VAlign = {}));
var HAlign;
(function (HAlign) {
    HAlign["LEFT"] = "left";
    HAlign["CENTER"] = "center";
    HAlign["RIGHT"] = "right";
})(HAlign = exports.HAlign || (exports.HAlign = {}));
},{"../../DataTypes/Vec2":56,"../../Utils/Color":131,"../UIElement":83}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const Input_1 = require("../../Input/Input");
const Color_1 = require("../../Utils/Color");
const MathUtils_1 = require("../../Utils/MathUtils");
const UIElement_1 = require("../UIElement");
/** A slider UIElement */
class Slider extends UIElement_1.default {
    constructor(position, initValue) {
        super(position);
        this.value = initValue;
        this.nibColor = Color_1.default.RED;
        this.sliderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.TRANSPARENT;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.nibSize = new Vec2_1.default(10, 20);
        // Set a default size
        this.size.set(200, 20);
    }
    /**
     * Retrieves the value of the slider
     * @returns The value of the slider
     */
    getValue() {
        return this.value;
    }
    /** A method called in response to the value changing */
    valueChanged() {
        if (this.onValueChange) {
            this.onValueChange(this.value);
        }
        if (this.onValueChangeEventId) {
            this.emitter.fireEvent(this.onValueChangeEventId, {
                target: this,
                value: this.value,
            });
        }
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.isClicked) {
            let val = MathUtils_1.default.invLerp(this.position.x - this.size.x / 2, this.position.x + this.size.x / 2, Input_1.default.getMousePosition().x);
            this.value = MathUtils_1.default.clamp01(val);
            this.valueChanged();
        }
    }
}
exports.default = Slider;
},{"../../DataTypes/Vec2":56,"../../Input/Input":64,"../../Utils/Color":131,"../../Utils/MathUtils":134,"../UIElement":83}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = require("../../Utils/Color");
const Label_1 = require("./Label");
const Input_1 = require("../../Input/Input");
/** A text input UIElement */
class TextInput extends Label_1.default {
    constructor(position) {
        super(position, "");
        this.focused = false;
        this.cursorCounter = 0;
        // Give a default size to the x only
        this.size.set(200, this.fontSize);
        this.hAlign = "left";
        this.borderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.WHITE;
    }
    update(deltaT) {
        super.update(deltaT);
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y)) {
                this.focused = true;
                this.cursorCounter = 30;
            }
            else {
                this.focused = false;
            }
        }
        if (this.focused) {
            let keys = Input_1.default.getKeysJustPressed();
            let nums = "1234567890";
            let specialChars = "`~!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?";
            let letters = "qwertyuiopasdfghjklzxcvbnm";
            let mask = nums + specialChars + letters;
            keys = keys.filter(key => mask.includes(key));
            let shiftPressed = Input_1.default.isKeyPressed("shift");
            let backspacePressed = Input_1.default.isKeyJustPressed("backspace");
            let spacePressed = Input_1.default.isKeyJustPressed("space");
            if (backspacePressed) {
                this.text = this.text.substring(0, this.text.length - 1);
            }
            else if (spacePressed) {
                this.text += " ";
            }
            else if (keys.length > 0) {
                if (shiftPressed) {
                    this.text += keys[0].toUpperCase();
                }
                else {
                    this.text += keys[0];
                }
            }
        }
    }
}
exports.default = TextInput;
},{"../../Input/Input":64,"../../Utils/Color":131,"./Label":85}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIElementType = void 0;
var UIElementType;
(function (UIElementType) {
    UIElementType["BUTTON"] = "BUTTON";
    UIElementType["LABEL"] = "LABEL";
    UIElementType["SLIDER"] = "SLIDER";
    UIElementType["TEXT_INPUT"] = "TEXTINPUT";
})(UIElementType = exports.UIElementType || (exports.UIElementType = {}));
},{}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * The manager class for navigation.
 * Handles all navigable entities, such and allows them to be accessed by outside systems by requesting a path
 * from one position to another.
 */
class NavigationManager {
    constructor() {
        this.navigableEntities = new Map_1.default();
    }
    /**
     * Adds a navigable entity to the NavigationManager
     * @param navName The name of the navigable entitry
     * @param nav The actual Navigable instance
     */
    addNavigableEntity(navName, nav) {
        this.navigableEntities.add(navName, nav);
    }
    /**
     * Gets a path frome one point to another using a specified Navigable object
     * @param navName The name of the registered Navigable object
     * @param fromPosition The starting position of navigation
     * @param toPosition The ending position of Navigation
     * @param direct If true, go direct from fromPosition to toPosition, don't use NavMesh
     * @returns A NavigationPath containing the route to take over the Navigable entity to get between the provided positions.
     */
    getPath(navName, fromPosition, toPosition, direct) {
        let nav = this.navigableEntities.get(navName);
        return nav.getNavigationPath(fromPosition.clone(), toPosition.clone(), direct);
    }
}
exports.default = NavigationManager;
},{"../DataTypes/Map":43}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
/**
 * A path that AIs can follow. Uses finishMove() in Physical to determine progress on the route
 */
class NavigationPath {
    /**
     * Constructs a new NavigationPath
     * @param path The path of nodes to take
     */
    constructor(path) {
        this.path = path;
        this.currentMoveDirection = Vec2_1.default.ZERO;
        this.distanceThreshold = 4;
    }
    /**
     * Returns the status of navigation along this NavigationPath
     * @returns True if the node has reached the end of the path, false otherwise
     */
    isDone() {
        return this.path.isEmpty();
    }
    /**
     * Gets the movement direction in the current position along the path
     * @param node The node to move along the path
     * @returns The movement direction as a Vec2
     */
    getMoveDirection(node) {
        // Return direction to next point in the nav
        return node.position.dirTo(this.path.peek());
    }
    /**
     * Updates this NavigationPath to the current state of the GameNode
     * @param node The node moving along the path
     */
    handlePathProgress(node) {
        if (node.position.distanceSqTo(this.path.peek()) <
            this.distanceThreshold * this.distanceThreshold) {
            // We've reached our node, move on to the next destination
            this.path.pop();
        }
    }
    toString() {
        return this.path.toString();
    }
}
exports.default = NavigationPath;
},{"../DataTypes/Vec2":56}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = require("../DataTypes/Stack");
const GraphUtils_1 = require("../Utils/GraphUtils");
const NavigationPath_1 = require("./NavigationPath");
/**
 * An implementation of a Navmesh. Navmeshes are graphs in the game world along which nodes can move.
 */
class Navmesh {
    /**
     * Creates a new Navmesh from the points in the speecified graph
     * @param graph The graph to construct a navmesh from
     */
    constructor(graph) {
        this.graph = graph;
    }
    // @implemented
    getNavigationPath(fromPosition, toPosition, direct) {
        let start = this.getClosestNode(fromPosition);
        let end = this.getClosestNode(toPosition);
        let pathStack = new Stack_1.default(this.graph.numVertices);
        // Push the final position and the final position in the graph
        pathStack.push(toPosition.clone());
        if (direct) {
            return new NavigationPath_1.default(pathStack);
        }
        pathStack.push(this.graph.positions[end]);
        let parent = GraphUtils_1.default.djikstra(this.graph, start);
        // Add all parents along the path
        let i = end;
        while (parent[i] !== -1) {
            pathStack.push(this.graph.positions[parent[i]]);
            i = parent[i];
        }
        return new NavigationPath_1.default(pathStack);
    }
    /**
     * Gets the closest node in this Navmesh to the specified position
     * @param position The position to query
     * @returns The index of the closest node in the Navmesh to the position
     */
    getClosestNode(position) {
        let n = this.graph.numVertices;
        let i = 1;
        let index = 0;
        let dist = position.distanceSqTo(this.graph.positions[0]);
        while (i < n) {
            let d = position.distanceSqTo(this.graph.positions[i]);
            if (d < dist) {
                dist = d;
                index = i;
            }
            i++;
        }
        return index;
    }
}
exports.default = Navmesh;
},{"../DataTypes/Stack":52,"../Utils/GraphUtils":133,"./NavigationPath":90}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PhysicsManager_1 = require("./PhysicsManager");
const Vec2_1 = require("../DataTypes/Vec2");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
const AreaCollision_1 = require("../DataTypes/Physics/AreaCollision");
/**
 * ALGORITHM:
 * 	In an effort to keep things simple and working effectively, each dynamic node will resolve its
 * 	collisions considering the rest of the world as static.
 *
 * 	Collision detecting will happen first. This can be considered a broad phase, but it is not especially
 * 	efficient, as it does not need to be for this game engine. Every dynamic node is checked against every
 * 	other node for collision area. If collision area is non-zero (meaning the current node sweeps into another),
 * 	it is added to a list of hits.
 *
 * 	INITIALIZATION:
 * 		- Physics constants are reset
 * 		- Swept shapes are recalculated. If a node isn't moving, it is skipped.
 *
 * 	COLLISION DETECTION:
 * 		- For a node, collision area will be calculated using the swept AABB of the node against every other AABB in a static state
 * 		- These collisions will be sorted by area in descending order
 *
 * 	COLLISION RESOLUTION:
 * 		- For each hit, time of collision is calculated using a swept line through the AABB of the static node expanded
 * 			with minkowski sums (discretely, but the concept is there)
 * 		- The collision is resolved based on the near time of the collision (from method of separated axes)
 * 			- X is resolved by near x, Y by near y.
 * 			- There is some fudging to allow for sliding along walls of separate colliders. Sorting by area also helps with this.
 * 			- Corner to corner collisions are resolve to favor x-movement. This is in consideration of platformers, to give
 * 				the player some help with jumps
 *
 * 	Pros:
 * 		- Everything happens with a consistent time. There is a distinct before and after for each resolution.
 * 		- No back-tracking needs to be done. Once we resolve a node, it is definitively resolved.
 *
 * 	Cons:
 * 		- Nodes that are processed early have movement priority over other nodes. This can lead to some undesirable interactions.
 */
class BasicPhysicsManager extends PhysicsManager_1.default {
    constructor(options) {
        super();
        this.staticNodes = new Array();
        this.dynamicNodes = new Array();
        this.tilemaps = new Array();
        this.collisionMasks = new Array(32);
        // Parse options
        this.parseOptions(options);
    }
    /**
     * Parses the options for constructing the physics manager
     * @param options A record of options
     */
    parseOptions(options) {
        if (options.groupNames !== undefined && options.collisions !== undefined) {
            for (let i = 0; i < options.groupNames.length; i++) {
                let group = options.groupNames[i];
                // Register the group name and number
                this.groupNames[i] = group;
                this.groupMap.set(group, 1 << i);
                let collisionMask = 0;
                for (let j = 0; j < options.collisions[i].length; j++) {
                    if (options.collisions[i][j]) {
                        collisionMask |= 1 << j;
                    }
                }
                this.collisionMasks[i] = collisionMask;
            }
        }
    }
    // @override
    registerObject(node) {
        if (node.isStatic) {
            // Static and not collidable
            this.staticNodes.push(node);
        }
        else {
            // Dynamic and not collidable
            this.dynamicNodes.push(node);
        }
    }
    // @override
    deregisterObject(node) {
        if (node.isStatic) {
            // Remove the node from the static list
            const index = this.staticNodes.indexOf(node);
            this.staticNodes.splice(index, 1);
        }
        else {
            // Remove the node from the dynamic list
            const index = this.dynamicNodes.indexOf(node);
            this.dynamicNodes.splice(index, 1);
        }
    }
    // @override
    registerTilemap(tilemap) {
        this.tilemaps.push(tilemap);
    }
    // @override
    deregisterTilemap(tilemap) {
        const index = this.tilemaps.indexOf(tilemap);
        this.tilemaps.splice(index, 1);
    }
    // @override
    update(deltaT) {
        for (let node of this.dynamicNodes) {
            /*---------- INITIALIZATION PHASE ----------*/
            // Clear frame dependent boolean values for each node
            node.onGround = false;
            node.onCeiling = false;
            node.onWall = false;
            node.collidedWithTilemap = false;
            node.isColliding = false;
            // If this node is not active, don't process it
            if (!node.active) {
                continue;
            }
            // Update the swept shapes of each node
            if (node.moving) {
                // If moving, reflect that in the swept shape
                node.sweptRect.sweep(node._velocity, node.collisionShape.center, node.collisionShape.halfSize);
            }
            else {
                // If our node isn't moving, don't bother to check it (other nodes will detect if they run into it)
                node._velocity.zero();
                continue;
            }
            /*---------- DETECTION PHASE ----------*/
            // Gather a set of overlaps
            let overlaps = new Array();
            let groupIndex = node.group === -1 ? -1 : Math.log2(node.group);
            // First, check this node against every static node (order doesn't actually matter here, since we sort anyways)
            for (let other of this.staticNodes) {
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Then, check it against every dynamic node
            for (let other of this.dynamicNodes) {
                // Ignore ourselves
                if (node === other)
                    continue;
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Lastly, gather a set of AABBs from the tilemap.
            // This step involves the most extra work, so it is abstracted into a method
            for (let tilemap of this.tilemaps) {
                // Ignore inactive tilemaps
                if (!tilemap.active)
                    continue;
                if (tilemap instanceof OrthogonalTilemap_1.default) {
                    this.collideWithOrthogonalTilemap(node, tilemap, overlaps);
                }
            }
            // Sort the overlaps by area
            overlaps = overlaps.sort((a, b) => b.area - a.area);
            // Keep track of hits to use later
            let hits = [];
            /*---------- RESOLUTION PHASE ----------*/
            // For every overlap, determine if we need to collide with it and when
            for (let overlap of overlaps) {
                // Ignore nodes we don't interact with
                if (groupIndex !== -1 &&
                    overlap.other.group !== -1 &&
                    (this.collisionMasks[groupIndex] & overlap.other.group) === 0)
                    continue;
                // Do a swept line test on the static AABB with this AABB size as padding (this is basically using a minkowski sum!)
                // Start the sweep at the position of this node with a delta of _velocity
                const point = node.collisionShape.center;
                const delta = node._velocity;
                const padding = node.collisionShape.halfSize;
                const otherAABB = overlap.collider;
                const hit = otherAABB.intersectSegment(node.collisionShape.center, node._velocity, node.collisionShape.halfSize);
                overlap.hit = hit;
                if (hit !== null) {
                    hits.push(hit);
                    // We got a hit, resolve with the time inside of the hit
                    let tnearx = hit.nearTimes.x;
                    let tneary = hit.nearTimes.y;
                    // Allow edge clipping (edge overlaps don't count, only area overlaps)
                    // Importantly don't allow both cases to be true. Then we clip through corners. Favor x to help players land jumps
                    if (tnearx < 1.0 &&
                        (point.y === otherAABB.top - padding.y ||
                            point.y === otherAABB.bottom + padding.y) &&
                        delta.x !== 0) {
                        tnearx = 1.0;
                    }
                    else if (tneary < 1.0 &&
                        (point.x === otherAABB.left - padding.x ||
                            point.x === otherAABB.right + padding.x) &&
                        delta.y !== 0) {
                        tneary = 1.0;
                    }
                    if (hit.nearTimes.x >= 0 && hit.nearTimes.x < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.x = node._velocity.x * tnearx;
                            node.isColliding = true;
                        }
                    }
                    if (hit.nearTimes.y >= 0 && hit.nearTimes.y < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.y = node._velocity.y * tneary;
                            node.isColliding = true;
                        }
                    }
                }
            }
            /*---------- INFORMATION/TRIGGER PHASE ----------*/
            // Check if we ended up on the ground, ceiling or wall
            // Also check for triggers
            for (let overlap of overlaps) {
                // Check for a trigger. If we care about the trigger, react
                if (overlap.other.isTrigger && overlap.other.triggerMask & node.group) {
                    // Get the bit that this group is represented by
                    let index = Math.floor(Math.log2(node.group));
                    // Extract the triggerEnter event name
                    this.emitter.fireEvent(overlap.other.triggerEnters[index], {
                        node: node.id,
                        other: overlap.other.id,
                    });
                }
                // Ignore collision sides for nodes we don't interact with
                if (groupIndex !== -1 &&
                    overlap.other.group !== -1 &&
                    (this.collisionMasks[groupIndex] & overlap.other.group) === 0)
                    continue;
                // Only check for direction if the overlap was collidable
                if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                    let collisionSide = overlap.collider.touchesAABBWithoutCorners(node.collisionShape.getBoundingRect());
                    if (collisionSide !== null) {
                        // If we touch, not including corner cases, check the collision normal
                        if (overlap.hit !== null) {
                            // If we hit a tilemap, keep track of it
                            if (overlap.type == "Tilemap") {
                                node.collidedWithTilemap = true;
                            }
                            if (collisionSide.y === -1) {
                                // Node is on top of overlap, so onGround
                                node.onGround = true;
                            }
                            else if (collisionSide.y === 1) {
                                // Node is on bottom of overlap, so onCeiling
                                node.onCeiling = true;
                            }
                            else {
                                // Node wasn't touching on y, so it is touching on x
                                node.onWall = true;
                            }
                        }
                    }
                }
            }
            // Resolve the collision with the node, and move it
            node.finishMove();
        }
    }
    /**
     * Handles a collision between this node and an orthogonal tilemap
     * @param node The node
     * @param tilemap The tilemap the node may be colliding with
     * @param overlaps The list of overlaps
     */
    collideWithOrthogonalTilemap(node, tilemap, overlaps) {
        // Get the min and max x and y coordinates of the moving node
        let min = new Vec2_1.default(node.sweptRect.left, node.sweptRect.top);
        let max = new Vec2_1.default(node.sweptRect.right, node.sweptRect.bottom);
        // Convert the min/max x/y to the min and max row/col in the tilemap array
        let minIndex = tilemap.getColRowAt(min);
        let maxIndex = tilemap.getColRowAt(max);
        let tileSize = tilemap.getTileSize();
        // Loop over all possible tiles (which isn't many in the scope of the velocity per frame)
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (tilemap.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a new collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    // Calculate collision area between the node and the tile
                    let area = node.sweptRect.overlapArea(collider);
                    if (area > 0) {
                        // We had a collision
                        overlaps.push(new AreaCollision_1.default(area, collider, tilemap, "Tilemap", new Vec2_1.default(col, row)));
                    }
                }
            }
        }
    }
}
exports.default = BasicPhysicsManager;
},{"../DataTypes/Physics/AreaCollision":45,"../DataTypes/Shapes/AABB":49,"../DataTypes/Vec2":56,"../Nodes/Tilemaps/OrthogonalTilemap":82,"./PhysicsManager":93}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const Map_1 = require("../DataTypes/Map");
/**
 * An abstract physics manager.
 * This class exposes functions for subclasses to implement that should allow for a working physics system to be created.
 */
class PhysicsManager {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        // The creation and implementation of layers is deferred to the subclass
        this.groupMap = new Map_1.default();
        this.groupNames = new Array();
    }
    destroy() {
        this.receiver.destroy();
    }
    /**
     * Sets the physics layer of the GameNode
     * @param node The GameNode
     * @param group The group that the GameNode should be on
     */
    setGroup(node, group) {
        node.group = this.groupMap.get(group);
    }
    /**
     * Retrieves the layer number associated with the provided name
     * @param layer The name of the layer
     * @returns The layer number, or 0 if there is not a layer with that name registered
     */
    getGroupNumber(group) {
        if (this.groupMap.has(group)) {
            return this.groupMap.get(group);
        }
        else {
            return 0;
        }
    }
    /**
     * Gets all group names associated with the number provided
     * @param groups A mask of groups
     * @returns All groups contained in the mask
     */
    getGroupNames(groups) {
        if (groups === -1) {
            return [PhysicsManager.DEFAULT_GROUP];
        }
        else {
            let g = 1;
            let names = [];
            for (let i = 0; i < 32; i++) {
                if (g & groups) {
                    // This group is in the groups number
                    names.push(this.groupNames[i]);
                }
                // Shift the bit over
                g = g << 1;
            }
        }
    }
}
exports.default = PhysicsManager;
/** The default group name */
PhysicsManager.DEFAULT_GROUP = "Default";
},{"../DataTypes/Map":43,"../Events/Emitter":59,"../Events/Receiver":63}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const Receiver_1 = require("../Events/Receiver");
const EventQueue_1 = require("../Events/EventQueue");
const GameEventType_1 = require("../Events/GameEventType");
// @ignorePage
class Recorder {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.log = new Queue_1.default(1000);
        this.recording = false;
        this.playing = false;
        this.frame = 0;
        this.eventQueue = EventQueue_1.default.getInstance();
        this.eventQueue.subscribe(this.receiver, "all");
    }
    update(deltaT) {
        if (this.recording) {
            this.frame += 1;
        }
        if (this.playing) {
            // If playing, ignore events, just feed the record to the event queue
            this.receiver.ignoreEvents();
            /*
                      While there is a next item, and while it should occur in this frame,
                      send the event. i.e., while current_frame * current_delta_t is greater
                      than recorded_frame * recorded_delta_t
                  */
            while (this.log.hasItems() &&
                this.log.peekNext().frame * this.log.peekNext().delta <
                    this.frame * deltaT) {
                let event = this.log.dequeue().event;
                console.log(event);
                this.eventQueue.addEvent(event);
            }
            if (!this.log.hasItems()) {
                this.playing = false;
            }
            this.frame += 1;
        }
        else {
            // If not playing, handle events
            while (this.receiver.hasNextEvent()) {
                let event = this.receiver.getNextEvent();
                if (event.type === GameEventType_1.GameEventType.STOP_RECORDING) {
                    this.recording = false;
                }
                if (this.recording) {
                    this.log.enqueue(new LogItem(this.frame, deltaT, event));
                }
                if (event.type === GameEventType_1.GameEventType.START_RECORDING) {
                    this.log.clear();
                    this.recording = true;
                    this.frame = 0;
                }
                if (event.type === GameEventType_1.GameEventType.PLAY_RECORDING) {
                    this.frame = 0;
                    this.recording = false;
                    this.playing = true;
                }
            }
        }
    }
}
exports.default = Recorder;
class LogItem {
    constructor(frame, deltaT, event) {
        this.frame = frame;
        this.delta = deltaT;
        this.event = event;
    }
}
},{"../DataTypes/Queue":47,"../Events/EventQueue":60,"../Events/GameEventType":62,"../Events/Receiver":63}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
/** */
class Registry extends Map_1.default {
}
exports.default = Registry;
},{"../../DataTypes/Map":43}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LabelShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType");
const PointShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/PointShaderType");
const RectShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/RectShaderType");
const SpriteShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Registry_1 = require("./Registry");
/**
 * A registry that handles shaders
 */
class ShaderRegistry extends Registry_1.default {
    constructor() {
        super(...arguments);
        this.registryItems = new Array();
    }
    /**
     * Preloads all built-in shaders
     */
    preload() {
        // Get the resourceManager and queue all built-in shaders for preloading
        const rm = ResourceManager_1.default.getInstance();
        // Queue a load for the point shader
        this.registerAndPreloadItem(ShaderRegistry.POINT_SHADER, PointShaderType_1.default, "builtin/shaders/point.vshader", "builtin/shaders/point.fshader");
        // Queue a load for the rect shader
        this.registerAndPreloadItem(ShaderRegistry.RECT_SHADER, RectShaderType_1.default, "builtin/shaders/rect.vshader", "builtin/shaders/rect.fshader");
        // Queue a load for the sprite shader
        this.registerAndPreloadItem(ShaderRegistry.SPRITE_SHADER, SpriteShaderType_1.default, "builtin/shaders/sprite.vshader", "builtin/shaders/sprite.fshader");
        // Queue a load for the label shader
        this.registerAndPreloadItem(ShaderRegistry.LABEL_SHADER, LabelShaderType_1.default, "builtin/shaders/label.vshader", "builtin/shaders/label.fshader");
        // Queue a load for any preloaded items
        for (let item of this.registryItems) {
            const shader = new item.constr(item.key);
            shader.initBufferObject();
            this.add(item.key, shader);
            // Load if desired
            if (item.preload !== undefined) {
                rm.shader(item.key, item.preload.vshaderLocation, item.preload.fshaderLocation);
            }
        }
    }
    /**
     * Registers a shader in the registry and loads it before the game begins
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     * @param vshaderLocation The location of the vertex shader
     * @param fshaderLocation the location of the fragment shader
     */
    registerAndPreloadItem(key, constr, vshaderLocation, fshaderLocation) {
        let shaderPreload = new ShaderPreload();
        shaderPreload.vshaderLocation = vshaderLocation;
        shaderPreload.fshaderLocation = fshaderLocation;
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        registryItem.preload = shaderPreload;
        this.registryItems.push(registryItem);
    }
    /**
     * Registers a shader in the registry. NOTE: If you use this, you MUST load the shader before use.
     * If you wish to preload the shader, use registerAndPreloadItem()
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     */
    registerItem(key, constr) {
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        this.registryItems.push(registryItem);
    }
}
exports.default = ShaderRegistry;
// Shader names
ShaderRegistry.POINT_SHADER = "point";
ShaderRegistry.RECT_SHADER = "rect";
ShaderRegistry.SPRITE_SHADER = "sprite";
ShaderRegistry.LABEL_SHADER = "label";
class ShaderRegistryItem {
}
class ShaderPreload {
}
},{"../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType":110,"../../Rendering/WebGLRendering/ShaderTypes/PointShaderType":111,"../../Rendering/WebGLRendering/ShaderTypes/RectShaderType":113,"../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType":114,"../../ResourceManager/ResourceManager":115,"./Registry":95}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const ShaderRegistry_1 = require("./Registries/ShaderRegistry");
/**
 * The Registry is the system's way of converting classes and types into string
 * representations for use elsewhere in the application.
 * It allows classes to be accessed without explicitly using constructors in code,
 * and for resources to be loaded at Game creation time.
 */
class RegistryManager {
    static preload() {
        this.shaders.preload();
        this.registries.forEach((key) => this.registries.get(key).preload());
    }
    static addCustomRegistry(name, registry) {
        this.registries.add(name, registry);
    }
    static getRegistry(key) {
        return this.registries.get(key);
    }
}
exports.default = RegistryManager;
RegistryManager.shaders = new ShaderRegistry_1.default();
/** Additional custom registries to add to the registry manager */
RegistryManager.registries = new Map_1.default();
},{"../DataTypes/Map":43,"./Registries/ShaderRegistry":96}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
const Emitter_1 = require("../../Events/Emitter");
const AnimationTypes_1 = require("./AnimationTypes");
/**
 * An animation manager class for an animated CanvasNode.
 * This class keeps track of the possible animations, as well as the current animation state,
 * and abstracts all interactions with playing, pausing, and stopping animations as well as
 * creating new animations from the CanvasNode.
 */
class AnimationManager {
    /**
     * Creates a new AnimationManager
     * @param owner The owner of the AnimationManager
     */
    constructor(owner) {
        this.owner = owner;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.currentAnimation = "";
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.loop = false;
        this.animations = new Map_1.default();
        this.onEndEvent = null;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Add an animation to this sprite
     * @param key The unique key of the animation
     * @param animation The animation data
     */
    add(key, animation) {
        this.animations.add(key, animation);
    }
    /**
     * Gets the index specified by the current animation and current frame
     * @returns The index in the current animation
     */
    getIndex() {
        if (this.animations.has(this.currentAnimation)) {
            return this.animations.get(this.currentAnimation).frames[this.currentFrame].index;
        }
        else {
            // No current animation, warn the user
            console.warn(`Animation index was requested, but the current animation: ${this.currentAnimation} was invalid`);
            return 0;
        }
    }
    getAnimationData() {
        if (this.animations.has(this.currentAnimation)) {
            return this.animations.get(this.currentAnimation).frames[this.currentFrame];
        }
    }
    /**
     * Determines whether the specified animation is currently playing
     * @param key The key of the animation to check
     * @returns true if the specified animation is playing, false otherwise
     */
    isPlaying(key) {
        return (this.currentAnimation === key &&
            this.animationState === AnimationTypes_1.AnimationState.PLAYING);
    }
    /**
     * Retrieves the current animation index and advances the animation frame
     * @returns The index of the animation frame
     */
    getIndexAndAdvanceAnimation() {
        // If we aren't playing, we won't be advancing the animation
        if (!(this.animationState === AnimationTypes_1.AnimationState.PLAYING)) {
            return this.getIndex();
        }
        if (this.animations.has(this.currentAnimation)) {
            let currentAnimation = this.animations.get(this.currentAnimation);
            let index = currentAnimation.frames[this.currentFrame].index;
            // Advance the animation
            this.frameProgress += 1;
            if (this.frameProgress >=
                currentAnimation.frames[this.currentFrame].duration) {
                // We have been on this frame for its whole duration, go to the next one
                this.frameProgress = 0;
                this.currentFrame += 1;
                if (this.currentFrame >= currentAnimation.frames.length) {
                    // We have reached the end of this animation
                    if (this.loop) {
                        this.currentFrame = 0;
                        this.frameProgress = 0;
                    }
                    else {
                        this.endCurrentAnimation();
                    }
                }
            }
            // Return the current index
            return index;
        }
        else {
            // No current animation, can't advance. Warn the user
            console.warn(`Animation index and advance was requested, but the current animation (${this.currentAnimation}) in node with id: ${this.owner.id} was invalid`);
            return 0;
        }
    }
    /** Ends the current animation and fires any necessary events, as well as starting any new animations */
    endCurrentAnimation() {
        this.currentFrame = 0;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        if (this.onEndEvent !== null) {
            this.emitter.fireEvent(this.onEndEvent, {
                owner: this.owner.id,
                animation: this.currentAnimation,
            });
        }
        // If there is a pending animation, play it
        if (this.pendingAnimation !== null) {
            this.play(this.pendingAnimation, this.pendingLoop, this.pendingOnEnd);
        }
    }
    /**
     * Plays the specified animation. Does not restart it if it is already playing
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    playIfNotAlready(animation, loop, onEnd) {
        if (this.currentAnimation !== animation) {
            this.play(animation, loop, onEnd);
        }
    }
    /**
     * Plays the specified animation
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    play(animation, loop, onEnd) {
        this.currentAnimation = animation;
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        // If loop arg was provided, use that
        if (loop !== undefined) {
            this.loop = loop;
        }
        else {
            // Otherwise, use what the json file specified
            this.loop = this.animations.get(animation).repeat;
        }
        if (onEnd !== undefined) {
            this.onEndEvent = onEnd;
        }
        else {
            this.onEndEvent = null;
        }
        // Reset pending animation
        this.pendingAnimation = null;
    }
    /**
     * Queues a single animation to be played after the current one. Does NOT stack.
     * Queueing additional animations past 1 will just replace the queued animation
     * @param animation The animation to queue
     * @param loop Whether or not the loop the queued animation
     * @param onEnd The event to fire when the queued animation ends
     */
    queue(animation, loop = false, onEnd) {
        this.pendingAnimation = animation;
        this.pendingLoop = loop;
        if (onEnd !== undefined) {
            this.pendingOnEnd = onEnd;
        }
        else {
            this.pendingOnEnd = null;
        }
    }
    /** Pauses the current animation */
    pause() {
        this.animationState = AnimationTypes_1.AnimationState.PAUSED;
    }
    /** Resumes the current animation if possible */
    resume() {
        if (this.animationState === AnimationTypes_1.AnimationState.PAUSED) {
            this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /** Stops the current animation. The animation cannot be resumed after this. */
    stop() {
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
    }
}
exports.default = AnimationManager;
},{"../../DataTypes/Map":43,"../../Events/Emitter":59,"./AnimationTypes":99}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenData = exports.TweenEffect = exports.AnimationFrame = exports.AnimationData = exports.AnimationState = void 0;
// @ignorePage
var AnimationState;
(function (AnimationState) {
    AnimationState[AnimationState["STOPPED"] = 0] = "STOPPED";
    AnimationState[AnimationState["PAUSED"] = 1] = "PAUSED";
    AnimationState[AnimationState["PLAYING"] = 2] = "PLAYING";
})(AnimationState = exports.AnimationState || (exports.AnimationState = {}));
class AnimationData {
    constructor() {
        this.repeat = false;
    }
}
exports.AnimationData = AnimationData;
class AnimationFrame {
}
exports.AnimationFrame = AnimationFrame;
class TweenEffect {
}
exports.TweenEffect = TweenEffect;
class TweenData {
}
exports.TweenData = TweenData;
},{}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ParticleSystemManager {
    constructor() {
        this.particleSystems = new Array();
    }
    static getInstance() {
        if (ParticleSystemManager.instance === null) {
            ParticleSystemManager.instance = new ParticleSystemManager();
        }
        return ParticleSystemManager.instance;
    }
    registerParticleSystem(system) {
        this.particleSystems.push(system);
    }
    deregisterParticleSystem(system) {
        let index = this.particleSystems.indexOf(system);
        this.particleSystems.splice(index, 1);
    }
    clearParticleSystems() {
        this.particleSystems = new Array();
    }
    update(deltaT) {
        for (let particleSystem of this.particleSystems) {
            particleSystem.update(deltaT);
        }
    }
}
exports.default = ParticleSystemManager;
ParticleSystemManager.instance = null;
},{}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
const AnimationTypes_1 = require("./AnimationTypes");
const EaseFunctions_1 = require("../../Utils/EaseFunctions");
const MathUtils_1 = require("../../Utils/MathUtils");
const TweenManager_1 = require("./TweenManager");
const Emitter_1 = require("../../Events/Emitter");
/**
 * A manager for the tweens of a GameNode.
 * Tweens are short animations played by interpolating between two properties using an easing function.
 * For a good visual representation of easing functions, check out @link(https://easings.net/)(https://easings.net/).
 * Multiple tween can be played at the same time, as long as they don't change the same property.
 * This allows for some interesting polishes or animations that may be very difficult to do with sprite work alone
 * - especially pixel art (such as rotations or scaling).
 */
class TweenController {
    /**
     * Creates a new TweenController
     * @param owner The owner of the TweenController
     */
    constructor(owner) {
        this.owner = owner;
        this.tweens = new Map_1.default();
        this.emitter = new Emitter_1.default();
        // Give ourselves to the TweenManager
        TweenManager_1.default.getInstance().registerTweenController(this);
    }
    /**
     * Destroys this TweenController
     */
    destroy() {
        // Only the gamenode and the tween manager should have a reference to this
        delete this.owner.tweens;
        TweenManager_1.default.getInstance().deregisterTweenController(this);
    }
    /**
     * Add a tween to this game node
     * @param key The name of the tween
     * @param tween The data of the tween
     */
    add(key, tween) {
        let typedTween = tween;
        // Initialize members that we need (and the user didn't provide)
        typedTween.progress = 0;
        typedTween.elapsedTime = 0;
        typedTween.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.tweens.add(key, typedTween);
    }
    /**
     * Play a tween with a certain name
     * @param key The name of the tween to play
     * @param loop Whether or not the tween should loop
     */
    play(key, loop) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            // Set loop if needed
            if (loop !== undefined) {
                tween.loop = loop;
            }
            // Set the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    effect.initialValue = this.owner[effect.property];
                }
            }
            // Start the tween running
            tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
            tween.elapsedTime = 0;
            tween.progress = 0;
            tween.reversing = false;
        }
        else {
            console.warn(`Tried to play tween "${key}" on node with id ${this.owner.id}, but no such tween exists`);
        }
    }
    /**
     * Pauses a playing tween. Does not affect tweens that are stopped.
     * @param key The name of the tween to pause.
     */
    pause(key) {
        if (this.tweens.has(key)) {
            this.tweens.get(key).animationState = AnimationTypes_1.AnimationState.PAUSED;
        }
    }
    /**
     * Resumes a paused tween.
     * @param key The name of the tween to resume
     */
    resume(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PAUSED)
                tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /**
     * Stops a currently playing tween
     * @param key The key of the tween
     */
    stop(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            tween.animationState = AnimationTypes_1.AnimationState.STOPPED;
            // Return to the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    this.owner[effect.property] = effect.initialValue;
                }
            }
        }
    }
    /**
     * The natural stop of a currently playing tween
     * @param key The key of the tween
     */
    end(key) {
        this.stop(key);
        if (this.tweens.has(key)) {
            // Get the tween
            let tween = this.tweens.get(key);
            // If it has an onEnd, send an event
            if (tween.onEnd) {
                this.emitter.fireEvent(tween.onEnd, { key: key, node: this.owner.id });
            }
        }
    }
    /**
     * Stops all currently playing tweens
     */
    stopAll() {
        this.tweens.forEach(key => this.stop(key));
    }
    update(deltaT) {
        this.tweens.forEach(key => {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PLAYING) {
                // Update the progress of the tween
                tween.elapsedTime += deltaT * 1000;
                // If we're past the startDelay, do the tween
                if (tween.elapsedTime >= tween.startDelay) {
                    if (!tween.reversing &&
                        tween.elapsedTime >= tween.startDelay + tween.duration) {
                        // If we're over time, stop the tween, loop, or reverse
                        if (tween.reverseOnComplete) {
                            // If we're over time and can reverse, do so
                            tween.reversing = true;
                        }
                        else if (tween.loop) {
                            // If we can't reverse and can loop, do so
                            tween.elapsedTime -= tween.duration;
                        }
                        else {
                            // We aren't looping and can't reverse, so stop
                            this.end(key);
                        }
                    }
                    // Check for the end of reversing
                    if (tween.reversing &&
                        tween.elapsedTime >= tween.startDelay + 2 * tween.duration) {
                        if (tween.loop) {
                            tween.reversing = false;
                            tween.elapsedTime -= 2 * tween.duration;
                        }
                        else {
                            this.end(key);
                        }
                    }
                    // Update the progress, make sure it is between 0 and 1. Errors from this should never be large
                    if (tween.reversing) {
                        tween.progress = MathUtils_1.default.clamp01((2 * tween.duration - (tween.elapsedTime - tween.startDelay)) /
                            tween.duration);
                    }
                    else {
                        tween.progress = MathUtils_1.default.clamp01((tween.elapsedTime - tween.startDelay) / tween.duration);
                    }
                    for (let effect of tween.effects) {
                        // Get the value from the ease function that corresponds to our progress
                        let ease = EaseFunctions_1.default[effect.ease](tween.progress);
                        // Use the value to lerp the property
                        let value = MathUtils_1.default.lerp(effect.start, effect.end, ease);
                        // Assign the value of the property
                        this.owner[effect.property] = value;
                    }
                }
            }
        });
    }
}
exports.default = TweenController;
},{"../../DataTypes/Map":43,"../../Events/Emitter":59,"../../Utils/EaseFunctions":132,"../../Utils/MathUtils":134,"./AnimationTypes":99,"./TweenManager":102}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TweenManager {
    constructor() {
        this.tweenControllers = new Array();
    }
    static getInstance() {
        if (TweenManager.instance === null) {
            TweenManager.instance = new TweenManager();
        }
        return TweenManager.instance;
    }
    registerTweenController(controller) {
        this.tweenControllers.push(controller);
    }
    deregisterTweenController(controller) {
        let index = this.tweenControllers.indexOf(controller);
        this.tweenControllers.splice(index, 1);
    }
    clearTweenControllers() {
        this.tweenControllers = new Array();
    }
    update(deltaT) {
        for (let tweenController of this.tweenControllers) {
            tweenController.update(deltaT);
        }
    }
}
exports.default = TweenManager;
TweenManager.instance = null;
},{}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Nodes/Graphic");
const Point_1 = require("../Nodes/Graphics/Point");
const Rect_1 = require("../Nodes/Graphics/Rect");
const Sprite_1 = require("../Nodes/Sprites/Sprite");
const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
const UIElement_1 = require("../Nodes/UIElement");
const GraphicRenderer_1 = require("./CanvasRendering/GraphicRenderer");
const RenderingManager_1 = require("./RenderingManager");
const TilemapRenderer_1 = require("./CanvasRendering/TilemapRenderer");
const UIElementRenderer_1 = require("./CanvasRendering/UIElementRenderer");
const Label_1 = require("../Nodes/UIElements/Label");
const Button_1 = require("../Nodes/UIElements/Button");
const Slider_1 = require("../Nodes/UIElements/Slider");
const TextInput_1 = require("../Nodes/UIElements/TextInput");
const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
const Vec2_1 = require("../DataTypes/Vec2");
const Line_1 = require("../Nodes/Graphics/Line");
const Debug_1 = require("../Debug/Debug");
/**
 * An implementation of the RenderingManager class using CanvasRenderingContext2D.
 */
class CanvasRenderer extends RenderingManager_1.default {
    constructor() {
        super();
    }
    // @override
    setScene(scene) {
        this.scene = scene;
        this.graphicRenderer.setScene(scene);
        this.tilemapRenderer.setScene(scene);
        this.uiElementRenderer.setScene(scene);
    }
    // @override
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = new Vec2_1.default(width, height);
        this.ctx = canvas.getContext("2d");
        this.graphicRenderer = new GraphicRenderer_1.default(this.ctx);
        this.tilemapRenderer = new TilemapRenderer_1.default(this.ctx);
        this.uiElementRenderer = new UIElementRenderer_1.default(this.ctx);
        // For crisp pixel art
        this.ctx.imageSmoothingEnabled = false;
        return this.ctx;
    }
    // @override
    render(visibleSet, tilemaps, uiLayers) {
        // Sort by depth, then by visible set by y-value
        visibleSet.sort((a, b) => {
            if (a.getLayer().getDepth() === b.getLayer().getDepth()) {
                return a.boundary.bottom - b.boundary.bottom;
            }
            else {
                return a.getLayer().getDepth() - b.getLayer().getDepth();
            }
        });
        let tilemapIndex = 0;
        let tilemapLength = tilemaps.length;
        let visibleSetIndex = 0;
        let visibleSetLength = visibleSet.length;
        while (tilemapIndex < tilemapLength || visibleSetIndex < visibleSetLength) {
            // Check conditions where we've already reached the edge of one list
            if (tilemapIndex >= tilemapLength) {
                // Only render the remaining visible set
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
                continue;
            }
            if (visibleSetIndex >= visibleSetLength) {
                // Only render tilemaps
                this.renderTilemap(tilemaps[tilemapIndex++]);
                continue;
            }
            // Render whichever is further down
            if (tilemaps[tilemapIndex].getLayer().getDepth() <=
                visibleSet[visibleSetIndex].getLayer().getDepth()) {
                this.renderTilemap(tilemaps[tilemapIndex++]);
            }
            else {
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
            }
        }
        // Render the uiLayers on top of everything else
        let sortedUILayers = new Array();
        uiLayers.forEach(key => sortedUILayers.push(uiLayers.get(key)));
        sortedUILayers = sortedUILayers.sort((ui1, ui2) => ui1.getDepth() - ui2.getDepth());
        sortedUILayers.forEach(uiLayer => {
            if (!uiLayer.isHidden())
                uiLayer.getItems().forEach(node => {
                    if (node.visible) {
                        this.renderNode(node);
                    }
                });
        });
    }
    /**
     * Renders a specified CanvasNode
     * @param node The CanvasNode to render
     */
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        // Move the canvas to the position of the node and rotate
        let xScale = 1;
        let yScale = 1;
        if (node instanceof Sprite_1.default) {
            xScale = node.invertX ? -1 : 1;
            yScale = node.invertY ? -1 : 1;
        }
        this.ctx.setTransform(xScale, 0, 0, yScale, (node.position.x - this.origin.x) * this.zoom, (node.position.y - this.origin.y) * this.zoom);
        this.ctx.rotate(-node.rotation);
        let globalAlpha = this.ctx.globalAlpha;
        if (node instanceof Rect_1.default) {
            Debug_1.default.log("node" + node.id, "Node" + node.id + " Alpha: " + node.alpha);
        }
        this.ctx.globalAlpha = node.alpha;
        if (node instanceof AnimatedSprite_1.default) {
            this.renderAnimatedSprite(node);
        }
        else if (node instanceof Sprite_1.default) {
            this.renderSprite(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
        this.ctx.globalAlpha = globalAlpha;
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    // @override
    renderSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        /*
                Coordinates in the space of the image:
                    image crop start -> x, y
                    image crop size  -> w, h
                Coordinates in the space of the world
                    image draw start -> x, y
                    image draw size  -> w, h
            */
        this.ctx.drawImage(image, sprite.imageOffset.x, sprite.imageOffset.y, sprite.size.x, sprite.size.y, ((-sprite.size.x * sprite.scale.x) / 2) * this.zoom, ((-sprite.size.y * sprite.scale.y) / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderAnimatedSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
        let animationOffset = sprite.getAnimationOffset(animationIndex);
        /*
                Coordinates in the space of the image:
                    image crop start -> x, y
                    image crop size  -> w, h
                Coordinates in the space of the world (given we moved)
                    image draw start -> -w/2, -h/2
                    image draw size  -> w, h
            */
        this.ctx.drawImage(image, sprite.imageOffset.x + animationOffset.x, sprite.imageOffset.y + animationOffset.y, sprite.size.x, sprite.size.y, ((-sprite.size.x * sprite.scale.x) / 2) * this.zoom, ((-sprite.size.y * sprite.scale.y) / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            this.graphicRenderer.renderPoint(graphic, this.zoom);
        }
        else if (graphic instanceof Line_1.default) {
            this.graphicRenderer.renderLine(graphic, this.origin, this.zoom);
        }
        else if (graphic instanceof Rect_1.default) {
            this.graphicRenderer.renderRect(graphic, this.zoom);
        }
    }
    // @override
    renderTilemap(tilemap) {
        if (tilemap instanceof OrthogonalTilemap_1.default) {
            this.tilemapRenderer.renderOrthogonalTilemap(tilemap);
        }
    }
    // @override
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            this.uiElementRenderer.renderLabel(uiElement);
        }
        else if (uiElement instanceof Button_1.default) {
            this.uiElementRenderer.renderButton(uiElement);
        }
        else if (uiElement instanceof Slider_1.default) {
            this.uiElementRenderer.renderSlider(uiElement);
        }
        else if (uiElement instanceof TextInput_1.default) {
            this.uiElementRenderer.renderTextInput(uiElement);
        }
    }
    clear(clearColor) {
        this.ctx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
        this.ctx.fillStyle = clearColor.toString();
        this.ctx.fillRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
}
exports.default = CanvasRenderer;
},{"../DataTypes/Vec2":56,"../Debug/Debug":57,"../Nodes/Graphic":73,"../Nodes/Graphics/Line":75,"../Nodes/Graphics/Point":77,"../Nodes/Graphics/Rect":78,"../Nodes/Sprites/AnimatedSprite":79,"../Nodes/Sprites/Sprite":80,"../Nodes/Tilemaps/OrthogonalTilemap":82,"../Nodes/UIElement":83,"../Nodes/UIElements/Button":84,"../Nodes/UIElements/Label":85,"../Nodes/UIElements/Slider":86,"../Nodes/UIElements/TextInput":87,"./CanvasRendering/GraphicRenderer":104,"./CanvasRendering/TilemapRenderer":105,"./CanvasRendering/UIElementRenderer":106,"./RenderingManager":107}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[Graphic]s
 */
class GraphicRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this GraphicRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a point
     * @param point The point to render
     * @param zoom The zoom level
     */
    renderPoint(point, zoom) {
        this.ctx.fillStyle = point.color.toStringRGBA();
        this.ctx.fillRect((-point.size.x / 2) * zoom, (-point.size.y / 2) * zoom, point.size.x * zoom, point.size.y * zoom);
    }
    renderLine(line, origin, zoom) {
        this.ctx.strokeStyle = line.color.toStringRGBA();
        this.ctx.lineWidth = line.thickness;
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo((line.end.x - line.start.x) * zoom, (line.end.y - line.start.y) * zoom);
        this.ctx.closePath();
        this.ctx.stroke();
    }
    /**
     * Renders a rect
     * @param rect The rect to render
     * @param zoom The zoom level
     */
    renderRect(rect, zoom) {
        // Draw the interior of the rect
        if (rect.color.a !== 0) {
            this.ctx.fillStyle = rect.color.toStringRGB();
            this.ctx.fillRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
        // Draw the border of the rect if it isn't transparent
        if (rect.borderColor.a !== 0) {
            this.ctx.strokeStyle = rect.getBorderColor().toStringRGB();
            this.ctx.lineWidth = rect.getBorderWidth();
            this.ctx.strokeRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
    }
}
exports.default = GraphicRenderer;
},{"../../ResourceManager/ResourceManager":115}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/**
 * A utility class for the @reference[CanvasRenderer] to render @reference[Tilemap]s
 */
class TilemapRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this TilemapRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders an orthogonal tilemap
     * @param tilemap The tilemap to render
     */
    renderOrthogonalTilemap(tilemap) {
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = tilemap.getLayer().getAlpha();
        let origin = this.scene.getViewTranslation(tilemap);
        let size = this.scene.getViewport().getHalfSize();
        let zoom = this.scene.getViewScale();
        let bottomRight = origin.clone().add(size.scaled(2 * zoom));
        if (tilemap.visible) {
            let minColRow = tilemap.getColRowAt(origin);
            let maxColRow = tilemap.getColRowAt(bottomRight);
            for (let x = minColRow.x; x <= maxColRow.x; x++) {
                for (let y = minColRow.y; y <= maxColRow.y; y++) {
                    // Get the tile at this position
                    let tile = tilemap.getTileAtRowCol(new Vec2_1.default(x, y));
                    // Extract the rot/flip parameters if there are any
                    const mask = 0xe << 28;
                    const rotFlip = ((mask & tile) >> 28) & 0xf;
                    tile = tile & ~mask;
                    // Find the tileset that owns this tile index and render
                    for (let tileset of tilemap.getTilesets()) {
                        if (tileset.hasTile(tile)) {
                            this.renderTile(tileset, tile, x, y, origin, tilemap.scale, zoom, rotFlip);
                        }
                    }
                }
            }
        }
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a tile
     * @param tileset The tileset this tile belongs to
     * @param tileIndex The index of the tile
     * @param tilemapRow The row of the tile in the tilemap
     * @param tilemapCol The column of the tile in the tilemap
     * @param origin The origin of the viewport
     * @param scale The scale of the tilemap
     * @param zoom The zoom level of the viewport
     */
    renderTile(tileset, tileIndex, tilemapRow, tilemapCol, origin, scale, zoom, rotFlip) {
        let image = this.resourceManager.getImage(tileset.getImageKey());
        // Get the true index
        let index = tileIndex - tileset.getStartIndex();
        // Get the row and col of the tile in image space
        let row = Math.floor(index / tileset.getNumCols());
        let col = index % tileset.getNumCols();
        let width = tileset.getTileSize().x;
        let height = tileset.getTileSize().y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor(tilemapRow * width * scale.x);
        let y = Math.floor(tilemapCol * height * scale.y);
        let worldX = Math.floor((x - origin.x) * zoom);
        let worldY = Math.floor((y - origin.y) * zoom);
        let worldWidth = Math.ceil(width * scale.x * zoom);
        let worldHeight = Math.ceil(height * scale.y * zoom);
        if (rotFlip !== 0) {
            let scaleX = 1;
            let scaleY = 1;
            let shearX = 0;
            let shearY = 0;
            // Flip on the x-axis
            if (rotFlip & 8) {
                scaleX = -1;
            }
            // Flip on the y-axis
            if (rotFlip & 4) {
                scaleY = -1;
            }
            // Flip over the line y=x
            if (rotFlip & 2) {
                shearX = scaleY;
                shearY = scaleX;
                scaleX = 0;
                scaleY = 0;
            }
            this.ctx.setTransform(scaleX, shearX, shearY, scaleY, worldX + worldWidth / 2, worldY + worldHeight / 2);
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, -worldWidth / 2, -worldHeight / 2, worldWidth, worldHeight);
            if (rotFlip !== 0) {
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
        }
        else {
            // No rotations, don't do the calculations, just render the tile
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, worldX, worldY, worldWidth, worldHeight);
        }
    }
}
exports.default = TilemapRenderer;
},{"../../DataTypes/Vec2":56,"../../ResourceManager/ResourceManager":115}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const MathUtils_1 = require("../../Utils/MathUtils");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[UIElement]s
 */
class UIElementRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this UIElementRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a label
     * @param label The label to render
     */
    renderLabel(label) {
        // If the size is unassigned (by the user or automatically) assign it
        label.handleInitialSizing(this.ctx);
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        // Get the font and text position in label
        this.ctx.font = label.getFontString();
        let offset = label.calculateTextOffset(this.ctx);
        // Stroke and fill a rounded rect and give it text
        this.ctx.globalAlpha = label.backgroundColor.a;
        this.ctx.fillStyle = label.calculateBackgroundColor().toStringRGBA();
        this.ctx.fillRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.strokeStyle = label.calculateBorderColor().toStringRGBA();
        this.ctx.globalAlpha = label.borderColor.a;
        this.ctx.lineWidth = label.borderWidth;
        this.ctx.strokeRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.fillStyle = label.calculateTextColor();
        this.ctx.globalAlpha = label.textColor.a;
        this.ctx.fillText(label.text, offset.x - label.size.x / 2, offset.y - label.size.y / 2);
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a button
     * @param button The button to render
     */
    renderButton(button) {
        this.renderLabel(button);
    }
    /**
     * Renders a slider
     * @param slider The slider to render
     */
    renderSlider(slider) {
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = slider.getLayer().getAlpha();
        // Calcualate the slider size
        let sliderSize = new Vec2_1.default(slider.size.x, 2);
        // Draw the slider
        this.ctx.fillStyle = slider.sliderColor.toString();
        this.ctx.fillRoundedRect(-sliderSize.x / 2, -sliderSize.y / 2, sliderSize.x, sliderSize.y, slider.borderRadius);
        // Calculate the nib size and position
        let x = MathUtils_1.default.lerp(-slider.size.x / 2, slider.size.x / 2, slider.getValue());
        // Draw the nib
        this.ctx.fillStyle = slider.nibColor.toString();
        this.ctx.fillRoundedRect(x - slider.nibSize.x / 2, -slider.nibSize.y / 2, slider.nibSize.x, slider.nibSize.y, slider.borderRadius);
        // Reset the alpha
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a textInput
     * @param textInput The textInput to render
     */
    renderTextInput(textInput) {
        // Show a cursor sometimes
        if (textInput.focused && textInput.cursorCounter % 60 > 30) {
            textInput.text += "|";
        }
        this.renderLabel(textInput);
        if (textInput.focused) {
            if (textInput.cursorCounter % 60 > 30) {
                textInput.text = textInput.text.substring(0, textInput.text.length - 1);
            }
            textInput.cursorCounter += 1;
            if (textInput.cursorCounter >= 60) {
                textInput.cursorCounter = 0;
            }
        }
    }
}
exports.default = UIElementRenderer;
},{"../../DataTypes/Vec2":56,"../../ResourceManager/ResourceManager":115,"../../Utils/MathUtils":134}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * An abstract framework to put all rendering in once place in the application
 */
class RenderingManager {
    constructor() {
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Sets the scene currently being rendered
     * @param scene The current Scene
     */
    setScene(scene) {
        this.scene = scene;
    }
}
exports.default = RenderingManager;
},{"../ResourceManager/ResourceManager":115}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const Graphic_1 = require("../Nodes/Graphic");
const Point_1 = require("../Nodes/Graphics/Point");
const Rect_1 = require("../Nodes/Graphics/Rect");
const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
const Sprite_1 = require("../Nodes/Sprites/Sprite");
const UIElement_1 = require("../Nodes/UIElement");
const Label_1 = require("../Nodes/UIElements/Label");
const ShaderRegistry_1 = require("../Registry/Registries/ShaderRegistry");
const RegistryManager_1 = require("../Registry/RegistryManager");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
const RenderingManager_1 = require("./RenderingManager");
class WebGLRenderer extends RenderingManager_1.default {
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = Vec2_1.default.ZERO;
        this.worldSize.x = width;
        this.worldSize.y = height;
        // Get the WebGL context
        this.gl = canvas.getContext("webgl");
        this.gl.viewport(0, 0, canvas.width, canvas.height);
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.enable(this.gl.CULL_FACE);
        // Tell the resource manager we're using WebGL
        ResourceManager_1.default.getInstance().useWebGL(true, this.gl);
        // Show the text canvas and get its context
        let textCanvas = document.getElementById("text-canvas");
        textCanvas.hidden = false;
        this.textCtx = textCanvas.getContext("2d");
        // Size the text canvas to be the same as the game canvas
        textCanvas.height = height;
        textCanvas.width = width;
        return this.gl;
    }
    render(visibleSet, tilemaps, uiLayers) {
        for (let node of visibleSet) {
            this.renderNode(node);
        }
        uiLayers.forEach(key => {
            if (!uiLayers.get(key).isHidden())
                uiLayers
                    .get(key)
                    .getItems()
                    .forEach(node => this.renderNode(node));
        });
    }
    clear(color) {
        this.gl.clearColor(color.r, color.g, color.b, color.a);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.textCtx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        if (node.hasCustomShader) {
            // If the node has a custom shader, render using that
            this.renderCustom(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof Sprite_1.default) {
            if (node instanceof AnimatedSprite_1.default) {
                this.renderAnimatedSprite(node);
            }
            else {
                this.renderSprite(node);
            }
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
    }
    renderSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderAnimatedSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.POINT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
        else if (graphic instanceof Rect_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.RECT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
    }
    renderTilemap(tilemap) {
        throw new Error("Method not implemented.");
    }
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.LABEL_SHADER);
            let options = this.addOptions(shader.getOptions(uiElement), uiElement);
            shader.render(this.gl, options);
            this.textCtx.setTransform(1, 0, 0, 1, (uiElement.position.x - this.origin.x) * this.zoom, (uiElement.position.y - this.origin.y) * this.zoom);
            this.textCtx.rotate(-uiElement.rotation);
            let globalAlpha = this.textCtx.globalAlpha;
            this.textCtx.globalAlpha = uiElement.alpha;
            // Render text
            this.textCtx.font = uiElement.getFontString();
            let offset = uiElement.calculateTextOffset(this.textCtx);
            this.textCtx.fillStyle = uiElement.calculateTextColor();
            this.textCtx.globalAlpha = uiElement.textColor.a;
            this.textCtx.fillText(uiElement.text, offset.x - uiElement.size.x / 2, offset.y - uiElement.size.y / 2);
            this.textCtx.globalAlpha = globalAlpha;
            this.textCtx.setTransform(1, 0, 0, 1, 0, 0);
        }
    }
    renderCustom(node) {
        let shader = RegistryManager_1.default.shaders.get(node.customShaderKey);
        let options = this.addOptions(shader.getOptions(node), node);
        shader.render(this.gl, options);
    }
    addOptions(options, node) {
        // Give the shader access to the world size
        options.worldSize = this.worldSize;
        // Adjust the origin position to the parallax
        let layer = node.getLayer();
        let parallax = new Vec2_1.default(1, 1);
        if (layer instanceof ParallaxLayer_1.default) {
            parallax = layer.parallax;
        }
        options.origin = this.origin.clone().mult(parallax);
        return options;
    }
}
exports.default = WebGLRenderer;
},{"../DataTypes/Vec2":56,"../Nodes/Graphic":73,"../Nodes/Graphics/Point":77,"../Nodes/Graphics/Rect":78,"../Nodes/Sprites/AnimatedSprite":79,"../Nodes/Sprites/Sprite":80,"../Nodes/UIElement":83,"../Nodes/UIElements/Label":85,"../Registry/Registries/ShaderRegistry":96,"../Registry/RegistryManager":97,"../ResourceManager/ResourceManager":115,"../Scene/Layers/ParallaxLayer":123,"./RenderingManager":107}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A wrapper class for WebGL shaders.
 * This class is a singleton, and there is only one for each shader type.
 * All objects that use this shader type will refer to and modify this same type.
 */
class ShaderType {
    constructor(programKey) {
        this.programKey = programKey;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Extracts the options from the CanvasNode and gives them to the render function
     * @param node The node to get options from
     * @returns An object containing the options that should be passed to the render function
     */
    getOptions(node) {
        return {};
    }
}
exports.default = ShaderType;
},{"../../ResourceManager/ResourceManager":115}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
/** */
class LabelShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "label";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const backgroundColor = options.backgroundColor.toWebGL();
        const borderColor = options.borderColor.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_BackgroundColor = gl.getUniformLocation(program, "u_BackgroundColor");
        gl.uniform4fv(u_BackgroundColor, backgroundColor);
        const u_BorderColor = gl.getUniformLocation(program, "u_BorderColor");
        gl.uniform4fv(u_BorderColor, borderColor);
        const u_MaxSize = gl.getUniformLocation(program, "u_MaxSize");
        gl.uniform2f(u_MaxSize, -vertexData[0], vertexData[1]);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        const u_BorderWidth = gl.getUniformLocation(program, "u_BorderWidth");
        gl.uniform1f(u_BorderWidth, options.borderWidth / maxDimension);
        const u_BorderRadius = gl.getUniformLocation(program, "u_BorderRadius");
        gl.uniform1f(u_BorderRadius, options.borderRadius / maxDimension);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) /
            maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) /
            maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([-x, y, -x, -y, x, y, x, -y]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            backgroundColor: rect.calculateBackgroundColor(),
            borderColor: rect.calculateBorderColor(),
            borderWidth: rect.borderWidth,
            borderRadius: rect.borderRadius,
            size: rect.size,
            rotation: rect.rotation,
        };
        return options;
    }
}
exports.default = LabelShaderType;
},{"../../../DataTypes/Mat4x4":44,"../../../DataTypes/Vec2":56,"../../../ResourceManager/ResourceManager":115,"./QuadShaderType":112}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RenderingUtils_1 = require("../../../Utils/RenderingUtils");
const ShaderType_1 = require("../ShaderType");
class PointShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
    }
    initBufferObject() {
        this.bufferObjectKey = "point";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        let position = RenderingUtils_1.default.toWebGLCoords(options.position, options.origin, options.worldSize);
        let color = RenderingUtils_1.default.toWebGLColor(options.color);
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = position;
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        const u_PointSize = gl.getUniformLocation(program, "u_PointSize");
        gl.uniform1f(u_PointSize, options.pointSize);
        gl.drawArrays(gl.POINTS, 0, 1);
    }
    getOptions(point) {
        let options = {
            position: point.position,
            color: point.color,
            pointSize: point.size,
        };
        return options;
    }
}
exports.default = PointShaderType;
},{"../../../Utils/RenderingUtils":135,"../ShaderType":109}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const ShaderType_1 = require("../ShaderType");
/** Represents any WebGL objects that have a quad mesh (i.e. a rectangular game object composed of only two triangles) */
class QuadShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.scale = Mat4x4_1.default.IDENTITY;
        this.rotation = Mat4x4_1.default.IDENTITY;
        this.translation = Mat4x4_1.default.IDENTITY;
    }
}
exports.default = QuadShaderType;
},{"../../../DataTypes/Mat4x4":44,"../ShaderType":109}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
/** */
class RectShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "rect";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const color = options.color.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) /
            maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) /
            maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /*
          So as it turns out, WebGL has an issue with non-square quads.
          It doesn't like when you don't have a 1-1 scale, and rotations are entirely messed up if this is not the case.
          To solve this, I used the scale of the LARGEST dimension of the quad to make a square, then adjusted the vertex coordinates inside of that.
          A diagram of the solution follows.
  
          There is a bounding square for the quad with dimensions hxh (in this case, since height is the largest dimension).
          The offset in the vertical direction is therefore 0.5, as it is normally.
          However, the offset in the horizontal direction is not so straightforward, but isn't conceptually hard.
          All we really have to do is a range change from [0, height/2] to [0, 0.5], where our value is t = width/2, and 0 <= t <= height/2.
  
          So now we have our rect, in a space scaled with respect to the largest dimension.
          Rotations work as you would expect, even for long rectangles.
  
                      0.5
              __ __ __ __ __ __ __
              |	|88888888888|	|
              |	|88888888888|	|
              |	|88888888888|	|
          -0.5|_ _|88888888888|_ _|0.5
              |	|88888888888|	|
              |	|88888888888|	|
              |	|88888888888|	|
              |___|88888888888|___|
                      -0.5
  
          The getVertices function below does as described, and converts the range
      */
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([-x, y, -x, -y, x, y, x, -y]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            color: rect.color,
            size: rect.size,
            rotation: rect.rotation,
        };
        return options;
    }
}
exports.default = RectShaderType;
},{"../../../DataTypes/Mat4x4":44,"../../../DataTypes/Vec2":56,"../../../ResourceManager/ResourceManager":115,"./QuadShaderType":112}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const AnimatedSprite_1 = require("../../../Nodes/Sprites/AnimatedSprite");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
/** A shader for sprites and animated sprites */
class SpriteShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "sprite";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        const texture = this.resourceManager.getTexture(options.imageKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y, options.scale);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 4 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        const a_TexCoord = gl.getAttribLocation(program, "a_TexCoord");
        gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 4 * FSIZE, 2 * FSIZE);
        gl.enableVertexAttribArray(a_TexCoord);
        // Uniforms
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) /
            maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) /
            maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Set up our sampler with our assigned texture unit
        const u_Sampler = gl.getUniformLocation(program, "u_Sampler");
        gl.uniform1i(u_Sampler, texture);
        // Pass in texShift
        const u_texShift = gl.getUniformLocation(program, "u_texShift");
        gl.uniform2fv(u_texShift, options.texShift);
        // Pass in texScale
        const u_texScale = gl.getUniformLocation(program, "u_texScale");
        gl.uniform2fv(u_texScale, options.texScale);
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h, scale) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        // Scale the rendering space if needed
        x *= scale[0];
        y *= scale[1];
        return new Float32Array([
            -x,
            y,
            0.0,
            0.0,
            -x,
            -y,
            0.0,
            1.0,
            x,
            y,
            1.0,
            0.0,
            x,
            -y,
            1.0,
            1.0,
        ]);
    }
    getOptions(sprite) {
        let texShift;
        let texScale;
        if (sprite instanceof AnimatedSprite_1.default) {
            let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
            let offset = sprite.getAnimationOffset(animationIndex);
            texShift = new Float32Array([
                offset.x / (sprite.cols * sprite.size.x),
                offset.y / (sprite.rows * sprite.size.y),
            ]);
            texScale = new Float32Array([1 / sprite.cols, 1 / sprite.rows]);
        }
        else {
            texShift = new Float32Array([0, 0]);
            texScale = new Float32Array([1, 1]);
        }
        let options = {
            position: sprite.position,
            rotation: sprite.rotation,
            size: sprite.size,
            scale: sprite.scale.toArray(),
            imageKey: sprite.imageId,
            texShift,
            texScale,
        };
        return options;
    }
}
exports.default = SpriteShaderType;
},{"../../../DataTypes/Mat4x4":44,"../../../DataTypes/Vec2":56,"../../../Nodes/Sprites/AnimatedSprite":79,"../../../ResourceManager/ResourceManager":115,"./QuadShaderType":112}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const Queue_1 = require("../DataTypes/Queue");
const StringUtils_1 = require("../Utils/StringUtils");
const AudioManager_1 = require("../Sound/AudioManager");
const WebGLProgramType_1 = require("../DataTypes/Rendering/WebGLProgramType");
/**
 * The resource manager for the game engine.
 * The resource manager interfaces with the loadable assets of a game such as images, data files,
 * and sounds, which are all found in the dist folder.
 * This class controls loading and updates the @reference[Scene] with the loading progress, so that the scene does
 * not start before all necessary assets are loaded.
 */
class ResourceManager {
    constructor() {
        this.loading = false;
        this.justLoaded = false;
        this.loadonly_imagesLoaded = 0;
        this.loadonly_imagesToLoad = 0;
        this.loadonly_imageLoadingQueue = new Queue_1.default();
        this.images = new Map_1.default();
        this.loadonly_spritesheetsLoaded = 0;
        this.loadonly_spritesheetsToLoad = 0;
        this.loadonly_spritesheetLoadingQueue = new Queue_1.default();
        this.spritesheets = new Map_1.default();
        this.loadonly_tilemapsLoaded = 0;
        this.loadonly_tilemapsToLoad = 0;
        this.loadonly_tilemapLoadingQueue = new Queue_1.default();
        this.tilemaps = new Map_1.default();
        this.loadonly_audioLoaded = 0;
        this.loadonly_audioToLoad = 0;
        this.loadonly_audioLoadingQueue = new Queue_1.default();
        this.audioBuffers = new Map_1.default();
        this.loadonly_jsonLoaded = 0;
        this.loadonly_jsonToLoad = 0;
        this.loadonly_jsonLoadingQueue = new Queue_1.default();
        this.jsonObjects = new Map_1.default();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        this.loadonly_gl_ShaderProgramsToLoad = 0;
        this.loadonly_gl_ShaderLoadingQueue = new Queue_1.default();
        this.gl_ShaderPrograms = new Map_1.default();
        this.gl_Textures = new Map_1.default();
        this.gl_NextTextureID = 0;
        this.gl_Buffers = new Map_1.default();
        this.resourcesToUnload = new Array();
        this.resourcesToKeep = new Array();
    }
    /* ######################################## SINGLETON ########################################*/
    /**
     * Returns the current instance of this class or a new instance if none exist
     * @returns The resource manager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new ResourceManager();
        }
        return this.instance;
    }
    /* ######################################## PUBLIC FUNCTION ########################################*/
    /**
     * Activates or deactivates the use of WebGL
     * @param flag True if WebGL should be used, false otherwise
     * @param gl The instance of the graphics context, if applicable
     */
    useWebGL(flag, gl) {
        this.gl_WebGLActive = flag;
        if (this.gl_WebGLActive) {
            this.gl = gl;
        }
    }
    /**
     * Loads an image from file
     * @param key The key to associate the loaded image with
     * @param path The path to the image to load
     */
    image(key, path) {
        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepImage(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    /**
     * Retrieves a loaded image
     * @param key The key of the loaded image
     * @returns The image element associated with this key
     */
    getImage(key) {
        let image = this.images.get(key);
        if (image === undefined) {
            throw `There is no image associated with key "${key}"`;
        }
        return image;
    }
    /**
     * Loads a spritesheet from file
     * @param key The key to associate the loaded spritesheet with
     * @param path The path to the spritesheet to load
     */
    spritesheet(key, path) {
        this.loadonly_spritesheetLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepSpritesheet(key) {
        this.keepResource(key, ResourceType.SPRITESHEET);
    }
    /**
     * Retrieves a loaded spritesheet
     * @param key The key of the spritesheet to load
     * @returns The loaded Spritesheet
     */
    getSpritesheet(key) {
        return this.spritesheets.get(key);
    }
    /**
     * Loads an audio file
     * @param key The key to associate with the loaded audio file
     * @param path The path to the audio file to load
     */
    audio(key, path) {
        this.loadonly_audioLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepAudio(key) {
        this.keepResource(key, ResourceType.AUDIO);
    }
    /**
     * Retrieves a loaded audio file
     * @param key The key of the audio file to load
     * @returns The AudioBuffer created from the loaded audio fle
     */
    getAudio(key) {
        return this.audioBuffers.get(key);
    }
    /**
     * Load a tilemap from a json file. Automatically loads related images
     * @param key The key to associate with the loaded tilemap
     * @param {string} path The path to the tilemap to load
     */
    tilemap(key, path) {
        this.loadonly_tilemapLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepTilemap(key) {
        this.keepResource(key, ResourceType.TILEMAP);
    }
    /**
     * Retreives a loaded tilemap
     * @param key The key of the loaded tilemap
     * @returns The tilemap data associated with the key
     */
    getTilemap(key) {
        return this.tilemaps.get(key);
    }
    /**
     * Loads an object from a json file.
     * @param key The key to associate with the loaded object
     * @param path The path to the json file to load
     */
    object(key, path) {
        this.loadonly_jsonLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepObject(key) {
        this.keepResource(key, ResourceType.JSON);
    }
    /**
     * Retreives a loaded object
     * @param key The key of the loaded object
     * @returns The object data associated with the key
     */
    getObject(key) {
        return this.jsonObjects.get(key);
    }
    /* ######################################## LOAD FUNCTION ########################################*/
    /**
     * Loads all resources currently in the queue
     * @param callback The function to cal when the resources are finished loading
     */
    loadResourcesFromQueue(callback) {
        this.loadonly_typesToLoad = 5;
        this.loading = true;
        // Load everything in the queues. Tilemaps have to come before images because they will add new images to the queue
        this.loadTilemapsFromQueue(() => {
            console.log("Loaded Tilemaps");
            this.loadSpritesheetsFromQueue(() => {
                console.log("Loaded Spritesheets");
                this.loadImagesFromQueue(() => {
                    console.log("Loaded Images");
                    this.loadAudioFromQueue(() => {
                        console.log("Loaded Audio");
                        this.loadObjectsFromQueue(() => {
                            console.log("Loaded Objects");
                            if (this.gl_WebGLActive) {
                                this.gl_LoadShadersFromQueue(() => {
                                    console.log("Loaded Shaders");
                                    this.finishLoading(callback);
                                });
                            }
                            else {
                                this.finishLoading(callback);
                            }
                        });
                    });
                });
            });
        });
    }
    finishLoading(callback) {
        // Done loading
        this.loading = false;
        this.justLoaded = true;
        callback();
    }
    /* ######################################## UNLOAD FUNCTION ########################################*/
    keepResource(key, type) {
        console.log("Keep resource...");
        for (let i = 0; i < this.resourcesToUnload.length; i++) {
            let resource = this.resourcesToUnload[i];
            if (resource.key === key && resource.resourceType === type) {
                console.log("Found resource " + key + " of type " + type + ". Keeping.");
                let resourceToMove = this.resourcesToUnload.splice(i, 1);
                this.resourcesToKeep.push(...resourceToMove);
                return;
            }
        }
    }
    /**
     * Deletes references to all resources in the resource manager
     */
    unloadAllResources() {
        this.loading = false;
        this.justLoaded = false;
        for (let resource of this.resourcesToUnload) {
            // Unload the resource
            this.unloadResource(resource);
        }
    }
    unloadResource(resource) {
        // Delete the resource itself
        switch (resource.resourceType) {
            case ResourceType.IMAGE:
                this.images.delete(resource.key);
                if (this.gl_WebGLActive) {
                    this.gl_Textures.delete(resource.key);
                }
                break;
            case ResourceType.TILEMAP:
                this.tilemaps.delete(resource.key);
                break;
            case ResourceType.SPRITESHEET:
                this.spritesheets.delete(resource.key);
                break;
            case ResourceType.AUDIO:
                this.audioBuffers.delete(resource.key);
                break;
            case ResourceType.JSON:
                this.jsonObjects.delete(resource.key);
                break;
            /*case ResourceType.SHADER:
                      this.gl_ShaderPrograms.get(resource.key).delete(this.gl);
                      this.gl_ShaderPrograms.delete(resource.key);
                      break;*/
        }
        // Delete any dependencies
        for (let dependency of resource.dependencies) {
            this.unloadResource(dependency);
        }
    }
    /* ######################################## WORK FUNCTIONS ########################################*/
    /**
     * Loads all tilemaps currently in the tilemap loading queue
     * @param onFinishLoading The function to call when loading is complete
     */
    loadTilemapsFromQueue(onFinishLoading) {
        this.loadonly_tilemapsToLoad = this.loadonly_tilemapLoadingQueue.getSize();
        this.loadonly_tilemapsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_tilemapsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_tilemapLoadingQueue.hasItems()) {
            let tilemap = this.loadonly_tilemapLoadingQueue.dequeue();
            this.loadTilemap(tilemap.key, tilemap.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular tilemap
     * @param key The key of the tilemap
     * @param pathToTilemapJSON The path to the tilemap JSON file
     * @param callbackIfLast The function to call if this is the last tilemap to load
     */
    loadTilemap(key, pathToTilemapJSON, callbackIfLast) {
        this.loadTextFile(pathToTilemapJSON, (fileText) => {
            let tilemapObject = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.tilemaps.add(key, tilemapObject);
            let resource = new ResourceReference(key, ResourceType.TILEMAP);
            // Grab the tileset images we need to load and add them to the imageloading queue
            for (let tileset of tilemapObject.tilesets) {
                if (tileset.image) {
                    let key = tileset.image;
                    let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                    this.loadonly_imageLoadingQueue.enqueue({
                        key: key,
                        path: path,
                        isDependency: true,
                    });
                    // Add this image as a dependency to the tilemap
                    resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                }
                else if (tileset.tiles) {
                    for (let tile of tileset.tiles) {
                        let key = tile.image;
                        let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                        this.loadonly_imageLoadingQueue.enqueue({
                            key: key,
                            path: path,
                            isDependency: true,
                        });
                        // Add this image as a dependency to the tilemap
                        resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                    }
                }
            }
            // Add the resource reference to the list of resource to unload
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingTilemap(callbackIfLast);
        });
    }
    /**
     * Finish loading a tilemap. Calls the callback function if this is the last tilemap being loaded
     * @param callback The function to call if this is the last tilemap to load
     */
    finishLoadingTilemap(callback) {
        this.loadonly_tilemapsLoaded += 1;
        if (this.loadonly_tilemapsLoaded === this.loadonly_tilemapsToLoad) {
            // We're done loading tilemaps
            callback();
        }
    }
    /**
     * Loads all spritesheets currently in the spritesheet loading queue
     * @param onFinishLoading The function to call when the spritesheets are done loading
     */
    loadSpritesheetsFromQueue(onFinishLoading) {
        this.loadonly_spritesheetsToLoad =
            this.loadonly_spritesheetLoadingQueue.getSize();
        this.loadonly_spritesheetsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_spritesheetsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_spritesheetLoadingQueue.hasItems()) {
            let spritesheet = this.loadonly_spritesheetLoadingQueue.dequeue();
            this.loadSpritesheet(spritesheet.key, spritesheet.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular spritesheet
     * @param key The key of the spritesheet to load
     * @param pathToSpritesheetJSON The path to the spritesheet JSON file
     * @param callbackIfLast The function to call if this is the last spritesheet
     */
    loadSpritesheet(key, pathToSpritesheetJSON, callbackIfLast) {
        this.loadTextFile(pathToSpritesheetJSON, (fileText) => {
            let spritesheet = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.spritesheets.add(key, spritesheet);
            let resource = new ResourceReference(key, ResourceType.SPRITESHEET);
            // Grab the image we need to load and add it to the imageloading queue
            let path = StringUtils_1.default.getPathFromFilePath(pathToSpritesheetJSON) +
                spritesheet.spriteSheetImage;
            this.loadonly_imageLoadingQueue.enqueue({
                key: spritesheet.name,
                path: path,
                isDependency: true,
            });
            resource.addDependency(new ResourceReference(spritesheet.name, ResourceType.IMAGE));
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingSpritesheet(callbackIfLast);
        });
    }
    /**
     * Finish loading a spritesheet. Calls the callback function if this is the last spritesheet being loaded
     * @param callback The function to call if this is the last spritesheet to load
     */
    finishLoadingSpritesheet(callback) {
        this.loadonly_spritesheetsLoaded += 1;
        if (this.loadonly_spritesheetsLoaded === this.loadonly_spritesheetsToLoad) {
            // We're done loading spritesheets
            callback();
        }
    }
    /**
     * Loads all images currently in the image loading queue
     * @param onFinishLoading The function to call when there are no more images to load
     */
    loadImagesFromQueue(onFinishLoading) {
        this.loadonly_imagesToLoad = this.loadonly_imageLoadingQueue.getSize();
        this.loadonly_imagesLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_imagesToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_imageLoadingQueue.hasItems()) {
            let image = this.loadonly_imageLoadingQueue.dequeue();
            this.loadImage(image.key, image.path, image.isDependency, onFinishLoading);
        }
    }
    /**
     * Loads a singular image
     * @param key The key of the image to load
     * @param path The path to the image to load
     * @param callbackIfLast The function to call if this is the last image
     */
    loadImage(key, path, isDependency, callbackIfLast) {
        var image = new Image();
        image.onload = () => {
            // Add to loaded images
            this.images.add(key, image);
            // If not a dependency, push it to the unload list. Otherwise it's managed by something else
            if (!isDependency) {
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.IMAGE));
            }
            // If WebGL is active, create a texture
            if (this.gl_WebGLActive) {
                this.createWebGLTexture(key, image);
            }
            // Finish image load
            this.finishLoadingImage(callbackIfLast);
        };
        image.src = path;
    }
    /**
     * Finish loading an image. If this is the last image, it calls the callback function
     * @param callback The function to call if this is the last image
     */
    finishLoadingImage(callback) {
        this.loadonly_imagesLoaded += 1;
        if (this.loadonly_imagesLoaded === this.loadonly_imagesToLoad) {
            // We're done loading images
            callback();
        }
    }
    /**
     * Loads all audio currently in the tilemap loading queue
     * @param onFinishLoading The function to call when tilemaps are done loading
     */
    loadAudioFromQueue(onFinishLoading) {
        this.loadonly_audioToLoad = this.loadonly_audioLoadingQueue.getSize();
        this.loadonly_audioLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_audioToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_audioLoadingQueue.hasItems()) {
            let audio = this.loadonly_audioLoadingQueue.dequeue();
            this.loadAudio(audio.key, audio.path, onFinishLoading);
        }
    }
    /**
     * Load a singular audio file
     * @param key The key to the audio file to load
     * @param path The path to the audio file to load
     * @param callbackIfLast The function to call if this is the last audio file to load
     */
    loadAudio(key, path, callbackIfLast) {
        let audioCtx = AudioManager_1.default.getInstance().getAudioContext();
        let request = new XMLHttpRequest();
        request.open("GET", path, true);
        request.responseType = "arraybuffer";
        request.onload = () => {
            audioCtx.decodeAudioData(request.response, buffer => {
                // Add to list of audio buffers
                this.audioBuffers.add(key, buffer);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.AUDIO));
                // Finish loading sound
                this.finishLoadingAudio(callbackIfLast);
            }, error => {
                throw "Error loading sound";
            });
        };
        request.send();
    }
    /**
     * Finish loading an audio file. Calls the callback functon if this is the last audio sample being loaded.
     * @param callback The function to call if this is the last audio file to load
     */
    finishLoadingAudio(callback) {
        this.loadonly_audioLoaded += 1;
        if (this.loadonly_audioLoaded === this.loadonly_audioToLoad) {
            // We're done loading audio
            callback();
        }
    }
    /**
     * Loads all objects currently in the object loading queue
     * @param onFinishLoading The function to call when there are no more objects to load
     */
    loadObjectsFromQueue(onFinishLoading) {
        this.loadonly_jsonToLoad = this.loadonly_jsonLoadingQueue.getSize();
        this.loadonly_jsonLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_jsonToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_jsonLoadingQueue.hasItems()) {
            let obj = this.loadonly_jsonLoadingQueue.dequeue();
            this.loadObject(obj.key, obj.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular object
     * @param key The key of the object to load
     * @param path The path to the object to load
     * @param callbackIfLast The function to call if this is the last object
     */
    loadObject(key, path, callbackIfLast) {
        this.loadTextFile(path, (fileText) => {
            let obj = JSON.parse(fileText);
            this.jsonObjects.add(key, obj);
            this.resourcesToUnload.push(new ResourceReference(key, ResourceType.JSON));
            this.finishLoadingObject(callbackIfLast);
        });
    }
    /**
     * Finish loading an object. If this is the last object, it calls the callback function
     * @param callback The function to call if this is the last object
     */
    finishLoadingObject(callback) {
        this.loadonly_jsonLoaded += 1;
        if (this.loadonly_jsonLoaded === this.loadonly_jsonToLoad) {
            // We're done loading objects
            callback();
        }
    }
    /* ########## WEBGL SPECIFIC FUNCTIONS ########## */
    getTexture(key) {
        return this.gl_Textures.get(key);
    }
    getShaderProgram(key) {
        return this.gl_ShaderPrograms.get(key).program;
    }
    getBuffer(key) {
        return this.gl_Buffers.get(key);
    }
    createWebGLTexture(imageKey, image) {
        // Get the texture ID
        const textureID = this.getTextureID(this.gl_NextTextureID);
        // Create the texture
        const texture = this.gl.createTexture();
        // Set up the texture
        // Enable texture0
        this.gl.activeTexture(textureID);
        // Bind our texture to texture 0
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        // Set the texture parameters
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        // Set the texture image
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
        // Add the texture to our map with the same key as the image
        this.gl_Textures.add(imageKey, this.gl_NextTextureID);
        // Increment the key
        this.gl_NextTextureID += 1;
    }
    getTextureID(id) {
        // Start with 9 cases - this can be expanded if needed, but for the best performance,
        // Textures should be stitched into an atlas
        switch (id) {
            case 0:
                return this.gl.TEXTURE0;
            case 1:
                return this.gl.TEXTURE1;
            case 2:
                return this.gl.TEXTURE2;
            case 3:
                return this.gl.TEXTURE3;
            case 4:
                return this.gl.TEXTURE4;
            case 5:
                return this.gl.TEXTURE5;
            case 6:
                return this.gl.TEXTURE6;
            case 7:
                return this.gl.TEXTURE7;
            case 8:
                return this.gl.TEXTURE8;
            default:
                return this.gl.TEXTURE9;
        }
    }
    createBuffer(key) {
        if (this.gl_WebGLActive) {
            let buffer = this.gl.createBuffer();
            this.gl_Buffers.add(key, buffer);
        }
    }
    /**
     * Enqueues loading of a new shader program
     * @param key The key of the shader program
     * @param vShaderFilepath
     * @param fShaderFilepath
     */
    shader(key, vShaderFilepath, fShaderFilepath) {
        let splitPath = vShaderFilepath.split(".");
        let end = splitPath[splitPath.length - 1];
        if (end !== "vshader") {
            throw `${vShaderFilepath} is not a valid vertex shader - must end in ".vshader`;
        }
        splitPath = fShaderFilepath.split(".");
        end = splitPath[splitPath.length - 1];
        if (end !== "fshader") {
            throw `${fShaderFilepath} is not a valid vertex shader - must end in ".fshader`;
        }
        let paths = new KeyPath_Shader();
        paths.key = key;
        paths.vpath = vShaderFilepath;
        paths.fpath = fShaderFilepath;
        this.loadonly_gl_ShaderLoadingQueue.enqueue(paths);
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepShader(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    gl_LoadShadersFromQueue(onFinishLoading) {
        this.loadonly_gl_ShaderProgramsToLoad =
            this.loadonly_gl_ShaderLoadingQueue.getSize();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        // If webGL isn'active or there are no items to load, we're finished
        if (!this.gl_WebGLActive || this.loadonly_gl_ShaderProgramsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_gl_ShaderLoadingQueue.hasItems()) {
            let shader = this.loadonly_gl_ShaderLoadingQueue.dequeue();
            this.gl_LoadShader(shader.key, shader.vpath, shader.fpath, onFinishLoading);
        }
    }
    gl_LoadShader(key, vpath, fpath, callbackIfLast) {
        this.loadTextFile(vpath, (vFileText) => {
            const vShader = vFileText;
            this.loadTextFile(fpath, (fFileText) => {
                const fShader = fFileText;
                // Extract the program and shaders
                const [shaderProgram, vertexShader, fragmentShader] = this.createShaderProgram(vShader, fShader);
                // Create a wrapper type
                const programWrapper = new WebGLProgramType_1.default();
                programWrapper.program = shaderProgram;
                programWrapper.vertexShader = vertexShader;
                programWrapper.fragmentShader = fragmentShader;
                // Add to our map
                this.gl_ShaderPrograms.add(key, programWrapper);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.SHADER));
                // Finish loading
                this.gl_FinishLoadingShader(callbackIfLast);
            });
        });
    }
    gl_FinishLoadingShader(callback) {
        this.loadonly_gl_ShaderProgramsLoaded += 1;
        if (this.loadonly_gl_ShaderProgramsLoaded ===
            this.loadonly_gl_ShaderProgramsToLoad) {
            // We're done loading shaders
            callback();
        }
    }
    createShaderProgram(vShaderSource, fShaderSource) {
        const vertexShader = this.loadVertexShader(vShaderSource);
        const fragmentShader = this.loadFragmentShader(fShaderSource);
        if (vertexShader === null || fragmentShader === null) {
            // We had a problem intializing - error
            return null;
        }
        // Create a shader program
        const program = this.gl.createProgram();
        if (!program) {
            // Error creating
            console.warn("Failed to create program");
            return null;
        }
        // Attach our vertex and fragment shader
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        // Link
        this.gl.linkProgram(program);
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            // Error linking
            const error = this.gl.getProgramInfoLog(program);
            console.warn("Failed to link program: " + error);
            // Clean up
            this.gl.deleteProgram(program);
            this.gl.deleteShader(vertexShader);
            this.gl.deleteShader(fragmentShader);
            return null;
        }
        // We successfully create a program
        return [program, vertexShader, fragmentShader];
    }
    loadVertexShader(shaderSource) {
        // Create a new vertex shader
        return this.loadShader(this.gl.VERTEX_SHADER, shaderSource);
    }
    loadFragmentShader(shaderSource) {
        // Create a new fragment shader
        return this.loadShader(this.gl.FRAGMENT_SHADER, shaderSource);
    }
    loadShader(type, shaderSource) {
        const shader = this.gl.createShader(type);
        // If we couldn't create the shader, error
        if (shader === null) {
            console.warn("Unable to create shader");
            return null;
        }
        // Add the source to the shader and compile
        this.gl.shaderSource(shader, shaderSource);
        this.gl.compileShader(shader);
        // Make sure there were no errors during this process
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            // Not compiled - error
            const error = this.gl.getShaderInfoLog(shader);
            console.warn("Failed to compile shader: " + error);
            // Clean up
            this.gl.deleteShader(shader);
            return null;
        }
        // Sucess, so return the shader
        return shader;
    }
    /* ########## GENERAL LOADING FUNCTIONS ########## */
    loadTextFile(textFilePath, callback) {
        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open("GET", textFilePath, true);
        xobj.onreadystatechange = function () {
            if (xobj.readyState == 4 && xobj.status == 200) {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }
    /* ########## LOADING BAR INFO ########## */
    getLoadPercent() {
        return ((this.loadonly_tilemapsLoaded / this.loadonly_tilemapsToLoad +
            this.loadonly_spritesheetsLoaded / this.loadonly_spritesheetsToLoad +
            this.loadonly_imagesLoaded / this.loadonly_imagesToLoad +
            this.loadonly_audioLoaded / this.loadonly_audioToLoad) /
            this.loadonly_typesToLoad);
    }
    update(deltaT) {
        if (this.loading) {
            if (this.onLoadProgress) {
                this.onLoadProgress(this.getLoadPercent());
            }
        }
        else if (this.justLoaded) {
            this.justLoaded = false;
            if (this.onLoadComplete) {
                this.onLoadComplete();
            }
        }
    }
}
exports.default = ResourceManager;
/**
 * A class representing a reference to a resource.
 * This is used for the exemption list to assure assets and their dependencies don't get
 * destroyed if they are still needed.
 */
class ResourceReference {
    constructor(key, resourceType) {
        this.key = key;
        this.resourceType = resourceType;
        this.dependencies = new Array();
    }
    addDependency(resource) {
        this.dependencies.push(resource);
    }
}
var ResourceType;
(function (ResourceType) {
    ResourceType["IMAGE"] = "IMAGE";
    ResourceType["TILEMAP"] = "TILEMAP";
    ResourceType["SPRITESHEET"] = "SPRITESHEET";
    ResourceType["AUDIO"] = "AUDIO";
    ResourceType["JSON"] = "JSON";
    ResourceType["SHADER"] = "SHADER";
})(ResourceType || (ResourceType = {}));
/**
 * A pair representing a key and the path of the resource to load
 */
class KeyPathPair {
    constructor() {
        this.isDependency = false;
    }
}
class KeyPath_Shader {
}
},{"../DataTypes/Map":43,"../DataTypes/Queue":47,"../DataTypes/Rendering/WebGLProgramType":48,"../Sound/AudioManager":128,"../Utils/StringUtils":136}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
/**
 * An abstract interface of a SceneGraph.
 * Exposes methods for use by other code, but leaves the implementation up to the subclasses.
 * The SceneGraph manages the positions of all GameNodes, and can easily prune a visible set for rendering.
 */
class SceneGraph {
    /**
     * Creates a new SceneGraph
     * @param viewport The viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        this.viewport = viewport;
        this.scene = scene;
        this.nodeMap = new Array();
        this.idCounter = 0;
    }
    /**
     * Add a node to the SceneGraph
     * @param node The CanvasNode to add to the SceneGraph
     * @returns The SceneGraph ID of this newly added CanvasNode
     */
    addNode(node) {
        this.nodeMap[node.id] = node;
        this.addNodeSpecific(node, this.idCounter);
        this.idCounter += 1;
        return this.idCounter - 1;
    }
    /**
     * Removes a node from the SceneGraph
     * @param node The node to remove
     */
    removeNode(node) {
        // Find and remove node in O(n)
        this.nodeMap[node.id] = undefined;
        this.removeNodeSpecific(node, node.id);
    }
    /**
     * Get a specific node using its id
     * @param id The id of the CanvasNode to retrieve
     * @returns The node with this ID
     */
    getNode(id) {
        return this.nodeMap[id];
    }
    /**
     * Returns the nodes at specific coordinates
     * @param vecOrX The x-coordinate of the position, or the coordinates in a Vec2
     * @param y The y-coordinate of the position
     * @returns An array of nodes found at the position provided
     */
    getNodesAt(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            return this.getNodesAtCoords(vecOrX.x, vecOrX.y);
        }
        else {
            return this.getNodesAtCoords(vecOrX, y);
        }
    }
    /**
     * Returns all nodes in the SceneGraph
     * @returns An Array containing all nodes in the SceneGraph
     */
    getAllNodes() {
        let arr = new Array();
        for (let i = 0; i < this.nodeMap.length; i++) {
            if (this.nodeMap[i] !== undefined) {
                arr.push(this.nodeMap[i]);
            }
        }
        return arr;
    }
}
exports.default = SceneGraph;
},{"../DataTypes/Vec2":56}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const SceneGraph_1 = require("./SceneGraph");
const Stats_1 = require("../Debug/Stats");
/**
 * An implementation of a SceneGraph that simply stored CanvasNodes in an array.
 */
class SceneGraphArray extends SceneGraph_1.default {
    /**
     * Creates a new SceneGraphArray
     * @param viewport The Viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        super(viewport, scene);
        this.nodeList = new Array();
    }
    // @override
    addNodeSpecific(node, id) {
        this.nodeList.push(node);
    }
    // @override
    removeNodeSpecific(node, id) {
        let index = this.nodeList.indexOf(node);
        if (index > -1) {
            this.nodeList.splice(index, 1);
        }
    }
    // @override
    getNodesAtCoords(x, y) {
        let results = [];
        for (let node of this.nodeList) {
            if (node.contains(x, y)) {
                results.push(node);
            }
        }
        return results;
    }
    // @override
    getNodesInRegion(boundary) {
        let t0 = performance.now();
        let results = [];
        for (let node of this.nodeList) {
            if (boundary.overlaps(node.boundary)) {
                results.push(node);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgquery", t1 - t0);
        return results;
    }
    update(deltaT) {
        let t0 = performance.now();
        for (let node of this.nodeList) {
            if (!node.getLayer().isPaused()) {
                node.update(deltaT);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgupdate", t1 - t0);
    }
    render(ctx) { }
    // @override
    getVisibleSet() {
        let visibleSet = new Array();
        for (let node of this.nodeList) {
            if (!node.getLayer().isHidden() &&
                node.visible &&
                this.viewport.includes(node)) {
                visibleSet.push(node);
            }
        }
        return visibleSet;
    }
}
exports.default = SceneGraphArray;
},{"../Debug/Stats":58,"./SceneGraph":116}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const MathUtils_1 = require("../Utils/MathUtils");
const Queue_1 = require("../DataTypes/Queue");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const Input_1 = require("../Input/Input");
const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
const UILayer_1 = require("../Scene/Layers/UILayer");
/**
 * The viewport of the game. Corresponds to the visible window displayed in the browser.
 * The viewport keeps track of its position in the game world, and can act as a camera to follow objects.
 */
class Viewport {
    constructor(canvasSize, zoomLevel) {
        /** The amount that is zoomed in or out. */
        this.ZOOM_FACTOR = 1.2;
        this.view = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.boundary = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.lastPositions = new Queue_1.default();
        this.smoothingFactor = 10;
        this.scrollZoomEnabled = false;
        this.canvasSize = Vec2_1.default.ZERO;
        this.focus = Vec2_1.default.ZERO;
        // Set the size of the canvas
        this.setCanvasSize(canvasSize);
        // Set the size of the viewport
        this.setSize(canvasSize);
        this.setZoomLevel(zoomLevel);
        // Set the center (and make the viewport stay there)
        this.setCenter(this.view.halfSize.clone());
        this.setFocus(this.view.halfSize.clone());
    }
    /** Enables the viewport to zoom in and out */
    enableZoom() {
        this.scrollZoomEnabled = true;
    }
    /**
     * Returns the position of the viewport
     * @returns The center of the viewport as a Vec2
     */
    getCenter() {
        return this.view.center;
    }
    /**
     * Returns a new Vec2 with the origin of the viewport
     * @returns The top left cornder of the Vieport as a Vec2
     */
    getOrigin() {
        return new Vec2_1.default(this.view.left, this.view.top);
    }
    /**
     * Returns the region visible to this viewport
     * @returns The AABB containing the region visible to the viewport
     */
    getView() {
        return this.view;
    }
    /**
     * Set the position of the viewport
     * @param vecOrX The new position or the x-coordinate of the new position
     * @param y The y-coordinate of the new position
     */
    setCenter(vecOrX, y = null) {
        let pos;
        if (vecOrX instanceof Vec2_1.default) {
            pos = vecOrX;
        }
        else {
            pos = new Vec2_1.default(vecOrX, y);
        }
        this.view.center = pos;
    }
    /**
     * Returns the size of the viewport as a Vec2
     * @returns The half-size of the viewport as a Vec2
     */
    getHalfSize() {
        return this.view.getHalfSize();
    }
    /**
     * Sets the size of the viewport
     * @param vecOrX The new width of the viewport or the new size as a Vec2
     * @param y The new height of the viewport
     */
    setSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.scaled(1 / 2));
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX / 2, y / 2));
        }
    }
    /**
     * Sets the half-size of the viewport
     * @param vecOrX The new half-width of the viewport or the new half-size as a Vec2
     * @param y The new height of the viewport
     */
    setHalfSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.clone());
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX, y));
        }
    }
    /**
     * Updates the viewport with the size of the current Canvas
     * @param vecOrX The width of the canvas, or the canvas size as a Vec2
     * @param y The height of the canvas
     */
    setCanvasSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.canvasSize = vecOrX.clone();
        }
        else {
            this.canvasSize = new Vec2_1.default(vecOrX, y);
        }
    }
    /**
     * Sets the zoom level of the viewport
     * @param zoom The zoom level
     */
    setZoomLevel(zoom) {
        this.view.halfSize.copy(this.canvasSize.scaled(1 / zoom / 2));
    }
    /**
     * Gets the zoom level of the viewport
     * @returns The zoom level
     */
    getZoomLevel() {
        return this.canvasSize.x / this.view.hw / 2;
    }
    /**
     * Sets the smoothing factor for the viewport movement.
     * @param smoothingFactor The smoothing factor for the viewport
     */
    setSmoothingFactor(smoothingFactor) {
        if (smoothingFactor < 0)
            smoothingFactor = 0;
        this.smoothingFactor = smoothingFactor;
    }
    /**
     * Tells the viewport to focus on a point. Overidden by "following".
     * @param focus The point the  viewport should focus on
     */
    setFocus(focus) {
        this.focus.copy(focus);
    }
    /**
     * Returns true if the CanvasNode is inside of the viewport
     * @param node The node to check
     * @returns True if the node is currently visible in the viewport, false if not
     */
    includes(node) {
        let parallax = node.getLayer() instanceof ParallaxLayer_1.default ||
            node.getLayer() instanceof UILayer_1.default
            ? node.getLayer().parallax
            : new Vec2_1.default(1, 1);
        let center = this.view.center.clone();
        this.view.center.mult(parallax);
        let overlaps = this.view.overlaps(node.boundary);
        this.view.center = center;
        return overlaps;
    }
    // TODO: Put some error handling on this for trying to make the bounds too small for the viewport
    // TODO: This should probably be done automatically, or should consider the aspect ratio or something
    /**
     * Sets the bounds of the viewport
     * @param lowerX The left edge of the viewport
     * @param lowerY The top edge of the viewport
     * @param upperX The right edge of the viewport
     * @param upperY The bottom edge of the viewport
     */
    setBounds(lowerX, lowerY, upperX, upperY) {
        let hwidth = (upperX - lowerX) / 2;
        let hheight = (upperY - lowerY) / 2;
        let x = lowerX + hwidth;
        let y = lowerY + hheight;
        this.boundary.center.set(x, y);
        this.boundary.halfSize.set(hwidth, hheight);
    }
    /**
     * Make the viewport follow the specified GameNode
     * @param node The GameNode to follow
     */
    follow(node) {
        this.following = node;
    }
    updateView() {
        if (this.lastPositions.getSize() > Math.min(this.smoothingFactor, 1)) {
            this.lastPositions.dequeue();
        }
        // Get the average of the last 10 positions
        let pos = Vec2_1.default.ZERO;
        if (this.smoothingFactor != 0) {
            this.lastPositions.forEach(position => pos.add(position));
            pos.scale(1 / this.lastPositions.getSize());
        }
        else {
            this.lastPositions.forEach(position => (pos = position));
        }
        // Set this position either to the object or to its bounds
        pos.x = MathUtils_1.default.clamp(pos.x, this.boundary.left + this.view.hw, this.boundary.right - this.view.hw);
        pos.y = MathUtils_1.default.clamp(pos.y, this.boundary.top + this.view.hh, this.boundary.bottom - this.view.hh);
        // Assure there are no lines in the tilemap
        pos.x = Math.floor(pos.x);
        pos.y = Math.floor(pos.y);
        this.view.center.copy(pos);
    }
    update(deltaT) {
        // If zoom is enabled
        if (this.scrollZoomEnabled) {
            if (Input_1.default.didJustScroll()) {
                let currentSize = this.view.getHalfSize().clone();
                if (Input_1.default.getScrollDirection() < 0) {
                    // Zoom in
                    currentSize.scale(1 / this.ZOOM_FACTOR);
                }
                else {
                    // Zoom out
                    currentSize.scale(this.ZOOM_FACTOR);
                }
                if (currentSize.x > this.boundary.hw) {
                    let factor = this.boundary.hw / currentSize.x;
                    currentSize.x = this.boundary.hw;
                    currentSize.y *= factor;
                }
                if (currentSize.y > this.boundary.hh) {
                    let factor = this.boundary.hh / currentSize.y;
                    currentSize.y = this.boundary.hh;
                    currentSize.x *= factor;
                }
                this.view.setHalfSize(currentSize);
            }
        }
        // If viewport is following an object
        if (this.following) {
            // Update our list of previous positions
            this.lastPositions.enqueue(this.following.position.clone());
        }
        else {
            this.lastPositions.enqueue(this.focus);
        }
        this.updateView();
    }
}
exports.default = Viewport;
},{"../DataTypes/Queue":47,"../DataTypes/Shapes/AABB":49,"../DataTypes/Vec2":56,"../Input/Input":64,"../Scene/Layers/ParallaxLayer":123,"../Scene/Layers/UILayer":124,"../Utils/MathUtils":134}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = require("../../Nodes/Sprites/Sprite");
const AnimatedSprite_1 = require("../../Nodes/Sprites/AnimatedSprite");
const GraphicTypes_1 = require("../../Nodes/Graphics/GraphicTypes");
const UIElementTypes_1 = require("../../Nodes/UIElements/UIElementTypes");
const Point_1 = require("../../Nodes/Graphics/Point");
const Vec2_1 = require("../../DataTypes/Vec2");
const Button_1 = require("../../Nodes/UIElements/Button");
const Label_1 = require("../../Nodes/UIElements/Label");
const Slider_1 = require("../../Nodes/UIElements/Slider");
const TextInput_1 = require("../../Nodes/UIElements/TextInput");
const Rect_1 = require("../../Nodes/Graphics/Rect");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Line_1 = require("../../Nodes/Graphics/Line");
const Particle_1 = require("../../Nodes/Graphics/Particle");
// @ignorePage
/**
 * A factory that abstracts adding @reference[CanvasNode]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class CanvasNodeFactory {
    constructor() {
        /**
         * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
         * @param type The type of UIElement to add
         * @param layerName The layer to add the UIElement to
         * @param options Any additional arguments to feed to the constructor
         * @returns A new UIElement
         */
        this.addUIElement = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case UIElementTypes_1.UIElementType.BUTTON:
                    instance = this.buildButton(options);
                    break;
                case UIElementTypes_1.UIElementType.LABEL:
                    instance = this.buildLabel(options);
                    break;
                case UIElementTypes_1.UIElementType.SLIDER:
                    instance = this.buildSlider(options);
                    break;
                case UIElementTypes_1.UIElementType.TEXT_INPUT:
                    instance = this.buildTextInput(options);
                    break;
                default:
                    throw `UIElementType '${type}' does not exist, or is registered incorrectly.`;
            }
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            this.scene.getSceneGraph().addNode(instance);
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a sprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new Sprite
         */
        this.addSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let instance = new Sprite_1.default(key);
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds an AnimatedSprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new AnimatedSprite
         */
        this.addAnimatedSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let spritesheet = this.resourceManager.getSpritesheet(key);
            let instance = new AnimatedSprite_1.default(spritesheet);
            // Add instance fo scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a new graphic element to the current Scene
         * @param type The type of graphic to add
         * @param layerName The layer on which to add the graphic
         * @param options Any additional arguments to send to the graphic constructor
         * @returns A new Graphic
         */
        this.addGraphic = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case GraphicTypes_1.GraphicType.POINT:
                    instance = this.buildPoint(options);
                    break;
                case GraphicTypes_1.GraphicType.LINE:
                    instance = this.buildLine(options);
                    break;
                case GraphicTypes_1.GraphicType.RECT:
                    instance = this.buildRect(options);
                    break;
                case GraphicTypes_1.GraphicType.PARTICLE:
                    instance = this.buildParticle(options);
                    break;
                default:
                    throw `GraphicType '${type}' does not exist, or is registered incorrectly.`;
            }
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
    }
    init(scene) {
        this.scene = scene;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /* ---------- BUILDERS ---------- */
    buildButton(options) {
        this.checkIfPropExists("Button", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Button", options, "text", "string");
        return new Button_1.default(options.position, options.text);
    }
    buildLabel(options) {
        this.checkIfPropExists("Label", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Label", options, "text", "string");
        return new Label_1.default(options.position, options.text);
    }
    buildSlider(options) {
        this.checkIfPropExists("Slider", options, "position", Vec2_1.default, "Vec2");
        let initValue = 0;
        if (options.value !== undefined) {
            initValue = options.value;
        }
        return new Slider_1.default(options.position, initValue);
    }
    buildTextInput(options) {
        this.checkIfPropExists("TextInput", options, "position", Vec2_1.default, "Vec2");
        return new TextInput_1.default(options.position);
    }
    buildPoint(options) {
        this.checkIfPropExists("Point", options, "position", Vec2_1.default, "Vec2");
        return new Point_1.default(options.position);
    }
    buildParticle(options) {
        this.checkIfPropExists("Particle", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Particle", options, "size", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Particle", options, "mass", "number", "number");
        //Changed for testing
        return new Particle_1.default(options.position, options.size, options.mass);
    }
    buildLine(options) {
        this.checkIfPropExists("Line", options, "start", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Line", options, "end", Vec2_1.default, "Vec2");
        return new Line_1.default(options.start, options.end);
    }
    buildRect(options) {
        this.checkIfPropExists("Rect", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Rect", options, "size", Vec2_1.default, "Vec2");
        return new Rect_1.default(options.position, options.size);
    }
    /* ---------- ERROR HANDLING ---------- */
    checkIfPropExists(objectName, options, prop, type, typeName) {
        if (!options || options[prop] === undefined) {
            // Check that the options object has the property
            throw `${objectName} object requires argument ${prop} of type ${typeName}, but none was provided.`;
        }
        else {
            // Check that the property has the correct type
            if (typeof type === "string") {
                if (!(typeof options[prop] === type)) {
                    throw `${objectName} object requires argument ${prop} of type ${type}, but provided ${prop} was not of type ${type}.`;
                }
            }
            else if (type instanceof Function) {
                // If type is a constructor, check against that
                if (!(options[prop] instanceof type)) {
                    throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
                }
            }
            else {
                throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
            }
        }
    }
}
exports.default = CanvasNodeFactory;
},{"../../DataTypes/Vec2":56,"../../Nodes/Graphics/GraphicTypes":74,"../../Nodes/Graphics/Line":75,"../../Nodes/Graphics/Particle":76,"../../Nodes/Graphics/Point":77,"../../Nodes/Graphics/Rect":78,"../../Nodes/Sprites/AnimatedSprite":79,"../../Nodes/Sprites/Sprite":80,"../../Nodes/UIElements/Button":84,"../../Nodes/UIElements/Label":85,"../../Nodes/UIElements/Slider":86,"../../Nodes/UIElements/TextInput":87,"../../Nodes/UIElements/UIElementTypes":88,"../../ResourceManager/ResourceManager":115}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNodeFactory_1 = require("./CanvasNodeFactory");
const TilemapFactory_1 = require("./TilemapFactory");
/**
 * The manager of all factories used for adding @reference[GameNode]s to the @reference[Scene].
 */
class FactoryManager {
    constructor(scene, tilemaps) {
        // Constructors are called here to allow assignment of their functions to functions in this class
        this.canvasNodeFactory = new CanvasNodeFactory_1.default();
        this.tilemapFactory = new TilemapFactory_1.default();
        this.canvasNodeFactory.init(scene);
        this.tilemapFactory.init(scene, tilemaps);
    }
    // Expose all of the factories through the factory manager
    /**
     * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
     * @param type The type of UIElement to add
     * @param layerName The layer to add the UIElement to
     * @param options Any additional arguments to feed to the constructor
     * @returns A new UIElement
     */
    uiElement(type, layerName, options) {
        return this.canvasNodeFactory.addUIElement(type, layerName, options);
    }
    /**
     * Adds a sprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new Sprite
     */
    sprite(key, layerName) {
        return this.canvasNodeFactory.addSprite(key, layerName);
    }
    /**
     * Adds an AnimatedSprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new AnimatedSprite
     */
    animatedSprite(key, layerName) {
        return this.canvasNodeFactory.addAnimatedSprite(key, layerName);
    }
    /**
     * Adds a new graphic element to the current Scene
     * @param type The type of graphic to add
     * @param layerName The layer on which to add the graphic
     * @param options Any additional arguments to send to the graphic constructor
     * @returns A new Graphic
     */
    graphic(type, layerName, options) {
        return this.canvasNodeFactory.addGraphic(type, layerName, options);
    }
    /**
     * Adds a tilemap to the scene
     * @param key The key of the loaded tilemap to load
     * @param constr The constructor of the desired tilemap
     * @param args Additional arguments to send to the tilemap constructor
     * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
     */
    tilemap(key, scale) {
        return this.tilemapFactory.add(key, scale);
    }
}
exports.default = FactoryManager;
},{"./CanvasNodeFactory":119,"./TilemapFactory":121}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const OrthogonalTilemap_1 = require("../../Nodes/Tilemaps/OrthogonalTilemap");
const Tileset_1 = require("../../DataTypes/Tilesets/Tileset");
const Vec2_1 = require("../../DataTypes/Vec2");
const PositionGraph_1 = require("../../DataTypes/Graphs/PositionGraph");
const Navmesh_1 = require("../../Pathfinding/Navmesh");
// @ignorePage
/**
 * A factory that abstracts adding @reference[Tilemap]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class TilemapFactory {
    constructor() {
        // TODO - This is specifically catered to Tiled tilemaps right now. In the future,
        // it would be good to have a "parseTilemap" function that would convert the tilemap
        // data into a standard format. This could allow for support from other programs
        // or the development of an internal level builder tool
        /**
         * Adds a tilemap to the scene
         * @param key The key of the loaded tilemap to load
         * @param constr The constructor of the desired tilemap
         * @param args Additional arguments to send to the tilemap constructor
         * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
         */
        this.add = (key, scale = new Vec2_1.default(1, 1)) => {
            // Get Tilemap Data
            let tilemapData = this.resourceManager.getTilemap(key);
            // Set the constructor for this tilemap to either be orthographic or isometric
            let constr;
            if (tilemapData.orientation === "orthographic") {
                constr = OrthogonalTilemap_1.default;
            }
            else {
                // No isometric tilemap support right now, so Orthographic tilemap
                constr = OrthogonalTilemap_1.default;
            }
            // Initialize the return value array
            let sceneLayers = new Array();
            // Create all of the tilesets for this tilemap
            let tilesets = new Array();
            let collectionTiles = new Array();
            for (let tileset of tilemapData.tilesets) {
                if (tileset.image) {
                    // If this is a standard tileset and not a collection, create a tileset for it.
                    // TODO - We are ignoring collection tilesets for now. This is likely not a great idea in practice,
                    // as theoretically someone could want to use one for a standard tilemap. We are assuming for now
                    // that we only want to use them for object layers
                    tilesets.push(new Tileset_1.default(tileset));
                }
                else {
                    tileset.tiles.forEach(tile => (tile.id += tileset.firstgid));
                    collectionTiles.push(...tileset.tiles);
                }
            }
            // Loop over the layers of the tilemap and create tiledlayers or object layers
            for (let layer of tilemapData.layers) {
                let sceneLayer;
                let isParallaxLayer = false;
                let depth = 0;
                if (layer.properties) {
                    for (let prop of layer.properties) {
                        if (prop.name === "Parallax") {
                            isParallaxLayer = prop.value;
                        }
                        else if (prop.name === "Depth") {
                            depth = prop.value;
                        }
                    }
                }
                if (isParallaxLayer) {
                    sceneLayer = this.scene.addParallaxLayer(layer.name, new Vec2_1.default(1, 1), depth);
                }
                else {
                    sceneLayer = this.scene.addLayer(layer.name, depth);
                }
                if (layer.type === "tilelayer") {
                    // Create a new tilemap object for the layer
                    let tilemap = new constr(tilemapData, layer, tilesets, scale);
                    tilemap.id = this.scene.generateId();
                    tilemap.setScene(this.scene);
                    // Add tilemap to scene
                    this.tilemaps.push(tilemap);
                    sceneLayer.addNode(tilemap);
                    // Register tilemap with physics if it's collidable
                    if (tilemap.isCollidable) {
                        tilemap.addPhysics();
                        if (layer.properties) {
                            for (let item of layer.properties) {
                                if (item.name === "Group") {
                                    tilemap.setGroup(item.value);
                                }
                            }
                        }
                    }
                }
                else {
                    let isNavmeshPoints = false;
                    let navmeshName;
                    let edges;
                    if (layer.properties) {
                        for (let prop of layer.properties) {
                            if (prop.name === "NavmeshPoints") {
                                isNavmeshPoints = true;
                            }
                            else if (prop.name === "name") {
                                navmeshName = prop.value;
                            }
                            else if (prop.name === "edges") {
                                edges = prop.value;
                            }
                        }
                    }
                    if (isNavmeshPoints) {
                        let g = new PositionGraph_1.default();
                        for (let obj of layer.objects) {
                            g.addPositionedNode(new Vec2_1.default(obj.x, obj.y));
                        }
                        for (let edge of edges) {
                            g.addEdge(edge.from, edge.to);
                        }
                        this.scene
                            .getNavigationManager()
                            .addNavigableEntity(navmeshName, new Navmesh_1.default(g));
                        continue;
                    }
                    // Layer is an object layer, so add each object as a sprite to a new layer
                    for (let obj of layer.objects) {
                        // Check if obj is collidable
                        let hasPhysics = false;
                        let isCollidable = false;
                        let isTrigger = false;
                        let onEnter = null;
                        let onExit = null;
                        let triggerGroup = null;
                        let group = "";
                        if (obj.properties) {
                            for (let prop of obj.properties) {
                                if (prop.name === "HasPhysics") {
                                    hasPhysics = prop.value;
                                }
                                else if (prop.name === "Collidable") {
                                    isCollidable = prop.value;
                                }
                                else if (prop.name === "Group") {
                                    group = prop.value;
                                }
                                else if (prop.name === "IsTrigger") {
                                    isTrigger = prop.value;
                                }
                                else if (prop.name === "TriggerGroup") {
                                    triggerGroup = prop.value;
                                }
                                else if (prop.name === "TriggerOnEnter") {
                                    onEnter = prop.value;
                                }
                                else if (prop.name === "TriggerOnExit") {
                                    onExit = prop.value;
                                }
                            }
                        }
                        let sprite;
                        // Check if obj is a tile from a tileset
                        for (let tileset of tilesets) {
                            if (tileset.hasTile(obj.gid)) {
                                // The object is a tile from this set
                                let imageKey = tileset.getImageKey();
                                let offset = tileset.getImageOffsetForTile(obj.gid);
                                sprite = this.scene.add.sprite(imageKey, layer.name);
                                let size = tileset.getTileSize().clone();
                                sprite.position.set((obj.x + size.x / 2) * scale.x, (obj.y - size.y / 2) * scale.y);
                                sprite.setImageOffset(offset);
                                sprite.size.copy(size);
                                sprite.scale.set(scale.x, scale.y);
                            }
                        }
                        // Not in a tileset, must correspond to a collection
                        if (!sprite) {
                            for (let tile of collectionTiles) {
                                if (obj.gid === tile.id) {
                                    let imageKey = tile.image;
                                    sprite = this.scene.add.sprite(imageKey, layer.name);
                                    sprite.position.set((obj.x + tile.imagewidth / 2) * scale.x, (obj.y - tile.imageheight / 2) * scale.y);
                                    sprite.scale.set(scale.x, scale.y);
                                }
                            }
                        }
                        // Now we have sprite. Associate it with our physics object if there is one
                        if (hasPhysics) {
                            // Make the sprite a static physics object
                            sprite.addPhysics(sprite.boundary.clone(), Vec2_1.default.ZERO, isCollidable, true);
                            sprite.setGroup(group);
                            if (isTrigger && triggerGroup !== null) {
                                sprite.setTrigger(triggerGroup, onEnter, onExit);
                            }
                        }
                    }
                }
                // Update the return value
                sceneLayers.push(sceneLayer);
            }
            return sceneLayers;
        };
    }
    init(scene, tilemaps) {
        this.scene = scene;
        this.tilemaps = tilemaps;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
}
exports.default = TilemapFactory;
},{"../../DataTypes/Graphs/PositionGraph":41,"../../DataTypes/Tilesets/Tileset":55,"../../DataTypes/Vec2":56,"../../Nodes/Tilemaps/OrthogonalTilemap":82,"../../Pathfinding/Navmesh":91,"../../ResourceManager/ResourceManager":115}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("../Utils/MathUtils");
/**
 * A layer in the scene. Layers are used for sorting @reference[GameNode]s by depth.
 */
class Layer {
    /**
     * Creates a new layer. To do this in a game, use the addLayer() method in @refrence[Scene]
     * @param scene The scene to add the layer to
     * @param name The name of the layer
     */
    constructor(scene, name) {
        this.scene = scene;
        this.name = name;
        this.paused = false;
        this.hidden = false;
        this.alpha = 1;
        this.items = new Array();
        this.ySort = false;
        this.depth = 0;
    }
    /**
     * Retreives the name of the layer
     * @returns The name of the layer
     */
    getName() {
        return this.name;
    }
    /**
     * Pauses/Unpauses the layer. Affects all elements in this layer
     * @param pauseValue True if the layer should be paused, false if not
     */
    setPaused(pauseValue) {
        this.paused = pauseValue;
    }
    /**
     * Returns whether or not the layer is paused
     */
    isPaused() {
        return this.paused;
    }
    /**
     * Sets the opacity of the layer
     * @param alpha The new opacity value in the range [0, 1]
     */
    setAlpha(alpha) {
        this.alpha = MathUtils_1.default.clamp(alpha, 0, 1);
    }
    /**
     * Gets the opacity of the layer
     * @returns The opacity
     */
    getAlpha() {
        return this.alpha;
    }
    /**
     * Sets the layer's hidden value. If hidden, a layer will not be rendered, but will still update
     * @param hidden The hidden value of the layer
     */
    setHidden(hidden) {
        this.hidden = hidden;
    }
    /**
     * Returns the hideen value of the lyaer
     * @returns True if the scene is hidden, false otherwise
     */
    isHidden() {
        return this.hidden;
    }
    /** Pauses this scene and hides it */
    disable() {
        this.paused = true;
        this.hidden = true;
    }
    /** Unpauses this layer and makes it visible */
    enable() {
        this.paused = false;
        this.hidden = false;
    }
    /**
     * Sets whether or not the scene will ySort automatically.
     * ySorting means that CanvasNodes on this layer will have their depth sorted depending on their y-value.
     * This means that if an object is "higher" in the scene, it will sort behind objects that are "lower".
     * This is useful for 3/4 view games, or similar situations, where you sometimes want to be in front of objects,
     * and other times want to be behind the same objects.
     * @param ySort True if ySorting should be active, false if not
     */
    setYSort(ySort) {
        this.ySort = ySort;
    }
    /**
     * Gets the ySort status of the scene
     * @returns True if ySorting is occurring, false otherwise
     */
    getYSort() {
        return this.ySort;
    }
    /**
     * Sets the depth of the layer compared to other layers. A larger number means the layer will be closer to the screen.
     * @param depth The depth of the layer.
     */
    setDepth(depth) {
        this.depth = depth;
    }
    /**
     * Retrieves the depth of the layer.
     * @returns The depth
     */
    getDepth() {
        return this.depth;
    }
    /**
     * Adds a node to this layer
     * @param node The node to add to this layer.
     */
    addNode(node) {
        this.items.push(node);
        node.setLayer(this);
    }
    /**
     * Removes a node from this layer
     * @param node The node to remove
     * @returns true if the node was removed, false otherwise
     */
    removeNode(node) {
        // Find and remove the node
        let index = this.items.indexOf(node);
        if (index !== -1) {
            this.items.splice(index, 1);
            node.setLayer(undefined);
        }
    }
    /**
     * Retreives all GameNodes from this layer
     * @returns an Array that contains all of the GameNodes in this layer.
     */
    getItems() {
        return this.items;
    }
}
exports.default = Layer;
},{"../Utils/MathUtils":134}],123:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = require("../Layer");
/**
 * An extension of a Layer that has a parallax value.
 */
class ParallaxLayer extends Layer_1.default {
    /**
     * Creates a new ParallaxLayer.
     * Use addParallaxLayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this ParallaxLayer to
     * @param name The name of the ParallaxLayer
     * @param parallax The parallax level
     */
    constructor(scene, name, parallax) {
        super(scene, name);
        this.parallax = parallax;
    }
}
exports.default = ParallaxLayer;
},{"../Layer":122}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const ParallaxLayer_1 = require("./ParallaxLayer");
/**
 * A Layer strictly to be used for managing UIElements.
 * This is intended to be a Layer that always stays in the same place,
 * and thus renders things like a HUD or an inventory without taking into consideration the \reference[Viewport] scroll.
 */
class UILayer extends ParallaxLayer_1.default {
    /**
     * Creates a new UILayer.
     * Use addUILayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this UILayer to
     * @param name The name of the UILayer
     */
    constructor(scene, name) {
        super(scene, name, Vec2_1.default.ZERO);
    }
}
exports.default = UILayer;
},{"../../DataTypes/Vec2":56,"./ParallaxLayer":123}],125:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = require("./Layer");
const Vec2_1 = require("../DataTypes/Vec2");
const BasicPhysicsManager_1 = require("../Physics/BasicPhysicsManager");
const SceneGraphArray_1 = require("../SceneGraph/SceneGraphArray");
const FactoryManager_1 = require("./Factories/FactoryManager");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const NavigationManager_1 = require("../Pathfinding/NavigationManager");
const AIManager_1 = require("../AI/AIManager");
const Map_1 = require("../DataTypes/Map");
const ParallaxLayer_1 = require("./Layers/ParallaxLayer");
const UILayer_1 = require("./Layers/UILayer");
const CanvasNode_1 = require("../Nodes/CanvasNode");
const SceneOptions_1 = require("./SceneOptions");
const Debug_1 = require("../Debug/Debug");
const TimerManager_1 = require("../Timing/TimerManager");
const TweenManager_1 = require("../Rendering/Animations/TweenManager");
const ParticleSystemManager_1 = require("../Rendering/Animations/ParticleSystemManager");
/**
 * Scenes are the main container in the game engine.
 * Your main scene is the current level or menu of the game, and will contain all of the GameNodes needed.
 * Scenes provide an easy way to load assets, add assets to the game world, and unload assets,
 * and have lifecycle methods exposed for these functions.
 */
class Scene {
    /**
     * Creates a new Scene. To add a new Scene in your game, use changeToScene() in @reference[SceneManager]
     * @param viewport The viewport of the game
     * @param sceneManager The SceneManager that owns this Scene
     * @param renderingManager The RenderingManager that will handle this Scene's rendering
     * @param game The instance of the Game
     * @param options The options for Scene initialization
     */
    constructor(viewport, sceneManager, renderingManager, options) {
        this.sceneOptions = SceneOptions_1.default.parse(options === undefined ? {} : options);
        this.worldSize = new Vec2_1.default(500, 500);
        this.viewport = viewport;
        this.viewport.setBounds(0, 0, 2560, 1280);
        this.running = false;
        this.sceneManager = sceneManager;
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tilemaps = new Array();
        this.sceneGraph = new SceneGraphArray_1.default(this.viewport, this);
        this.layers = new Map_1.default();
        this.uiLayers = new Map_1.default();
        this.parallaxLayers = new Map_1.default();
        this.physicsManager = new BasicPhysicsManager_1.default(this.sceneOptions.physics);
        this.navManager = new NavigationManager_1.default();
        this.aiManager = new AIManager_1.default();
        this.renderingManager = renderingManager;
        this.add = new FactoryManager_1.default(this, this.tilemaps);
        this.load = ResourceManager_1.default.getInstance();
        this.resourceManager = this.load;
        // Get the timer manager and clear any existing timers
        TimerManager_1.default.getInstance().clearTimers();
    }
    /** A lifecycle method that gets called immediately after a new scene is created, before anything else. */
    initScene(init) { }
    /** A lifecycle method that gets called when a new scene is created. Load all files you wish to access in the scene here. */
    loadScene() { }
    /** A lifecycle method called strictly after loadScene(). Create any game objects you wish to use in the scene here. */
    startScene() { }
    /**
     * A lifecycle method called every frame of the game. This is where you can dynamically do things like add in new enemies
     * @param delta The time this frame represents
     */
    updateScene(deltaT) { }
    /** A lifecycle method that gets called on scene destruction. Specify which files you no longer need for garbage collection. */
    unloadScene() { }
    update(deltaT) {
        this.updateScene(deltaT);
        // Do time updates
        TimerManager_1.default.getInstance().update(deltaT);
        // Do all AI updates
        this.aiManager.update(deltaT);
        // Update all physics objects
        this.physicsManager.update(deltaT);
        // Update all canvas objects
        this.sceneGraph.update(deltaT);
        // Update all tilemaps
        this.tilemaps.forEach(tilemap => {
            if (!tilemap.getLayer().isPaused()) {
                tilemap.update(deltaT);
            }
        });
        // Update all tweens
        TweenManager_1.default.getInstance().update(deltaT);
        // Update all particle systems
        ParticleSystemManager_1.default.getInstance().update(deltaT);
        // Update viewport
        this.viewport.update(deltaT);
    }
    /**
     * Collects renderable sets and coordinates with the RenderingManager to draw the Scene
     */
    render() {
        // Get the visible set of nodes
        let visibleSet = this.sceneGraph.getVisibleSet();
        // Add parallax layer items to the visible set (we're rendering them all for now)
        this.parallaxLayers.forEach(key => {
            let pLayer = this.parallaxLayers.get(key);
            for (let node of pLayer.getItems()) {
                if (node instanceof CanvasNode_1.default) {
                    visibleSet.push(node);
                }
            }
        });
        // Send the visible set, tilemaps, and uiLayers to the renderer
        this.renderingManager.render(visibleSet, this.tilemaps, this.uiLayers);
        let nodes = this.sceneGraph.getAllNodes();
        this.tilemaps.forEach(tilemap => tilemap.visible ? nodes.push(tilemap) : 0);
        Debug_1.default.setNodes(nodes);
    }
    /**
     * Sets the scene as running or not
     * @param running True if the Scene should be running, false if not
     */
    setRunning(running) {
        this.running = running;
    }
    /**
     * Returns whether or not the Scene is running
     * @returns True if the scene is running, false otherwise
     */
    isRunning() {
        return this.running;
    }
    /**
     * Removes a node from this Scene
     * @param node The node to remove
     */
    remove(node) {
        // Remove from the scene graph
        if (node instanceof CanvasNode_1.default) {
            this.sceneGraph.removeNode(node);
        }
    }
    /** Destroys this scene and all nodes in it */
    destroy() {
        for (let node of this.sceneGraph.getAllNodes()) {
            node.destroy();
        }
        for (let tilemap of this.tilemaps) {
            tilemap.destroy();
        }
        this.receiver.destroy();
        delete this.sceneGraph;
        delete this.physicsManager;
        delete this.navManager;
        delete this.aiManager;
        delete this.receiver;
    }
    /**
     * Adds a new layer to the scene and returns it
     * @param name The name of the new layer
     * @param depth The depth of the layer
     * @returns The newly created Layer
     */
    addLayer(name, depth) {
        if (this.layers.has(name) ||
            this.parallaxLayers.has(name) ||
            this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new Layer_1.default(this, name);
        this.layers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new parallax layer to this scene and returns it
     * @param name The name of the parallax layer
     * @param parallax The parallax level
     * @param depth The depth of the layer
     * @returns The newly created ParallaxLayer
     */
    addParallaxLayer(name, parallax, depth) {
        if (this.layers.has(name) ||
            this.parallaxLayers.has(name) ||
            this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new ParallaxLayer_1.default(this, name, parallax);
        this.parallaxLayers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new UILayer to the scene
     * @param name The name of the new UIlayer
     * @returns The newly created UILayer
     */
    addUILayer(name) {
        if (this.layers.has(name) ||
            this.parallaxLayers.has(name) ||
            this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new UILayer_1.default(this, name);
        this.uiLayers.add(name, layer);
        return layer;
    }
    /**
     * Gets a layer from the scene by name if it exists.
     * This can be a Layer or any of its subclasses
     * @param name The name of the layer
     * @returns The Layer found with that name
     */
    getLayer(name) {
        if (this.layers.has(name)) {
            return this.layers.get(name);
        }
        else if (this.parallaxLayers.has(name)) {
            return this.parallaxLayers.get(name);
        }
        else if (this.uiLayers.has(name)) {
            return this.uiLayers.get(name);
        }
        else {
            throw `Requested layer ${name} does not exist.`;
        }
    }
    /**
     * Returns true if this layer is a ParallaxLayer
     * @param name The name of the layer
     * @returns True if this layer is a ParallaxLayer
     */
    isParallaxLayer(name) {
        return this.parallaxLayers.has(name);
    }
    /**
     * Returns true if this layer is a UILayer
     * @param name The name of the layer
     * @returns True if this layer is ParallaxLayer
     */
    isUILayer(name) {
        return this.uiLayers.has(name);
    }
    /**
     * Returns the translation of this node with respect to camera space (due to the viewport moving).
     * This value is affected by the parallax level of the @reference[Layer] the node is on.
     * @param node The node to check the viewport with respect to
     * @returns A Vec2 containing the translation of viewport with respect to this node.
     */
    getViewTranslation(node) {
        let layer = node.getLayer();
        if (layer instanceof ParallaxLayer_1.default || layer instanceof UILayer_1.default) {
            return this.viewport.getOrigin().mult(layer.parallax);
        }
        else {
            return this.viewport.getOrigin();
        }
    }
    /**
     * Returns the scale level of the view
     * @returns The zoom level of the viewport
     */
    getViewScale() {
        return this.viewport.getZoomLevel();
    }
    /**
     * Returns the Viewport associated with this scene
     * @returns The current Viewport
     */
    getViewport() {
        return this.viewport;
    }
    /**
     * Gets the world size of this Scene
     * @returns The world size in a Vec2
     */
    getWorldSize() {
        return this.worldSize;
    }
    /**
     * Gets the SceneGraph associated with this Scene
     * @returns The SceneGraph
     */
    getSceneGraph() {
        return this.sceneGraph;
    }
    /**
     * Gets the PhysicsManager associated with this Scene
     * @returns The PhysicsManager
     */
    getPhysicsManager() {
        return this.physicsManager;
    }
    /**
     * Gets the NavigationManager associated with this Scene
     * @returns The NavigationManager
     */
    getNavigationManager() {
        return this.navManager;
    }
    /**
     * Gets the AIManager associated with this Scene
     * @returns The AIManager
     */
    getAIManager() {
        return this.aiManager;
    }
    /**
     * Generates an ID for a GameNode
     * @returns The new ID
     */
    generateId() {
        return this.sceneManager.generateId();
    }
    /**
     * Retrieves a Tilemap in this Scene
     * @param name The name of the Tilemap
     * @returns The Tilemap, if one this name exists, otherwise null
     */
    getTilemap(name) {
        for (let tilemap of this.tilemaps) {
            if (tilemap.name === name) {
                return tilemap;
            }
        }
        return null;
    }
}
exports.default = Scene;
},{"../AI/AIManager":36,"../DataTypes/Map":43,"../DataTypes/Vec2":56,"../Debug/Debug":57,"../Events/Emitter":59,"../Events/Receiver":63,"../Nodes/CanvasNode":71,"../Pathfinding/NavigationManager":89,"../Physics/BasicPhysicsManager":92,"../Rendering/Animations/ParticleSystemManager":100,"../Rendering/Animations/TweenManager":102,"../ResourceManager/ResourceManager":115,"../SceneGraph/SceneGraphArray":117,"../Timing/TimerManager":130,"./Factories/FactoryManager":120,"./Layer":122,"./Layers/ParallaxLayer":123,"./Layers/UILayer":124,"./SceneOptions":127}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * The SceneManager acts as an interface to create Scenes, and handles the lifecycle methods of Scenes.
 * It gives Scenes access to information they need from the @reference[Game] class while keeping a layer of separation.
 */
class SceneManager {
    /**
     * Creates a new SceneManager
     * @param viewport The Viewport of the game
     * @param game The Game instance
     * @param renderingManager The RenderingManager of the game
     */
    constructor(viewport, renderingManager) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.viewport = viewport;
        this.renderingManager = renderingManager;
        this.idCounter = 0;
        this.pendingScene = null;
    }
    /**
     * Add a scene as the main scene.
     * Use this method if you've created a subclass of Scene, and you want to add it as the main Scene.
     * @param constr The constructor of the scene to add
     * @param init An object to pass to the init function of the new scene
     */
    changeToScene(constr, init, options) {
        console.log("Creating the new scene - change is pending until next update");
        this.pendingScene = new constr(this.viewport, this, this.renderingManager, options);
        this.pendingSceneInit = init;
    }
    doSceneChange() {
        console.log("Performing scene change");
        this.viewport.setCenter(this.viewport.getHalfSize().x, this.viewport.getHalfSize().y);
        if (this.currentScene) {
            console.log("Unloading old scene");
            this.currentScene.unloadScene();
            console.log("Destroying old scene");
            this.currentScene.destroy();
        }
        console.log("Unloading old resources...");
        this.resourceManager.unloadAllResources();
        // Make the pending scene the current one
        this.currentScene = this.pendingScene;
        // Make the pending scene null
        this.pendingScene = null;
        // Init the scene
        this.currentScene.initScene(this.pendingSceneInit);
        // Enqueue all scene asset loads
        this.currentScene.loadScene();
        // Load all assets
        console.log("Starting Scene Load");
        this.resourceManager.loadResourcesFromQueue(() => {
            console.log("Starting Scene");
            this.currentScene.startScene();
            this.currentScene.setRunning(true);
        });
        this.renderingManager.setScene(this.currentScene);
    }
    /**
     * Generates a unique ID
     * @returns A new ID
     */
    generateId() {
        return this.idCounter++;
    }
    /**
     * Renders the current Scene
     */
    render() {
        if (this.currentScene) {
            this.currentScene.render();
        }
    }
    /**
     * Updates the current Scene
     * @param deltaT The timestep of the Scene
     */
    update(deltaT) {
        if (this.pendingScene !== null) {
            this.doSceneChange();
        }
        if (this.currentScene && this.currentScene.isRunning()) {
            this.currentScene.update(deltaT);
        }
    }
}
exports.default = SceneManager;
},{"../ResourceManager/ResourceManager":115}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * The options to give a @reference[Scene] for initialization
 */
class SceneOptions {
    static parse(options) {
        let sOpt = new SceneOptions();
        if (options.physics === undefined) {
            sOpt.physics = { groups: undefined, collisions: undefined };
        }
        else {
            sOpt.physics = options.physics;
        }
        return sOpt;
    }
}
exports.default = SceneOptions;
},{}],128:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_AUDIO_CHANNELS = exports.AudioChannelType = void 0;
const Map_1 = require("../DataTypes/Map");
const Receiver_1 = require("../Events/Receiver");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Manages any sounds or music needed for the game.
 * Through the EventQueue, exposes interface to play sounds so GameNodes can activate sounds without
 * needing direct references to the audio system
 */
class AudioManager {
    constructor() {
        this.initAudio();
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe([
            GameEventType_1.GameEventType.PLAY_SOUND,
            GameEventType_1.GameEventType.STOP_SOUND,
            GameEventType_1.GameEventType.PLAY_MUSIC,
            GameEventType_1.GameEventType.PLAY_SFX,
            GameEventType_1.GameEventType.MUTE_CHANNEL,
            GameEventType_1.GameEventType.UNMUTE_CHANNEL,
        ]);
        this.currentSounds = new Map_1.default();
        this.gainNodes = new Array(exports.MAX_AUDIO_CHANNELS);
        this.initGainNodes();
    }
    /**
     * Get the instance of the AudioManager class or create a new one if none exists
     * @returns The AudioManager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new AudioManager();
        }
        return this.instance;
    }
    /**
     * Initializes the webAudio context
     */
    initAudio() {
        try {
            window.AudioContext = window.AudioContext; // || window.webkitAudioContext;
            this.audioCtx = new AudioContext();
            console.log("Web Audio API successfully loaded");
        }
        catch (e) {
            console.warn("Web Audio API is not supported in this browser");
        }
    }
    initGainNodes() {
        for (let i = 0; i < exports.MAX_AUDIO_CHANNELS; i++) {
            this.gainNodes[i] = this.audioCtx.createGain();
        }
    }
    /**
     * Returns the current audio context
     * @returns The AudioContext
     */
    getAudioContext() {
        return this.audioCtx;
    }
    /*
          According to the MDN, create a new sound for every call:
  
          An AudioBufferSourceNode can only be played once; after each call to start(), you have to create a new node
          if you want to play the same sound again. Fortunately, these nodes are very inexpensive to create, and the
          actual AudioBuffers can be reused for multiple plays of the sound. Indeed, you can use these nodes in a
          "fire and forget" manner: create the node, call start() to begin playing the sound, and don't even bother to
          hold a reference to it. It will automatically be garbage-collected at an appropriate time, which won't be
          until sometime after the sound has finished playing.
      */
    /**
     * Creates a new sound from the key of a loaded audio file
     * @param key The key of the loaded audio file to create a new sound for
     * @returns The newly created AudioBuffer
     */
    createSound(key, holdReference, channel, options) {
        // Get audio buffer
        let buffer = ResourceManager_1.default.getInstance().getAudio(key);
        // Create a sound source
        var source = this.audioCtx.createBufferSource();
        // Tell the source which sound to play
        source.buffer = buffer;
        // Add any additional nodes
        const nodes = [source];
        // Do any additional nodes here?
        // Of course, there aren't any supported yet...
        // Add the gain node for this channel
        nodes.push(this.gainNodes[channel]);
        // Connect any nodes along the path
        for (let i = 1; i < nodes.length; i++) {
            nodes[i - 1].connect(nodes[i]);
        }
        // Connect the source to the context's destination
        nodes[nodes.length - 1].connect(this.audioCtx.destination);
        return source;
    }
    /**
     * Play the sound specified by the key
     * @param key The key of the sound to play
     * @param loop A boolean for whether or not to loop the sound
     * @param holdReference A boolean for whether or not we want to hold on to a reference of the audio node. This is good for playing music on a loop that will eventually need to be stopped.
     */
    playSound(key, loop, holdReference, channel, options) {
        let sound = this.createSound(key, holdReference, channel, options);
        if (loop) {
            sound.loop = true;
        }
        // Add a reference of the new sound to a map. This will allow us to stop a looping or long sound at a later time
        if (holdReference) {
            this.currentSounds.add(key, sound);
        }
        sound.start();
    }
    /**
     * Stop the sound specified by the key
     */
    stopSound(key) {
        let sound = this.currentSounds.get(key);
        if (sound) {
            sound.stop();
            this.currentSounds.delete(key);
        }
    }
    muteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(0, this.audioCtx.currentTime);
    }
    unmuteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(1, this.audioCtx.currentTime);
    }
    /**
     * Sets the volume of a channel using the GainNode for that channel. For more
     * information on GainNodes, see https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * @param channel The audio channel to set the volume for
     * @param volume The volume of the channel. 0 is muted. Values below zero will be set to zero.
     */
    static setVolume(channel, volume) {
        if (volume < 0) {
            volume = 0;
        }
        const am = AudioManager.getInstance();
        am.gainNodes[channel].gain.setValueAtTime(volume, am.audioCtx.currentTime);
    }
    /**
     * Returns the GainNode for this channel.
     * Learn more about GainNodes here https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * DON'T USE THIS UNLESS YOU KNOW WHAT YOU'RE DOING
     * @param channel The channel
     * @returns The GainNode for the specified channel
     */
    getChannelGainNode(channel) {
        return this.gainNodes[channel];
    }
    update(deltaT) {
        // Play each audio clip requested
        // TODO - Add logic to merge sounds if there are multiple of the same key
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            if (event.type === GameEventType_1.GameEventType.PLAY_SOUND ||
                event.type === GameEventType_1.GameEventType.PLAY_MUSIC ||
                event.type === GameEventType_1.GameEventType.PLAY_SFX) {
                let soundKey = event.data.get("key");
                let loop = event.data.get("loop");
                let holdReference = event.data.get("holdReference");
                let channel = AudioChannelType.DEFAULT;
                if (event.type === GameEventType_1.GameEventType.PLAY_MUSIC) {
                    channel = AudioChannelType.MUSIC;
                }
                else if (GameEventType_1.GameEventType.PLAY_SFX) {
                    channel = AudioChannelType.SFX;
                }
                else if (event.data.has("channel")) {
                    channel = event.data.get("channel");
                }
                this.playSound(soundKey, loop, holdReference, channel, event.data);
            }
            if (event.type === GameEventType_1.GameEventType.STOP_SOUND) {
                let soundKey = event.data.get("key");
                this.stopSound(soundKey);
            }
            if (event.type === GameEventType_1.GameEventType.MUTE_CHANNEL) {
                this.muteChannel(event.data.get("channel"));
            }
            if (event.type === GameEventType_1.GameEventType.UNMUTE_CHANNEL) {
                this.unmuteChannel(event.data.get("channel"));
            }
        }
    }
}
exports.default = AudioManager;
var AudioChannelType;
(function (AudioChannelType) {
    AudioChannelType[AudioChannelType["DEFAULT"] = 0] = "DEFAULT";
    AudioChannelType[AudioChannelType["SFX"] = 1] = "SFX";
    AudioChannelType[AudioChannelType["MUSIC"] = 2] = "MUSIC";
    AudioChannelType[AudioChannelType["CUSTOM_1"] = 3] = "CUSTOM_1";
    AudioChannelType[AudioChannelType["CUSTOM_2"] = 4] = "CUSTOM_2";
    AudioChannelType[AudioChannelType["CUSTOM_3"] = 5] = "CUSTOM_3";
    AudioChannelType[AudioChannelType["CUSTOM_4"] = 6] = "CUSTOM_4";
    AudioChannelType[AudioChannelType["CUSTOM_5"] = 7] = "CUSTOM_5";
    AudioChannelType[AudioChannelType["CUSTOM_6"] = 8] = "CUSTOM_6";
    AudioChannelType[AudioChannelType["CUSTOM_7"] = 9] = "CUSTOM_7";
    AudioChannelType[AudioChannelType["CUSTOM_8"] = 10] = "CUSTOM_8";
    AudioChannelType[AudioChannelType["CUSTOM_9"] = 11] = "CUSTOM_9";
})(AudioChannelType = exports.AudioChannelType || (exports.AudioChannelType = {}));
exports.MAX_AUDIO_CHANNELS = 12;
},{"../DataTypes/Map":43,"../Events/GameEventType":62,"../Events/Receiver":63,"../ResourceManager/ResourceManager":115}],129:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimerState = void 0;
const MathUtils_1 = require("../Utils/MathUtils");
const TimerManager_1 = require("./TimerManager");
/** */
class Timer {
    constructor(time, onEnd, loop = false) {
        // Register this timer
        TimerManager_1.default.getInstance().addTimer(this);
        this.totalTime = time;
        this.timeLeft = 0;
        this.onEnd = onEnd;
        this.loop = loop;
        this.state = TimerState.STOPPED;
        this.numRuns = 0;
    }
    isStopped() {
        return this.state === TimerState.STOPPED;
    }
    isPaused() {
        return this.state === TimerState.PAUSED;
    }
    /**
     * Returns whether or not this timer has been run before
     * @returns true if it has been run at least once (after the latest reset), and false otherwise
     */
    hasRun() {
        return this.numRuns > 0;
    }
    start(time) {
        if (time !== undefined) {
            this.totalTime = time;
        }
        this.state = TimerState.ACTIVE;
        this.timeLeft = this.totalTime;
    }
    /** Resets this timer. Sets the progress back to zero, and sets the number of runs back to zero */
    reset() {
        this.timeLeft = this.totalTime;
        this.numRuns = 0;
    }
    pause() {
        this.state = TimerState.PAUSED;
    }
    update(deltaT) {
        if (this.state === TimerState.ACTIVE) {
            this.timeLeft -= deltaT * 1000;
            if (this.timeLeft <= 0) {
                this.timeLeft = MathUtils_1.default.clampLow0(this.timeLeft);
                this.end();
            }
        }
    }
    end() {
        // Update the state
        this.state = TimerState.STOPPED;
        this.numRuns += 1;
        // Call the end function if there is one
        if (this.onEnd) {
            this.onEnd();
        }
        // Loop if we want to
        if (this.loop) {
            this.state = TimerState.ACTIVE;
            this.timeLeft = this.totalTime;
        }
    }
    toString() {
        return ("Timer: " +
            this.state +
            " - Time Left: " +
            this.timeLeft +
            "ms of " +
            this.totalTime +
            "ms");
    }
}
exports.default = Timer;
var TimerState;
(function (TimerState) {
    TimerState["ACTIVE"] = "ACTIVE";
    TimerState["PAUSED"] = "PAUSED";
    TimerState["STOPPED"] = "STOPPED";
})(TimerState = exports.TimerState || (exports.TimerState = {}));
},{"../Utils/MathUtils":134,"./TimerManager":130}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TimerManager {
    constructor() {
        this.timers = new Array();
    }
    static getInstance() {
        if (!this.instance) {
            this.instance = new TimerManager();
        }
        return this.instance;
    }
    addTimer(timer) {
        this.timers.push(timer);
    }
    clearTimers() {
        this.timers = new Array();
    }
    update(deltaT) {
        this.timers.forEach(timer => timer.update(deltaT));
    }
}
exports.default = TimerManager;
},{}],131:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("./MathUtils");
// TODO: This should be moved to the datatypes folder
/**
 * A Color util class that keeps track of colors like a vector, but can be converted into a string format
 */
class Color {
    /**
     * Creates a new color
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    constructor(r = 0, g = 0, b = 0, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Transparent color
     * @returns rgba(0, 0, 0, 0)
     */
    static get TRANSPARENT() {
        return new Color(0, 0, 0, 0);
    }
    /**
     * Red color
     * @returns rgb(255, 0, 0)
     */
    static get RED() {
        return new Color(255, 0, 0, 1);
    }
    /**
     * Green color
     * @returns rgb(0, 255, 0)
     */
    static get GREEN() {
        return new Color(0, 255, 0, 1);
    }
    /**
     * Blue color
     * @returns rgb(0, 0, 255)
     */
    static get BLUE() {
        return new Color(0, 0, 255, 1);
    }
    /**
     * Yellow color
     * @returns rgb(255, 255, 0)
     */
    static get YELLOW() {
        return new Color(255, 255, 0, 1);
    }
    /**
     * Magenta color
     * @returns rgb(255, 0, 255)
     */
    static get MAGENTA() {
        return new Color(255, 0, 255, 1);
    }
    /**
     * Cyan color
     * @returns rgb(0, 255, 255)
     */
    static get CYAN() {
        return new Color(0, 255, 255, 1);
    }
    /**
     * White color
     * @returns rgb(255, 255, 255)
     */
    static get WHITE() {
        return new Color(255, 255, 255, 1);
    }
    /**
     * Black color
     * @returns rgb(0, 0, 0)
     */
    static get BLACK() {
        return new Color(0, 0, 0, 1);
    }
    /**
     * Orange color
     * @returns rgb(255, 100, 0)
     */
    static get ORANGE() {
        return new Color(255, 100, 0, 1);
    }
    /**
     * Sets the color to the values provided
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    set(r, g, b, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Returns a new color slightly lighter than the current color
     * @returns A new lighter Color
     */
    lighten() {
        return new Color(MathUtils_1.default.clamp(this.r + 40, 0, 255), MathUtils_1.default.clamp(this.g + 40, 0, 255), MathUtils_1.default.clamp(this.b + 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns a new color slightly darker than the current color
     * @returns A new darker Color
     */
    darken() {
        return new Color(MathUtils_1.default.clamp(this.r - 40, 0, 255), MathUtils_1.default.clamp(this.g - 40, 0, 255), MathUtils_1.default.clamp(this.b - 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns this color as an array
     * @returns [r, g, b, a]
     */
    toArray() {
        return [this.r, this.g, this.b, this.a];
    }
    /**
     * Returns the color as a string of the form #RRGGBB
     * @returns #RRGGBB
     */
    toString() {
        return ("#" +
            MathUtils_1.default.toHex(this.r, 2) +
            MathUtils_1.default.toHex(this.g, 2) +
            MathUtils_1.default.toHex(this.b, 2));
    }
    /**
     * Returns the color as a string of the form rgb(r, g, b)
     * @returns rgb(r, g, b)
     */
    toStringRGB() {
        return ("rgb(" +
            this.r.toString() +
            ", " +
            this.g.toString() +
            ", " +
            this.b.toString() +
            ")");
    }
    /**
     * Returns the color as a string of the form rgba(r, g, b, a)
     * @returns rgba(r, g, b, a)
     */
    toStringRGBA() {
        if (this.a === 0) {
            return this.toStringRGB();
        }
        return ("rgba(" +
            this.r.toString() +
            ", " +
            this.g.toString() +
            ", " +
            this.b.toString() +
            ", " +
            this.a.toString() +
            ")");
    }
    /**
     * Turns this color into a float32Array and changes color range to [0.0, 1.0]
     * @returns a Float32Array containing the color
     */
    toWebGL() {
        return new Float32Array([this.r / 255, this.g / 255, this.b / 255, this.a]);
    }
    static fromStringHex(str) {
        let i = 0;
        if (str.charAt(0) == "#")
            i += 1;
        let r = MathUtils_1.default.fromHex(str.substring(i, i + 2));
        let g = MathUtils_1.default.fromHex(str.substring(i + 2, i + 4));
        let b = MathUtils_1.default.fromHex(str.substring(i + 4, i + 6));
        return new Color(r, g, b);
    }
}
exports.default = Color;
},{"./MathUtils":134}],132:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.EaseFunctionType = void 0;
class EaseFunctions {
    static easeInOutSine(x) {
        return -(Math.cos(Math.PI * x) - 1) / 2;
    }
    static easeOutInSine(x) {
        return x < 0.5
            ? -Math.cos(Math.PI * (x + 0.5)) / 2
            : -Math.cos(Math.PI * (x - 0.5)) / 2 + 1;
    }
    static easeOutSine(x) {
        return Math.sin((x * Math.PI) / 2);
    }
    static easeInSine(x) {
        return 1 - Math.cos((x * Math.PI) / 2);
    }
    static easeInOutQuint(x) {
        return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
    }
    static easeInOutQuad(x) {
        return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
    }
    static easeOutInQuad(x) {
        return x < 0.5 ? this.easeOutIn_OutPow(x, 2) : this.easeOutIn_InPow(x, 2);
    }
    static easeOutIn_OutPow(x, pow) {
        return 0.5 - Math.pow(-2 * x + 1, pow) / 2;
    }
    static easeOutIn_InPow(x, pow) {
        return 0.5 + Math.pow(2 * x - 1, pow) / 2;
    }
}
exports.default = EaseFunctions;
var EaseFunctionType;
(function (EaseFunctionType) {
    // SINE
    EaseFunctionType["IN_OUT_SINE"] = "easeInOutSine";
    EaseFunctionType["OUT_IN_SINE"] = "easeOutInSine";
    EaseFunctionType["IN_SINE"] = "easeInSine";
    EaseFunctionType["OUT_SINE"] = "easeOutSine";
    // QUAD
    EaseFunctionType["IN_OUT_QUAD"] = "easeInOutQuad";
    EaseFunctionType["OUT_IN_QUAD"] = "easeOutInQuad";
    // QUINT
    EaseFunctionType["IN_OUT_QUINT"] = "easeInOutQuint";
})(EaseFunctionType = exports.EaseFunctionType || (exports.EaseFunctionType = {}));
},{}],133:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class to provides some utility functions for graphs */
class GraphUtils {
    /**
     * An implementation of Djikstra's shortest path algorithm based on the one described in The Algorithm Design Manual.
     * @param g The graph
     * @param start The number to start the shortest path from
     * @returns An array containing the parent of each node of the Graph in the shortest path.
     */
    static djikstra(g, start) {
        let i; // Counter
        let p; // Pointer to edgenode
        let inTree = new Array(g.numVertices);
        let distance = new Array(g.numVertices);
        let parent = new Array(g.numVertices);
        let v; // Current vertex to process
        let w; // Candidate for next vertex
        let weight; // Edge weight
        let dist; // Best current distance from start
        for (i = 0; i < g.numVertices; i++) {
            inTree[i] = false;
            distance[i] = Infinity;
            parent[i] = -1;
        }
        distance[start] = 0;
        v = start;
        while (!inTree[v]) {
            inTree[v] = true;
            p = g.edges[v];
            while (p !== null) {
                w = p.y;
                weight = p.weight;
                if (distance[w] > distance[v] + weight) {
                    distance[w] = distance[v] + weight;
                    parent[w] = v;
                }
                p = p.next;
            }
            v = 0;
            dist = Infinity;
            for (i = 0; i <= g.numVertices; i++) {
                if (!inTree[i] && dist > distance[i]) {
                    dist = distance;
                    v = i;
                }
            }
        }
        return parent;
    }
}
exports.default = GraphUtils;
},{}],134:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class containing some utility functions for math operations */
class MathUtils {
    /**
     * Returns the sign of the value provided
     * @param x The value to extract the sign from
     * @returns -1 if the number is less than 0, 1 otherwise
     */
    static sign(x) {
        return x < 0 ? -1 : 1;
    }
    /**
     * Returns whether or not x is between a and b
     * @param a The min bound
     * @param b The max bound
     * @param x The value to check
     * @param exclusive Whether or not a and b are exclusive bounds
     * @returns True if x is between a and b, false otherwise
     */
    static between(a, b, x, exclusive) {
        if (exclusive) {
            return a < x && x < b;
        }
        else {
            return a <= x && x <= b;
        }
    }
    /**
     * Clamps the value x to the range [min, max], rounding up or down if needed
     * @param x The value to be clamped
     * @param min The min of the range
     * @param max The max of the range
     * @returns x, if it is between min and max, or min/max if it exceeds their bounds
     */
    static clamp(x, min, max) {
        if (x < min)
            return min;
        if (x > max)
            return max;
        return x;
    }
    /**
     * Clamps the value x to the range between 0 and 1
     * @param x The value to be clamped
     * @returns x, if it is between 0 and 1, or 0/1 if it exceeds their bounds
     */
    static clamp01(x) {
        return MathUtils.clamp(x, 0, 1);
    }
    /**
     * Clamps the lower end of the value of x to the range to min
     * @param x The value to be clamped
     * @param min The minimum allowed value of x
     * @returns x, if it is greater than min, otherwise min
     */
    static clampLow(x, min) {
        return x < min ? min : x;
    }
    /**
     * Clamps the lower end of the value of x to zero
     * @param x The value to be clamped
     * @returns x, if it is greater than 0, otherwise 0
     */
    static clampLow0(x) {
        return MathUtils.clampLow(x, 0);
    }
    static clampMagnitude(v, m) {
        if (v.magSq() > m * m) {
            return v.scaleTo(m);
        }
        else {
            return v;
        }
    }
    static changeRange(x, min, max, newMin, newMax) {
        return this.lerp(newMin, newMax, this.invLerp(min, max, x));
    }
    /**
     * Linear Interpolation
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param t The time we are interpolating to
     * @returns The value between a and b at time t
     */
    static lerp(a, b, t) {
        return a + t * (b - a);
    }
    /**
     * Inverse Linear Interpolation. Finds the time at which a value between a and b would occur
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param value The current value
     * @returns The time at which the current value occurs between a and b
     */
    static invLerp(a, b, value) {
        return (value - a) / (b - a);
    }
    /**
     * Cuts off decimal points of a number after a specified place
     * @param num The number to floor
     * @param place The last decimal place of the new number
     * @returns The floored number
     */
    static floorToPlace(num, place) {
        if (place === 0) {
            return Math.floor(num);
        }
        let factor = 10;
        while (place > 1) {
            factor != 10;
            place--;
        }
        return Math.floor(num * factor) / factor;
    }
    /**
     * Returns a number from a hex string
     * @param str the string containing the hex number
     * @returns the number in decimal represented by the hex string
     */
    static fromHex(str) {
        return parseInt(str, 16);
    }
    /**
     * Returns the number as a hexadecimal
     * @param num The number to convert to hex
     * @param minLength The length of the returned hex string (adds zero padding if needed)
     * @returns The hex representation of the number as a string
     */
    static toHex(num, minLength = null) {
        let factor = 1;
        while (factor * 16 < num) {
            factor *= 16;
        }
        let hexStr = "";
        while (factor >= 1) {
            let digit = Math.floor(num / factor);
            hexStr += MathUtils.toHexDigit(digit);
            num -= digit * factor;
            factor /= 16;
        }
        if (minLength !== null) {
            while (hexStr.length < minLength) {
                hexStr = "0" + hexStr;
            }
        }
        return hexStr;
    }
    /**
     * Converts a digit to hexadecimal. In this case, a digit is between 0 and 15 inclusive
     * @param num The digit to convert to hexadecimal
     * @returns The hex representation of the digit as a string
     */
    static toHexDigit(num) {
        if (num < 10) {
            return "" + num;
        }
        else {
            return String.fromCharCode(65 + num - 10);
        }
    }
}
exports.default = MathUtils;
},{}],135:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("./MathUtils");
class RenderingUtils {
    static toWebGLCoords(point, origin, worldSize) {
        return new Float32Array([
            MathUtils_1.default.changeRange(point.x, origin.x, origin.x + worldSize.x, -1, 1),
            MathUtils_1.default.changeRange(point.y, origin.y, origin.y + worldSize.y, 1, -1),
        ]);
    }
    static toWebGLScale(size, worldSize) {
        return new Float32Array([
            (2 * size.x) / worldSize.x,
            (2 * size.y) / worldSize.y,
        ]);
    }
    static toWebGLColor(color) {
        return new Float32Array([
            MathUtils_1.default.changeRange(color.r, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.g, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.b, 0, 255, 0, 1),
            color.a,
        ]);
    }
}
exports.default = RenderingUtils;
},{"./MathUtils":134}],136:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** Some utility functions for dealing with strings */
class StringUtils {
    /**
     * Extracts the path from a filepath that includes the file
     * @param filePath the filepath to extract the path from
     * @returns The path portion of the filepath provided
     */
    static getPathFromFilePath(filePath) {
        let splitPath = filePath.split("/");
        splitPath.pop();
        splitPath.push("");
        return splitPath.join("/");
    }
}
exports.default = StringUtils;
},{}],137:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpriteSizes = exports.PhysicsGroups = exports.Events = exports.Action = void 0;
const Vec2_1 = require("./Wolfie2D/DataTypes/Vec2");
var Action;
(function (Action) {
    Action["Left"] = "left";
    Action["Right"] = "right";
    Action["Jump"] = "jump";
    Action["Attack"] = "attack";
    Action["Dash"] = "dash";
    Action["Pause"] = "pause";
    Action["Up"] = "up";
    Action["Down"] = "down";
})(Action = exports.Action || (exports.Action = {}));
exports.Events = {
    MAIN_MENU: "MAIN_MENU",
    PLAYER_DAMAGE: "PLAYER_DAMAGE",
    PLAYER_HEAL: "PLAYER_HEAL",
    PLAYER_DEATH: "PLAYER_DEATH",
    ENEMY_DEATH: "ENEMY_DEATH",
    ENEMY_DAMAGE: "ENEMY_DAMAGE",
    LEVEL_END: "LEVEL_END",
    ENTER_LEVEL_END: "ENTER_LEVEL_END",
};
exports.PhysicsGroups = {
    PLAYER_PHYS: "PLAYER_PHYS",
    ENEMY_PHYS: "ENEMY_PHYS",
    HITBOX_PHYS: "HITBOX_PHYS",
};
exports.SpriteSizes = {
    SOUL: new Vec2_1.default(18, 24),
    PLAYER: new Vec2_1.default(18, 24),
};
},{"./Wolfie2D/DataTypes/Vec2":56}],138:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Game_1 = require("./Wolfie2D/Loop/Game");
const MainMenu_1 = require("./Autopsy/Scenes/MainMenu");
const globals_1 = require("./globals");
// The main function is your entrypoint into Wolfie2D. Specify your first scene and any options here.
(function main() {
    // Run any tests
    runTests();
    // Set up options for our game
    let options = {
        canvasSize: { x: 1200, y: 800 },
        clearColor: { r: 34, g: 28, b: 41 },
        inputs: [
            { name: globals_1.Action.Left, keys: ["a"] },
            { name: globals_1.Action.Right, keys: ["d"] },
            { name: globals_1.Action.Up, keys: ["w"] },
            { name: globals_1.Action.Down, keys: ["s"] },
            { name: globals_1.Action.Jump, keys: ["space"] },
            { name: globals_1.Action.Attack, keys: ["j"] },
            { name: globals_1.Action.Dash, keys: ["shift"] },
            { name: globals_1.Action.Pause, keys: ["escape"] },
        ],
        useWebGL: false,
        showDebug: false,
    };
    // Create a game with the options specified
    const game = new Game_1.default(options);
    // Start our game
    game.start(MainMenu_1.default, {});
})();
function runTests() { }
},{"./Autopsy/Scenes/MainMenu":35,"./Wolfie2D/Loop/Game":68,"./globals":137}]},{},[138])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvQXV0b3BzeS9DYW1lcmEudHMiLCJzcmMvQXV0b3BzeS9FbmVteS9HaG9zdC9HaG9zdC50cyIsInNyYy9BdXRvcHN5L0VuZW15L0dob3N0L0dob3N0Q29udHJvbGxlci50cyIsInNyYy9BdXRvcHN5L0VuZW15L0dob3N0L0dob3N0U3RhdGVzL0RyaWZ0aW5nLnRzIiwic3JjL0F1dG9wc3kvRW5lbXkvR2hvc3QvR2hvc3RTdGF0ZXMvRm9sbG93aW5nLnRzIiwic3JjL0F1dG9wc3kvRW5lbXkvR2hvc3QvR2hvc3RTdGF0ZXMvR2hvc3RTdGF0ZS50cyIsInNyYy9BdXRvcHN5L0VuZW15L0dob3N0L0dob3N0U3RhdGVzL0tub2NrYmFjay50cyIsInNyYy9BdXRvcHN5L0hpdGJveC9EYW1hZ2VUeXBlLnRzIiwic3JjL0F1dG9wc3kvSGl0Ym94L0hpdGJveC50cyIsInNyYy9BdXRvcHN5L0hpdGJveC9IaXRib3hDb250cm9sbGVyLnRzIiwic3JjL0F1dG9wc3kvSGl0Ym94L0hpdGJveFN0YXRlcy9BY3RpdmUudHMiLCJzcmMvQXV0b3BzeS9IaXRib3gvSGl0Ym94U3RhdGVzL0hpdGJveFN0YXRlLnRzIiwic3JjL0F1dG9wc3kvSGl0Ym94L0hpdGJveFN0YXRlcy9NYW5hZ2VIaXRib3gudHMiLCJzcmMvQXV0b3BzeS9QbGF5ZXIvUGxheWVyLnRzIiwic3JjL0F1dG9wc3kvUGxheWVyL1N0YXRlcy9BY3Rpb25zL0F0dGFjay50cyIsInNyYy9BdXRvcHN5L1BsYXllci9TdGF0ZXMvQWN0aW9ucy9BdHRhY2tEb3duLnRzIiwic3JjL0F1dG9wc3kvUGxheWVyL1N0YXRlcy9BY3Rpb25zL0F0dGFja1VwcGVyLnRzIiwic3JjL0F1dG9wc3kvUGxheWVyL1N0YXRlcy9BY3Rpb25zL0Rhc2hpbmcudHMiLCJzcmMvQXV0b3BzeS9QbGF5ZXIvU3RhdGVzL0FjdGlvbnMvSWRsZS50cyIsInNyYy9BdXRvcHN5L1BsYXllci9TdGF0ZXMvQWN0aW9ucy9KdW1wLnRzIiwic3JjL0F1dG9wc3kvUGxheWVyL1N0YXRlcy9BY3Rpb25zL1BsYXllckFjdGlvblN0YXRlLnRzIiwic3JjL0F1dG9wc3kvUGxheWVyL1N0YXRlcy9Nb3ZlbWVudC9Bc2NlbmRpbmcudHMiLCJzcmMvQXV0b3BzeS9QbGF5ZXIvU3RhdGVzL01vdmVtZW50L0Rlc2NlbmRpbmcudHMiLCJzcmMvQXV0b3BzeS9QbGF5ZXIvU3RhdGVzL01vdmVtZW50L0dyb3VuZGVkLnRzIiwic3JjL0F1dG9wc3kvUGxheWVyL1N0YXRlcy9Nb3ZlbWVudC9JbkFpci50cyIsInNyYy9BdXRvcHN5L1BsYXllci9TdGF0ZXMvTW92ZW1lbnQvUGxheWVyTW92ZW1lbnRTdGF0ZS50cyIsInNyYy9BdXRvcHN5L1BsYXllci9TdGF0ZXMvUGxheWVyU3RhdGUudHMiLCJzcmMvQXV0b3BzeS9TY2VuZXMvR2FtZUxldmVsLnRzIiwic3JjL0F1dG9wc3kvU2NlbmVzL0xldmVsMS50cyIsInNyYy9BdXRvcHN5L1NjZW5lcy9MZXZlbDIudHMiLCJzcmMvQXV0b3BzeS9TY2VuZXMvTGV2ZWwzLnRzIiwic3JjL0F1dG9wc3kvU2NlbmVzL0xldmVsNC50cyIsInNyYy9BdXRvcHN5L1NjZW5lcy9MZXZlbDUudHMiLCJzcmMvQXV0b3BzeS9TY2VuZXMvTGV2ZWw2LnRzIiwic3JjL0F1dG9wc3kvU2NlbmVzL01haW5NZW51LnRzIiwic3JjL1dvbGZpZTJEL0FJL0FJTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9BSS9TdGF0ZU1hY2hpbmVBSS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvRnVuY3Rpb25zL051bGxGdW5jLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9HcmFwaHMvRWRnZU5vZGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0dyYXBocy9HcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGgudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvUmVnaW9uLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9NYXAudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL01hdDR4NC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvUGh5c2ljcy9BcmVhQ29sbGlzaW9uLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9QaHlzaWNzL0hpdC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvUXVldWUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1JlbmRlcmluZy9XZWJHTFByb2dyYW1UeXBlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQUFCQi50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0NpcmNsZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL1NoYXBlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TdGFjay50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhdGUvU3RhdGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1N0YXRlL1N0YXRlTWFjaGluZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMi50cyIsInNyYy9Xb2xmaWUyRC9EZWJ1Zy9EZWJ1Zy50cyIsInNyYy9Xb2xmaWUyRC9EZWJ1Zy9TdGF0cy50cyIsInNyYy9Xb2xmaWUyRC9FdmVudHMvRW1pdHRlci50cyIsInNyYy9Xb2xmaWUyRC9FdmVudHMvRXZlbnRRdWV1ZS50cyIsInNyYy9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50LnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRUeXBlLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9SZWNlaXZlci50cyIsInNyYy9Xb2xmaWUyRC9JbnB1dC9JbnB1dC50cyIsInNyYy9Xb2xmaWUyRC9JbnB1dC9JbnB1dEhhbmRsZXIudHMiLCJzcmMvV29sZmllMkQvTG9vcC9FbnZpcm9ubWVudEluaXRpYWxpemVyLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvRml4ZWRVcGRhdGVHYW1lTG9vcC50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0dhbWUudHMiLCJzcmMvV29sZmllMkQvTG9vcC9HYW1lTG9vcC50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0dhbWVPcHRpb25zLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0NhbnZhc05vZGUudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvR2FtZU5vZGUudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvR3JhcGhpYy50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXMudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvTGluZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9QYXJ0aWNsZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9Qb2ludC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9SZWN0LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGUudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvU3ByaXRlcy9TcHJpdGUudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVGlsZW1hcC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnQudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9CdXR0b24udHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1NsaWRlci50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzLnRzIiwic3JjL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoLnRzIiwic3JjL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdm1lc2gudHMiLCJzcmMvV29sZmllMkQvUGh5c2ljcy9CYXNpY1BoeXNpY3NNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1BoeXNpY3MvUGh5c2ljc01hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUGxheWJhY2svUmVjb3JkZXIudHMiLCJzcmMvV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cmllcy9SZWdpc3RyeS50cyIsInNyYy9Xb2xmaWUyRC9SZWdpc3RyeS9SZWdpc3RyaWVzL1NoYWRlclJlZ2lzdHJ5LnRzIiwic3JjL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJ5TWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQW5pbWF0aW9ucy9BbmltYXRpb25NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL0FuaW1hdGlvblR5cGVzLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL1BhcnRpY2xlU3lzdGVtTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQW5pbWF0aW9ucy9Ud2VlbkNvbnRyb2xsZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9DYW52YXNSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyaW5nL0dyYXBoaWNSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyaW5nL1RpbGVtYXBSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyaW5nL1VJRWxlbWVudFJlbmRlcmVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9SZW5kZXJpbmdNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9MYWJlbFNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1BvaW50U2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvUXVhZFNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1JlY3RTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9TcHJpdGVTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmVHcmFwaC9TY2VuZUdyYXBoLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lR3JhcGgvU2NlbmVHcmFwaEFycmF5LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lR3JhcGgvVmlld3BvcnQudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvRmFjdG9yaWVzL0NhbnZhc05vZGVGYWN0b3J5LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0ZhY3Rvcmllcy9GYWN0b3J5TWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9GYWN0b3JpZXMvVGlsZW1hcEZhY3RvcnkudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvTGF5ZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvTGF5ZXJzL1BhcmFsbGF4TGF5ZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvTGF5ZXJzL1VJTGF5ZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvU2NlbmUudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvU2NlbmVNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL1NjZW5lT3B0aW9ucy50cyIsInNyYy9Xb2xmaWUyRC9Tb3VuZC9BdWRpb01hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvVGltaW5nL1RpbWVyLnRzIiwic3JjL1dvbGZpZTJEL1RpbWluZy9UaW1lck1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvQ29sb3IudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvRWFzZUZ1bmN0aW9ucy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9HcmFwaFV0aWxzLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL01hdGhVdGlscy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9SZW5kZXJpbmdVdGlscy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9TdHJpbmdVdGlscy50cyIsInNyYy9nbG9iYWxzLnRzIiwic3JjL21haW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0lBLDJEQUFvRDtBQUVwRCxNQUFxQixNQUFNO0lBS3pCLFlBQVksS0FBWSxFQUFFLE1BQVk7UUFDcEMsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDbEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7SUFDdkIsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFjO1FBQ25CLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEUsSUFDRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFL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T0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLO1lBQ2hILElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUs7WUFDaEgsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSztZQUNsSCxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENB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RyxFQUFFLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsRUFBRSxJQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ2pFLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUVsQixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7UUFDN0IsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO1FBQ2YsSUFBSSxLQUFLLEdBQ1AsSUFBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ3pFLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztRQUU3QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNyQyxJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkIsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7WUFDOUQsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQzFFLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDckIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxN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Y2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi9Xb2xmaWUyRC9VdGlscy9NYXRoVXRpbHNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbWVyYSBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG4gIG5vZGU6IEdhbWVOb2RlO1xyXG4gIHByaXZhdGUgZm9sbG93aW5nOiBHYW1lTm9kZTtcclxuICBvZmZzZXQ6IFZlYzI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHBvaW50OiBQb2ludCwgb2Zmc2V0OiBWZWMyKSB7XHJcbiAgICB0aGlzLm5vZGUgPSBwb2ludDtcclxuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBjb25zdCBvZmZzZXRGb2xsb3cgPSB0aGlzLmZvbGxvd2luZy5wb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XHJcbiAgICBpZiAoXHJcbiAgICAgIE1hdGguYWJzKHRoaXMubm9kZS5wb3NpdGlvbi55IC0gdGhpcy5mb2xsb3dpbmcucG9zaXRpb24uY2xvbmUoKS55KSA+XHJcbiAgICAgIE1hdGguYWJzKHRoaXMub2Zmc2V0LnkpXHJcbiAgICApXHJcbiAgICAgIHRoaXMubm9kZS5wb3NpdGlvbi55ID0gTWF0aFV0aWxzLmxlcnAoXHJcbiAgICAgICAgdGhpcy5ub2RlLnBvc2l0aW9uLnksXHJcbiAgICAgICAgb2Zmc2V0Rm9sbG93LnksXHJcbiAgICAgICAgMiAqIGRlbHRhVCxcclxuICAgICAgKTtcclxuXHJcbiAgICB0aGlzLm5vZGUucG9zaXRpb24ueCA9IG9mZnNldEZvbGxvdy54O1xyXG4gIH1cclxuXHJcbiAgZm9sbG93KG5vZGU6IEdhbWVOb2RlKSB7XHJcbiAgICB0aGlzLmZvbGxvd2luZyA9IG5vZGU7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgR2hvc3RDb250cm9sbGVyIGZyb20gXCIuL0dob3N0Q29udHJvbGxlclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IHsgUGh5c2ljc0dyb3VwcywgU3ByaXRlU2l6ZXMgfSBmcm9tIFwiLi4vLi4vLi4vZ2xvYmFsc1wiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBIaXRib3ggZnJvbSBcIi4uLy4uL0hpdGJveC9IaXRib3hcIjtcclxuaW1wb3J0IHsgRGFtYWdlVHlwZSB9IGZyb20gXCIuLi8uLi9IaXRib3gvRGFtYWdlVHlwZVwiO1xyXG5pbXBvcnQgeyBMYXllcnMgfSBmcm9tIFwiLi4vLi4vU2NlbmVzL0dhbWVMZXZlbFwiO1xyXG5cclxuZXhwb3J0IGVudW0gR2hvc3RUeXBlIHtcclxuICBSRUQgPSBcInJlZFwiLFxyXG4gIEJMVUUgPSBcImJsdWVcIixcclxufVxyXG5cclxuZXhwb3J0IGVudW0gR2hvc3RBbmltYXRpb25zIHtcclxuICBJZGxlID0gXCJJZGxlXCIsXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdob3N0IHtcclxuICBoaXRib3g6IEhpdGJveDtcclxuICBub2RlOiBBbmltYXRlZFNwcml0ZTtcclxuICBoZWFsdGg6IG51bWJlcjtcclxuICB0eXBlOiBzdHJpbmc7IC8vIHJlZChIUCkgb3IgYmx1ZShNUClcclxuXHJcbiAgY29uc3RydWN0b3Ioc3ByaXRlOiBBbmltYXRlZFNwcml0ZSwgcG9zOiBWZWMyLCB0eXBlOiBzdHJpbmcpIHtcclxuICAgIHRoaXMubm9kZSA9IHNwcml0ZTtcclxuICAgIHRoaXMubm9kZS5hZGRQaHlzaWNzKFxyXG4gICAgICBuZXcgQUFCQihuZXcgVmVjMigwLCAwKSwgU3ByaXRlU2l6ZXMuU09VTCksXHJcbiAgICAgIG5ldyBWZWMyKDAsIDApLFxyXG4gICAgKTtcclxuICAgIHRoaXMubm9kZS5hZGRBSShHaG9zdENvbnRyb2xsZXIpO1xyXG4gICAgdGhpcy5ub2RlLnNldEdyb3VwKFBoeXNpY3NHcm91cHMuRU5FTVlfUEhZUyk7XHJcbiAgICB0aGlzLm5vZGUucG9zaXRpb24gPSBwb3M7XHJcbiAgICB0aGlzLm5vZGUuYW5pbWF0aW9uLnBsYXkoR2hvc3RBbmltYXRpb25zLklkbGUsIHRydWUpO1xyXG4gICAgdGhpcy5oZWFsdGggPSA1O1xyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFN0YXRlTWFjaGluZUFJIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9BSS9TdGF0ZU1hY2hpbmVBSVwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2hvc3RTdGF0ZSBmcm9tIFwiLi9HaG9zdFN0YXRlcy9HaG9zdFN0YXRlXCI7XHJcbmltcG9ydCBEcmlmdGluZyBmcm9tIFwiLi9HaG9zdFN0YXRlcy9EcmlmdGluZ1wiO1xyXG5pbXBvcnQgRm9sbG93aW5nIGZyb20gXCIuL0dob3N0U3RhdGVzL0ZvbGxvd2luZ1wiO1xyXG5pbXBvcnQgS25vY2tiYWNrIGZyb20gXCIuL0dob3N0U3RhdGVzL0tub2NrYmFja1wiO1xyXG5cclxuZXhwb3J0IGVudW0gR1N0YXRlIHtcclxuICBEcmlmdGluZyA9IFwiZHJpZnRpbmdcIixcclxuICBGb2xsb3dpbmcgPSBcImZvbGxvd2luZ1wiLFxyXG4gIEtub2NrYmFjayA9IFwia25vY2tiYWNrXCIsXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdob3N0Q29udHJvbGxlciBleHRlbmRzIFN0YXRlTWFjaGluZUFJIHtcclxuICBvd25lcjogR2FtZU5vZGU7XHJcbiAgLy9kaXJlY3Rpb25fb3AgPSBbbmV3IFZlYzIoMSwxKSxuZXcgVmVjMigxLC0xKSxuZXcgVmVjMigtMSwxKSxuZXcgVmVjMigtMSwtMSldXHJcbiAgZGlyZWN0aW9uOiBWZWMyID0gVmVjMi5aRVJPO1xyXG4gIHZlbG9jaXR5OiBWZWMyID0gVmVjMi5aRVJPO1xyXG4gIGRyaWZ0U3BlZWQgPSAxMDtcclxuICBmb2xsb3dTcGVlZCA9IDMwO1xyXG4gIGtub2NrYmFja1NwZWVkID0gMTUwO1xyXG4gIGdyYXZpdHkgPSAwO1xyXG5cclxuICBpbml0aWFsaXplQUkob3duZXI6IEdhbWVOb2RlLCBjb25maWc6IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcclxuICAgIHRoaXMub3duZXIgPSBvd25lcjtcclxuXHJcbiAgICB0aGlzLmRpcmVjdGlvbiA9IHRoaXMucmFuZG9tRGlyZWN0aW9uKCk7XHJcbiAgICB0aGlzLmluaXRpYWxpemVTdGF0ZXMoKTtcclxuICB9XHJcblxyXG4gIGluaXRpYWxpemVTdGF0ZXMoKSB7XHJcbiAgICB0aGlzLmFkZFN0YXRlKEdTdGF0ZS5EcmlmdGluZywgbmV3IERyaWZ0aW5nKHRoaXMsIHRoaXMub3duZXIpKTtcclxuICAgIHRoaXMuYWRkU3RhdGUoR1N0YXRlLkZvbGxvd2luZywgbmV3IEZvbGxvd2luZyh0aGlzLCB0aGlzLm93bmVyKSk7XHJcbiAgICB0aGlzLmFkZFN0YXRlKEdTdGF0ZS5Lbm9ja2JhY2ssIG5ldyBLbm9ja2JhY2sodGhpcywgdGhpcy5vd25lcikpO1xyXG5cclxuICAgIHRoaXMuaW5pdGlhbGl6ZShHU3RhdGUuRHJpZnRpbmcpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKSB7XHJcbiAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcclxuICAgIHRoaXMub3duZXIubW92ZSh0aGlzLnZlbG9jaXR5KTtcclxuICB9XHJcblxyXG4gIHJhbmRvbURpcmVjdGlvbigpIHtcclxuICAgIHJldHVybiBWZWMyLlVQLnJvdGF0ZUNDVyhNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHN0YXRlKCkge1xyXG4gICAgcmV0dXJuIDxHaG9zdFN0YXRlPnRoaXMuc3RhY2sucGVlaygpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgR2hvc3RTdGF0ZSBmcm9tIFwiLi9HaG9zdFN0YXRlXCI7XHJcbmltcG9ydCB7IEdTdGF0ZSB9IGZyb20gXCIuLi9HaG9zdENvbnRyb2xsZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERyaWZ0aW5nIGV4dGVuZHMgR2hvc3RTdGF0ZSB7XHJcbiAgb25FbnRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XHJcbiAgICB0aGlzLnBhcmVudC5kaXJlY3Rpb24gPSB0aGlzLnBhcmVudC5yYW5kb21EaXJlY3Rpb24oKTtcclxuICAgIHRoaXMuc3RhdGVOYW1lID0gXCJEcmlmdGluZ1wiO1xyXG4gICAgdGhpcy5jYW5Gb2xsb3cgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcikge1xyXG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgaWYgKHRoaXMud2l0aGluWEJsb2NrKDYpKSB0aGlzLmNhbkZvbGxvdyA9IHRydWU7XHJcblxyXG4gICAgaWYgKHRoaXMuY2FuRm9sbG93KSB7XHJcbiAgICAgIHRoaXMuZmluaXNoZWQoR1N0YXRlLkZvbGxvd2luZyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBhcmVudC52ZWxvY2l0eS54ID1cclxuICAgICAgICB0aGlzLnBhcmVudC5kaXJlY3Rpb24ueCAqIHRoaXMucGFyZW50LmRyaWZ0U3BlZWQgKiBkZWx0YVQ7XHJcbiAgICAgIHRoaXMucGFyZW50LnZlbG9jaXR5LnkgPVxyXG4gICAgICAgIHRoaXMucGFyZW50LmRpcmVjdGlvbi55ICogdGhpcy5wYXJlbnQuZHJpZnRTcGVlZCAqIGRlbHRhVDtcclxuXHJcbiAgICAgIHRoaXMub3duZXIubW92ZSh0aGlzLnBhcmVudC52ZWxvY2l0eSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICAvLyg8QW5pbWF0ZWRTcHJpdGU+dGhpcy5vd25lcikuYW5pbWF0aW9uLnN0b3AoKTtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IEdob3N0U3RhdGUgZnJvbSBcIi4vR2hvc3RTdGF0ZVwiO1xyXG5pbXBvcnQgeyBHU3RhdGUgfSBmcm9tIFwiLi4vR2hvc3RDb250cm9sbGVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb2xsb3dpbmcgZXh0ZW5kcyBHaG9zdFN0YXRlIHtcclxuICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcclxuICAgIHRoaXMuc3RhdGVOYW1lID0gXCJGb2xsb3dpbmdcIjtcclxuICAgIHRoaXMuc3R1Y2tUaW1lci5zdGFydCgpO1xyXG4gICAgdGhpcy5jYW5Gb2xsb3cgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKSB7XHJcbiAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICBpZiAoIXRoaXMud2l0aGluWEJsb2NrKDYpKSB0aGlzLmNhbkZvbGxvdyA9IGZhbHNlO1xyXG5cclxuICAgIGlmICghdGhpcy5jYW5Gb2xsb3cpIHtcclxuICAgICAgdGhpcy5mb2xsb3dpbmdDRFRpbWVyLnN0YXJ0KCk7XHJcbiAgICAgIHRoaXMuZmluaXNoZWQoR1N0YXRlLkRyaWZ0aW5nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgdGhpcy5vd25lci5vbldhbGwgfHxcclxuICAgICAgdGhpcy5vd25lci5vbkNlaWxpbmcgfHxcclxuICAgICAgdGhpcy5vd25lci5vbkdyb3VuZFxyXG4gICAgKSB7XHJcbiAgICAgIGlmICh0aGlzLnN0dWNrVGltZXIuaXNTdG9wcGVkKCkpIHtcclxuICAgICAgICB0aGlzLmZvbGxvd2luZ0NEVGltZXIuc3RhcnQoKTtcclxuICAgICAgICB0aGlzLmZpbmlzaGVkKEdTdGF0ZS5EcmlmdGluZyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnN0dWNrVGltZXIucmVzZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBhcmVudC5kaXJlY3Rpb24gPSB0aGlzLm93bmVyLnBvc2l0aW9uLmRpclRvKHRoaXMucGxheWVyUG9zKTtcclxuXHJcbiAgICB0aGlzLnBhcmVudC52ZWxvY2l0eS54ID1cclxuICAgICAgdGhpcy5wYXJlbnQuZGlyZWN0aW9uLnggKiB0aGlzLnBhcmVudC5mb2xsb3dTcGVlZCAqIGRlbHRhVDtcclxuICAgIHRoaXMucGFyZW50LnZlbG9jaXR5LnkgPVxyXG4gICAgICB0aGlzLnBhcmVudC5kaXJlY3Rpb24ueSAqIHRoaXMucGFyZW50LmZvbGxvd1NwZWVkICogZGVsdGFUO1xyXG5cclxuICAgIHRoaXMub3duZXIubW92ZSh0aGlzLnBhcmVudC52ZWxvY2l0eSk7XHJcbiAgfVxyXG5cclxuICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICAvLyg8QW5pbWF0ZWRTcHJpdGU+dGhpcy5vd25lcikuYW5pbWF0aW9uLnN0b3AoKTtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFN0YXRlIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhdGUvU3RhdGVcIjtcclxuaW1wb3J0IFN0YXRlTWFjaGluZSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1N0YXRlL1N0YXRlTWFjaGluZVwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1RpbWluZy9UaW1lclwiO1xyXG5pbXBvcnQgR2hvc3RDb250cm9sbGVyIGZyb20gXCIuLi9HaG9zdENvbnRyb2xsZXJcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBHYW1lTGV2ZWwgZnJvbSBcIi4uLy4uLy4uL1NjZW5lcy9HYW1lTGV2ZWxcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZ2xvYmFsc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR2hvc3RTdGF0ZSBleHRlbmRzIFN0YXRlIHtcclxuICBvd25lcjogR2FtZU5vZGU7XHJcbiAgcGFyZW50OiBHaG9zdENvbnRyb2xsZXI7XHJcbiAgZm9sbG93aW5nQ0RUaW1lcjogVGltZXI7XHJcbiAgc3R1Y2tUaW1lcjogVGltZXI7XHJcbiAgY29udGFjdENvb2xkb3duOiBUaW1lcjtcclxuICBrbm9ja2JhY2tUaW1lcjogVGltZXI7XHJcbiAgcGxheWVyUG9zOiBWZWMyO1xyXG4gIGNhbkZvbGxvdzogYm9vbGVhbjtcclxuICBzdGF0ZU5hbWU6IHN0cmluZzsgLy8gRm9yIGRlYnVnIHB1cnBvc2VzXHJcblxyXG4gIGNvbnN0cnVjdG9yKHBhcmVudDogU3RhdGVNYWNoaW5lLCBvd25lcjogR2FtZU5vZGUpIHtcclxuICAgIHN1cGVyKHBhcmVudCk7XHJcbiAgICB0aGlzLm93bmVyID0gb3duZXI7XHJcbiAgICB0aGlzLmZvbGxvd2luZ0NEVGltZXIgPSBuZXcgVGltZXIoMTAwMDApO1xyXG4gICAgdGhpcy5zdHVja1RpbWVyID0gbmV3IFRpbWVyKDUwMDApOyAvLyBjaGVjayBpZiBhIGdob3N0IGlzIHN0dWNrIGZvciB0b28gbG9uZ1xyXG4gICAgdGhpcy5jb250YWN0Q29vbGRvd24gPSBuZXcgVGltZXIoMTAwMCk7XHJcbiAgICB0aGlzLmtub2NrYmFja1RpbWVyID0gbmV3IFRpbWVyKDUwMCk7XHJcbiAgfVxyXG5cclxuICBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7fVxyXG5cclxuICAvKipcclxuICAgKiBjaGVjayBpZiB0aGlzIG5vZGUgaXMgd2l0aGluIHggYmxvY2sgb2YgcGxheWVyLlxyXG4gICAqIEEgeCBieSB4IHNxdWFyZSBhcmVhIHdpdGggcGxheWVyIGFzIGNlbnRlclxyXG4gICAqL1xyXG4gIHdpdGhpblhCbG9jayh4OiBudW1iZXIpIHtcclxuICAgIHRoaXMucGxheWVyUG9zID0gKDxHYW1lTGV2ZWw+dGhpcy5vd25lci5nZXRTY2VuZSgpKS5wbGF5ZXIubm9kZS5wb3NpdGlvbjtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIE1hdGguYWJzKHRoaXMub3duZXIucG9zaXRpb24ueCAtIHRoaXMucGxheWVyUG9zLngpIDw9IDMyICogeCAmJlxyXG4gICAgICBNYXRoLmFicyh0aGlzLm93bmVyLnBvc2l0aW9uLnkgLSB0aGlzLnBsYXllclBvcy55KSA8PSAzMiAqIHhcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLm93bmVyLm9uV2FsbCkge1xyXG4gICAgICAvLyBGbGlwIGFyb3VuZFxyXG4gICAgICB0aGlzLnBhcmVudC5kaXJlY3Rpb24ueCAqPSAtMTtcclxuICAgICAgKDxBbmltYXRlZFNwcml0ZT50aGlzLm93bmVyKS5pbnZlcnRYID0gISg8QW5pbWF0ZWRTcHJpdGU+dGhpcy5vd25lcilcclxuICAgICAgICAuaW52ZXJ0WDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMuY29udGFjdENvb2xkb3duLmlzU3RvcHBlZCgpICYmXHJcbiAgICAgIHRoaXMub3duZXIuY29sbGlzaW9uU2hhcGUub3ZlcmxhcHMoXHJcbiAgICAgICAgKDxHYW1lTGV2ZWw+dGhpcy5vd25lci5nZXRTY2VuZSgpKS5wbGF5ZXIubm9kZS5jb2xsaXNpb25TaGFwZSxcclxuICAgICAgKVxyXG4gICAgKSB7XHJcbiAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoRXZlbnRzLlBMQVlFUl9EQU1BR0UpO1xyXG4gICAgICB0aGlzLmNvbnRhY3RDb29sZG93bi5zdGFydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm93bmVyLm9uQ2VpbGluZyB8fCB0aGlzLm93bmVyLm9uR3JvdW5kKSB7XHJcbiAgICAgIHRoaXMucGFyZW50LmRpcmVjdGlvbi55ICo9IC0xO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgR2hvc3RTdGF0ZSBmcm9tIFwiLi9HaG9zdFN0YXRlXCI7XHJcbmltcG9ydCB7IEdTdGF0ZSB9IGZyb20gXCIuLi9HaG9zdENvbnRyb2xsZXJcIjtcclxuaW1wb3J0IEdhbWVMZXZlbCBmcm9tIFwiLi4vLi4vLi4vU2NlbmVzL0dhbWVMZXZlbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS25vY2tiYWNrIGV4dGVuZHMgR2hvc3RTdGF0ZSB7XHJcbiAgb25FbnRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XHJcbiAgICB0aGlzLnBsYXllclBvcyA9ICg8R2FtZUxldmVsPnRoaXMub3duZXIuZ2V0U2NlbmUoKSkucGxheWVyLm5vZGUucG9zaXRpb247XHJcbiAgICB0aGlzLnBhcmVudC5kaXJlY3Rpb24ueCA9IHRoaXMub3duZXIucG9zaXRpb24ueC10aGlzLnBsYXllclBvcy54ID4gMCA/IDEgOiAtMTtcclxuICAgIHRoaXMucGFyZW50LmRpcmVjdGlvbi55ID0gMDtcclxuICAgIHRoaXMuc3RhdGVOYW1lID0gR1N0YXRlLktub2NrYmFjaztcclxuICAgIHRoaXMua25vY2tiYWNrVGltZXIuc3RhcnQoKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcikge1xyXG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XHJcbiAgICB0aGlzLnBhcmVudC52ZWxvY2l0eS54ID1cclxuICAgICAgdGhpcy5wYXJlbnQuZGlyZWN0aW9uLnggKiB0aGlzLnBhcmVudC5rbm9ja2JhY2tTcGVlZCAqIGRlbHRhVDtcclxuICAgIHRoaXMucGFyZW50LnZlbG9jaXR5LnkgPVxyXG4gICAgICB0aGlzLnBhcmVudC5kaXJlY3Rpb24ueSAqIHRoaXMucGFyZW50Lmtub2NrYmFja1NwZWVkICogZGVsdGFUO1xyXG5cclxuICAgIHRoaXMub3duZXIubW92ZSh0aGlzLnBhcmVudC52ZWxvY2l0eSk7XHJcblxyXG4gICAgaWYodGhpcy5rbm9ja2JhY2tUaW1lci5pc1N0b3BwZWQoKSl7XHJcbiAgICAgICAgaWYgKHRoaXMud2l0aGluWEJsb2NrKDYpKSB0aGlzLmNhbkZvbGxvdyA9IHRydWU7XHJcbiAgICAgICAgZWxzZSB0aGlzLmNhbkZvbGxvdyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5jYW5Gb2xsb3cpIHtcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hlZChHU3RhdGUuRm9sbG93aW5nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaGVkKEdTdGF0ZS5EcmlmdGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG4gICAgLy8oPEFuaW1hdGVkU3ByaXRlPnRoaXMub3duZXIpLmFuaW1hdGlvbi5zdG9wKCk7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG59XHJcbiIsImV4cG9ydCBlbnVtIERhbWFnZVR5cGUge1xyXG4gICAgVE9fUExBWUVSID0gXCJUT19QTEFZRVJcIixcclxuICAgIFRPX0VORU1ZID0gXCJUT19FTkVNWVwiLFxyXG4gICAgQ09OVEFDVCA9IFwiQ09OVEFDVFwiLFxyXG59IiwiaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBIaXRib3hDb250cm9sbGVyIGZyb20gXCIuL0hpdGJveENvbnRyb2xsZXJcIjtcclxuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcclxuaW1wb3J0IHsgUGh5c2ljc0dyb3VwcyB9IGZyb20gXCIuLi8uLi9nbG9iYWxzXCI7XHJcblxyXG5leHBvcnQgZW51bSBIU3RhdGUge1xyXG4gIEFjdGl2ZSA9IFwiQWN0aXZlXCIsXHJcbiAgQ29udGFjdCA9IFwiQ29udGFjdFwiLFxyXG4gIE1hbmFnZXIgPSBcIk1hbmFnZXJcIixcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGl0Ym94IHtcclxuICBub2RlOiBBbmltYXRlZFNwcml0ZTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBvd25lcjogQW5pbWF0ZWRTcHJpdGUsXHJcbiAgICBzcHJpdGU6IEFuaW1hdGVkU3ByaXRlLFxyXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsXHJcbiAgICBjZW50ZXI6IFZlYzIsXHJcbiAgICBoYWxmU2l6ZTogVmVjMixcclxuICAgIGludmVydFg6IGJvb2xlYW4sXHJcbiAgICBvZmZzZXQ6IFZlYzIsXHJcbiAgKSB7XHJcbiAgICB0aGlzLm5vZGUgPSBzcHJpdGU7XHJcblxyXG4gICAgdGhpcy5ub2RlLmFkZFBoeXNpY3MobmV3IEFBQkIoY2VudGVyLCBoYWxmU2l6ZSksIG5ldyBWZWMyKDAsIDApKTtcclxuICAgIHRoaXMubm9kZS5zZXRHcm91cChQaHlzaWNzR3JvdXBzLkhJVEJPWF9QSFlTKTtcclxuXHJcbiAgICB0aGlzLm5vZGUuYWRkQUkoSGl0Ym94Q29udHJvbGxlciwge1xyXG4gICAgICBpbnZlcnRYOiBpbnZlcnRYLFxyXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcclxuICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXHJcbiAgICAgIG93bmVyOiBvd25lcixcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgU3RhdGVNYWNoaW5lQUkgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0FJL1N0YXRlTWFjaGluZUFJXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBIaXRib3hTdGF0ZSBmcm9tIFwiLi9IaXRib3hTdGF0ZXMvSGl0Ym94U3RhdGVcIjtcclxuaW1wb3J0IEFjdGl2ZSBmcm9tIFwiLi9IaXRib3hTdGF0ZXMvQWN0aXZlXCI7XHJcbmltcG9ydCB7IEhTdGF0ZSB9IGZyb20gXCIuL0hpdGJveFwiO1xyXG5pbXBvcnQgTWFuYWdlSGl0Ym94IGZyb20gXCIuL0hpdGJveFN0YXRlcy9NYW5hZ2VIaXRib3hcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIaXRib3hDb250cm9sbGVyIGV4dGVuZHMgU3RhdGVNYWNoaW5lQUkge1xyXG4gIC8vIFRoZSBlbnRpdHkgdGhhdCB0aGlzIGhpdGJveCBpcyBjb21pbmcgZnJvbVxyXG4gIG93bmluZ0VudGl0eTogQW5pbWF0ZWRTcHJpdGU7XHJcblxyXG4gIG93bmVyOiBHYW1lTm9kZTtcclxuICB2ZWxvY2l0eTogVmVjMiA9IFZlYzIuWkVSTztcclxuICBpbnZlcnRYOiBib29sZWFuO1xyXG4gIG9mZnNldDogVmVjMjtcclxuICBldmVudFR5cGU6IHN0cmluZztcclxuXHJcbiAgaW5pdGlhbGl6ZUFJKG93bmVyOiBHYW1lTm9kZSwgY29uZmlnOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XHJcbiAgICB0aGlzLm93bmVyID0gb3duZXI7XHJcbiAgICB0aGlzLmludmVydFggPSBjb25maWcuaW52ZXJ0WDtcclxuICAgIHRoaXMub2Zmc2V0ID0gY29uZmlnLm9mZnNldDtcclxuICAgIHRoaXMuZXZlbnRUeXBlID0gY29uZmlnLmV2ZW50VHlwZTtcclxuICAgIHRoaXMub3duaW5nRW50aXR5ID0gY29uZmlnLm93bmVyO1xyXG4gICAgLy8gc3Vic2NyaWJlIHRvIGV2ZW50cyBtYXliZVxyXG5cclxuICAgIHRoaXMuaW5pdGlhbGl6ZVN0YXRlcygpO1xyXG4gIH1cclxuXHJcbiAgaW5pdGlhbGl6ZVN0YXRlcygpIHtcclxuICAgIC8vIGFkZCBzdGF0ZXNcclxuICAgIHRoaXMuYWRkU3RhdGUoSFN0YXRlLkFjdGl2ZSwgbmV3IEFjdGl2ZSh0aGlzLCB0aGlzLm93bmVyKSk7XHJcbiAgICB0aGlzLmFkZFN0YXRlKEhTdGF0ZS5NYW5hZ2VyLCBuZXcgTWFuYWdlSGl0Ym94KHRoaXMsIHRoaXMub3duZXIpKTtcclxuXHJcbiAgICAvLyBhZGQgaW5pdGlhbCBzdGF0ZVxyXG4gICAgdGhpcy5pbml0aWFsaXplKEhTdGF0ZS5NYW5hZ2VyKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcikge1xyXG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XHJcbiAgfVxyXG5cclxuICBnZXQgc3RhdGUoKSB7XHJcbiAgICByZXR1cm4gPEhpdGJveFN0YXRlPnRoaXMuc3RhY2sucGVlaygpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCB7IEhTdGF0ZSB9IGZyb20gXCIuLi9IaXRib3hcIjtcclxuaW1wb3J0IEhpdGJveFN0YXRlIGZyb20gXCIuL0hpdGJveFN0YXRlXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZUxldmVsIGZyb20gXCIuLi8uLi9TY2VuZXMvR2FtZUxldmVsXCI7XHJcbmltcG9ydCB7IERhbWFnZVR5cGUgfSBmcm9tIFwiLi4vRGFtYWdlVHlwZVwiO1xyXG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tIFwiLi4vLi4vLi4vZ2xvYmFsc1wiO1xyXG5pbXBvcnQgR2hvc3RDb250cm9sbGVyLCB7R1N0YXRlfSBmcm9tIFwiLi4vLi4vRW5lbXkvR2hvc3QvR2hvc3RDb250cm9sbGVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY3RpdmUgZXh0ZW5kcyBIaXRib3hTdGF0ZSB7XHJcbiAgb25FbnRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XHJcbiAgICB0aGlzLnN0YXRlTmFtZSA9IEhTdGF0ZS5BY3RpdmU7XHJcbiAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5KFwiYW5pbWF0aW9uXCIsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcikge1xyXG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XHJcbiAgICBjb25zdCBwbGF5ZXIgPSAoPEdhbWVMZXZlbD50aGlzLm93bmVyLmdldFNjZW5lKCkpLnBsYXllci5ub2RlO1xyXG5cclxuICAgIGxldCBwb3NYID0gcGxheWVyLnBvc2l0aW9uLnggKyB0aGlzLnBhcmVudC5vZmZzZXQueDtcclxuICAgIGxldCBwb3NZID0gcGxheWVyLnBvc2l0aW9uLnkgKyB0aGlzLnBhcmVudC5vZmZzZXQueTtcclxuICAgIGlmICh0aGlzLnBhcmVudC5pbnZlcnRYKSB7XHJcbiAgICAgIHBvc1ggPSBwb3NYIC0gdGhpcy5wYXJlbnQub2Zmc2V0LnggKiAyO1xyXG4gICAgICBwb3NZID0gcG9zWSAtIHRoaXMucGFyZW50Lm9mZnNldC55ICogMjtcclxuICAgICAgdGhpcy5vd25lci5pbnZlcnRYID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm93bmVyLnBvc2l0aW9uID0gbmV3IFZlYzIocG9zWCwgcG9zWSk7XHJcblxyXG4gICAgLy8gSGl0Ym94IGRhbWFnaW5nIGVuZW1pZXNcclxuICAgIGlmICh0aGlzLmhhc0hpdCkge1xyXG4gICAgICBpZiAodGhpcy5wYXJlbnQuZXZlbnRUeXBlID09PSBEYW1hZ2VUeXBlLlRPX0VORU1ZKSB7XHJcbiAgICAgICAgY29uc3QgZW5lbWllcyA9ICg8R2FtZUxldmVsPnRoaXMub3duZXIuZ2V0U2NlbmUoKSkuZW5lbWllcztcclxuICAgICAgICBlbmVtaWVzLmZvckVhY2goZW5lbXkgPT4ge1xyXG4gICAgICAgICAgaWYgKHRoaXMub3duZXIuY29sbGlzaW9uU2hhcGUub3ZlcmxhcHMoZW5lbXkubm9kZS5jb2xsaXNpb25TaGFwZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChFdmVudHMuRU5FTVlfREFNQUdFLCB7IGVuZW15OiBlbmVteSB9KTtcclxuICAgICAgICAgICAgKDxHaG9zdENvbnRyb2xsZXI+ZW5lbXkubm9kZS5fYWkpLmNoYW5nZVN0YXRlKEdTdGF0ZS5Lbm9ja2JhY2spO1xyXG4gICAgICAgICAgICB0aGlzLmhhc0hpdCA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBIaXRib3ggZGFtYWdpbmcgcGxheWVyXHJcbiAgICAgIGlmICh0aGlzLnBhcmVudC5ldmVudFR5cGUgPT09IERhbWFnZVR5cGUuVE9fUExBWUVSKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3duZXIuY29sbGlzaW9uU2hhcGUub3ZlcmxhcHMocGxheWVyLmNvbGxpc2lvblNoYXBlKSkge1xyXG4gICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChFdmVudHMuUExBWUVSX0RBTUFHRSk7XHJcbiAgICAgICAgICB0aGlzLmhhc0hpdCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5vd25lci5hbmltYXRpb24uaXNQbGF5aW5nKFwiYW5pbWF0aW9uXCIpKSB7XHJcbiAgICAgIHRoaXMub3duZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xyXG4gICAgLy8gaGFuZGxlIGV2ZW50cyBoZXJlXHJcbiAgfVxyXG5cclxuICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBTdGF0ZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1N0YXRlL1N0YXRlXCI7XHJcbmltcG9ydCBTdGF0ZU1hY2hpbmUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TdGF0ZS9TdGF0ZU1hY2hpbmVcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IEhpdGJveENvbnRyb2xsZXIgZnJvbSBcIi4uL0hpdGJveENvbnRyb2xsZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEhpdGJveFN0YXRlIGV4dGVuZHMgU3RhdGUge1xyXG4gIG93bmVyOiBBbmltYXRlZFNwcml0ZTtcclxuICBwYXJlbnQ6IEhpdGJveENvbnRyb2xsZXI7XHJcbiAgc3RhdGVOYW1lOiBzdHJpbmc7IC8vIEZvciBkZWJ1ZyBwdXJwb3Nlc1xyXG5cclxuICBoYXNIaXQ6IGJvb2xlYW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKHBhcmVudDogU3RhdGVNYWNoaW5lLCBvd25lcjogR2FtZU5vZGUpIHtcclxuICAgIHN1cGVyKHBhcmVudCk7XHJcbiAgICB0aGlzLm93bmVyID0gPEFuaW1hdGVkU3ByaXRlPm93bmVyO1xyXG4gICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7fVxyXG59XHJcbiIsImltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IHsgRGFtYWdlVHlwZSB9IGZyb20gXCIuLi9EYW1hZ2VUeXBlXCI7XHJcbmltcG9ydCB7IEhTdGF0ZSB9IGZyb20gXCIuLi9IaXRib3hcIjtcclxuaW1wb3J0IEhpdGJveFN0YXRlIGZyb20gXCIuL0hpdGJveFN0YXRlXCI7XHJcblxyXG4vLyBUaGlzIHN0YXRlIHRlbGxzIHRoZSBoaXRib3ggd2hhdCB0eXBlIG9mIGhpdGJveCBpdCB3aWxsIGVuZCB1cCBhcy5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFuYWdlSGl0Ym94IGV4dGVuZHMgSGl0Ym94U3RhdGUge1xyXG4gIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pikge1xyXG4gICAgdGhpcy5zdGF0ZU5hbWUgPSBIU3RhdGUuTWFuYWdlcjtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcikge1xyXG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgdGhpcy5maW5pc2hlZChIU3RhdGUuQWN0aXZlKTtcclxuICB9XHJcblxyXG4gIGhhbmRsZUlucHV0KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcclxuICAgIC8vIGhhbmRsZSBldmVudHMgaGVyZVxyXG4gIH1cclxuXHJcbiAgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG4gICAgcmV0dXJuIHt9O1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IFN0YXRlTWFjaGluZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1N0YXRlL1N0YXRlTWFjaGluZVwiO1xyXG5pbXBvcnQgR3JvdW5kZWQgZnJvbSBcIi4vU3RhdGVzL01vdmVtZW50L0dyb3VuZGVkXCI7XHJcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XHJcbmltcG9ydCBBc2NlbmRpbmcgZnJvbSBcIi4vU3RhdGVzL01vdmVtZW50L0FzY2VuZGluZ1wiO1xyXG5pbXBvcnQgRGVzY2VuZGluZyBmcm9tIFwiLi9TdGF0ZXMvTW92ZW1lbnQvRGVzY2VuZGluZ1wiO1xyXG5pbXBvcnQgRGFzaGluZyBmcm9tIFwiLi9TdGF0ZXMvQWN0aW9ucy9EYXNoaW5nXCI7XHJcbmltcG9ydCBJZGxlIGZyb20gXCIuL1N0YXRlcy9BY3Rpb25zL0lkbGVcIjtcclxuaW1wb3J0IEp1bXAgZnJvbSBcIi4vU3RhdGVzL0FjdGlvbnMvSnVtcFwiO1xyXG5pbXBvcnQgQXR0YWNrIGZyb20gXCIuL1N0YXRlcy9BY3Rpb25zL0F0dGFja1wiO1xyXG5pbXBvcnQgQXR0YWNrRG93biBmcm9tIFwiLi9TdGF0ZXMvQWN0aW9ucy9BdHRhY2tEb3duXCI7XHJcbmltcG9ydCBBdHRhY2tVcHBlciBmcm9tIFwiLi9TdGF0ZXMvQWN0aW9ucy9BdHRhY2tVcHBlclwiO1xyXG5pbXBvcnQgeyBQaHlzaWNzR3JvdXBzLCBTcHJpdGVTaXplcyB9IGZyb20gXCIuLi8uLi9nbG9iYWxzXCI7XHJcblxyXG5leHBvcnQgZW51bSBNb3ZlbWVudFN0YXRlIHtcclxuICBHcm91bmRlZCA9IFwiZ3JvdW5kZWRcIixcclxuICBBc2NlbmRpbmcgPSBcImFzY2VuZGluZ1wiLFxyXG4gIERlc2NlbmRpbmcgPSBcImRlc2NlbmRpbmdcIixcclxufVxyXG5cclxuZXhwb3J0IGVudW0gQWN0aW9uU3RhdGUge1xyXG4gIERhc2ggPSBcImRhc2hcIixcclxuICBBdHRhY2sgPSBcImF0dGFja1wiLFxyXG4gIEF0dGFja1VwcGVyID0gXCJhdHRhY2tVcHBlclwiLFxyXG4gIEF0dGFja0Rvd24gPSBcImF0dGFja0Rvd25cIixcclxuICBJZGxlID0gXCJpZGxlXCIsXHJcbiAgSnVtcCA9IFwianVtcFwiLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBQbGF5ZXJBbmltYXRpb25zIHtcclxuICBJZGxlID0gXCJJZGxlXCIsXHJcbiAgV2FsayA9IFwiV2Fsa1wiLFxyXG4gIFNjeXRoZVNsYXNoID0gXCJTY3l0aGUgU2xhc2hcIixcclxuICBKdW1wID0gXCJKdW1wXCIsXHJcbiAgRGFzaCA9IFwiRGFzaFwiLFxyXG4gIFNjeXRoZVVwcGVyID0gXCJTY3l0aGUgVXBwZXJcIixcclxuICBTY3l0aGVEb3duID0gXCJTY3l0aGUgRG93blwiLFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGF5ZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuICBub2RlOiBBbmltYXRlZFNwcml0ZTtcclxuICBtYXhIZWFsdGg6IG51bWJlcjtcclxuICBoZWFsdGg6IG51bWJlcjtcclxuICB2ZWxvY2l0eTogVmVjMiA9IG5ldyBWZWMyKCk7XHJcbiAgc3BlZWQgPSAzMDA7XHJcbiAgcHJpdmF0ZSB0aW1lVG9BcGV4ID0gMC4zNTtcclxuICBwcml2YXRlIGp1bXBIZWlnaHQgPSAyMDtcclxuICBncmF2aXR5OiBudW1iZXI7XHJcbiAganVtcFZlbG9jaXR5OiBudW1iZXI7XHJcblxyXG4gIG1vdmVtZW50U3RhdGVNYWNoaW5lOiBTdGF0ZU1hY2hpbmU7XHJcbiAgYWN0aW9uU3RhdGVNYWNoaW5lOiBTdGF0ZU1hY2hpbmU7XHJcblxyXG4gIGNhbkRhc2g6IGJvb2xlYW47XHJcbiAgbGFzdEdyb3VuZGVkUG9zaXRpb246IFZlYzI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpIHtcclxuICAgIHRoaXMubm9kZSA9IHNwcml0ZTtcclxuICAgIHRoaXMubm9kZS5hZGRQaHlzaWNzKG5ldyBBQUJCKG5ldyBWZWMyKDAsIDApLCBTcHJpdGVTaXplcy5QTEFZRVIpKTtcclxuICAgIHRoaXMubm9kZS5zZXRHcm91cChQaHlzaWNzR3JvdXBzLlBMQVlFUl9QSFlTKTtcclxuICAgIHRoaXMubm9kZS5wb3NpdGlvbiA9IG5ldyBWZWMyKDEwMCwgNTApO1xyXG4gICAgdGhpcy5ub2RlLmFuaW1hdGlvbi5wbGF5KFBsYXllckFuaW1hdGlvbnMuSWRsZSwgdHJ1ZSk7XHJcbiAgICB0aGlzLm1heEhlYWx0aCA9IDEwO1xyXG4gICAgdGhpcy5oZWFsdGggPSAxMDtcclxuICAgIHRoaXMudXBkYXRlR3Jhdml0eSgpO1xyXG4gICAgdGhpcy5pbml0aWFsaXplQUkoKTtcclxuICB9XHJcblxyXG4gIGluaXRpYWxpemVBSSgpIHtcclxuICAgIHRoaXMubW92ZW1lbnRTdGF0ZU1hY2hpbmUgPSBuZXcgU3RhdGVNYWNoaW5lKCk7XHJcbiAgICB0aGlzLm1vdmVtZW50U3RhdGVNYWNoaW5lXHJcbiAgICAgIC5hZGRTdGF0ZShcclxuICAgICAgICBNb3ZlbWVudFN0YXRlLkdyb3VuZGVkLFxyXG4gICAgICAgIG5ldyBHcm91bmRlZCh0aGlzLm1vdmVtZW50U3RhdGVNYWNoaW5lLCB0aGlzLm5vZGUsIHRoaXMpLFxyXG4gICAgICApXHJcbiAgICAgIC5hZGRTdGF0ZShcclxuICAgICAgICBNb3ZlbWVudFN0YXRlLkFzY2VuZGluZyxcclxuICAgICAgICBuZXcgQXNjZW5kaW5nKHRoaXMubW92ZW1lbnRTdGF0ZU1hY2hpbmUsIHRoaXMubm9kZSwgdGhpcyksXHJcbiAgICAgIClcclxuICAgICAgLmFkZFN0YXRlKFxyXG4gICAgICAgIE1vdmVtZW50U3RhdGUuRGVzY2VuZGluZyxcclxuICAgICAgICBuZXcgRGVzY2VuZGluZyh0aGlzLm1vdmVtZW50U3RhdGVNYWNoaW5lLCB0aGlzLm5vZGUsIHRoaXMpLFxyXG4gICAgICApXHJcbiAgICAgIC5pbml0aWFsaXplKE1vdmVtZW50U3RhdGUuR3JvdW5kZWQpO1xyXG5cclxuICAgIHRoaXMuYWN0aW9uU3RhdGVNYWNoaW5lID0gbmV3IFN0YXRlTWFjaGluZSgpO1xyXG4gICAgdGhpcy5hY3Rpb25TdGF0ZU1hY2hpbmVcclxuICAgICAgLmFkZFN0YXRlKFxyXG4gICAgICAgIEFjdGlvblN0YXRlLkRhc2gsXHJcbiAgICAgICAgbmV3IERhc2hpbmcodGhpcy5hY3Rpb25TdGF0ZU1hY2hpbmUsIHRoaXMubm9kZSwgdGhpcyksXHJcbiAgICAgIClcclxuICAgICAgLmFkZFN0YXRlKFxyXG4gICAgICAgIEFjdGlvblN0YXRlLklkbGUsXHJcbiAgICAgICAgbmV3IElkbGUodGhpcy5hY3Rpb25TdGF0ZU1hY2hpbmUsIHRoaXMubm9kZSwgdGhpcyksXHJcbiAgICAgIClcclxuICAgICAgLmFkZFN0YXRlKFxyXG4gICAgICAgIEFjdGlvblN0YXRlLkp1bXAsXHJcbiAgICAgICAgbmV3IEp1bXAodGhpcy5hY3Rpb25TdGF0ZU1hY2hpbmUsIHRoaXMubm9kZSwgdGhpcyksXHJcbiAgICAgIClcclxuICAgICAgLmFkZFN0YXRlKFxyXG4gICAgICAgIEFjdGlvblN0YXRlLkF0dGFjayxcclxuICAgICAgICBuZXcgQXR0YWNrKHRoaXMuYWN0aW9uU3RhdGVNYWNoaW5lLCB0aGlzLm5vZGUsIHRoaXMpLFxyXG4gICAgICApXHJcbiAgICAgIC5hZGRTdGF0ZShcclxuICAgICAgICBBY3Rpb25TdGF0ZS5BdHRhY2tVcHBlcixcclxuICAgICAgICBuZXcgQXR0YWNrVXBwZXIodGhpcy5hY3Rpb25TdGF0ZU1hY2hpbmUsIHRoaXMubm9kZSwgdGhpcyksXHJcbiAgICAgIClcclxuICAgICAgLmFkZFN0YXRlKFxyXG4gICAgICAgIEFjdGlvblN0YXRlLkF0dGFja0Rvd24sXHJcbiAgICAgICAgbmV3IEF0dGFja0Rvd24odGhpcy5hY3Rpb25TdGF0ZU1hY2hpbmUsIHRoaXMubm9kZSwgdGhpcyksXHJcbiAgICAgIClcclxuICAgICAgLmluaXRpYWxpemUoQWN0aW9uU3RhdGUuSWRsZSk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVHcmF2aXR5KCkge1xyXG4gICAgdGhpcy5ncmF2aXR5ID0gKDIgKiB0aGlzLmp1bXBIZWlnaHQpIC8gTWF0aC5wb3codGhpcy50aW1lVG9BcGV4LCAyKSAvIDEwO1xyXG4gICAgdGhpcy5qdW1wVmVsb2NpdHkgPSAtdGhpcy5ncmF2aXR5ICogdGhpcy50aW1lVG9BcGV4O1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLm1vdmVtZW50U3RhdGVNYWNoaW5lLnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgdGhpcy5hY3Rpb25TdGF0ZU1hY2hpbmUudXBkYXRlKGRlbHRhVCk7XHJcbiAgICB0aGlzLm5vZGUubW92ZSh0aGlzLnZlbG9jaXR5KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFBsYXllckFjdGlvblN0YXRlIGZyb20gXCIuL1BsYXllckFjdGlvblN0YXRlXCI7XHJcbmltcG9ydCBIaXRib3ggZnJvbSBcIi4uLy4uLy4uL0hpdGJveC9IaXRib3hcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCB7IEFjdGlvblN0YXRlLCBQbGF5ZXJBbmltYXRpb25zIH0gZnJvbSBcIi4uLy4uL1BsYXllclwiO1xyXG5pbXBvcnQgeyBMYXllcnMgfSBmcm9tIFwiLi4vLi4vLi4vU2NlbmVzL0dhbWVMZXZlbFwiO1xyXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1RpbWluZy9UaW1lclwiO1xyXG5pbXBvcnQgeyBEYW1hZ2VUeXBlIH0gZnJvbSBcIi4uLy4uLy4uL0hpdGJveC9EYW1hZ2VUeXBlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdHRhY2sgZXh0ZW5kcyBQbGF5ZXJBY3Rpb25TdGF0ZSB7XHJcbiAgb25FbnRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcbiAgICB0aGlzLnN0YXRlTmFtZSA9IFwiQXR0YWNrXCI7XHJcbiAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5SWZOb3RBbHJlYWR5KFBsYXllckFuaW1hdGlvbnMuU2N5dGhlU2xhc2gpO1xyXG5cclxuICAgIGNvbnN0IG9mZnNldCA9IG5ldyBWZWMyKDYwLCAwKTtcclxuXHJcbiAgICBjb25zdCBzcHJpdGUgPSB0aGlzLnBsYXllci5ub2RlXHJcbiAgICAgIC5nZXRTY2VuZSgpXHJcbiAgICAgIC5hZGQuYW5pbWF0ZWRTcHJpdGUoXCJTY3l0aGVTbGFzaFwiLCBMYXllcnMuTWFpbik7XHJcblxyXG4gICAgY29uc3QgdGltZXIgPSBuZXcgVGltZXIoXHJcbiAgICAgIDEwMCxcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIGxldCBoaXRib3ggPSBuZXcgSGl0Ym94KFxyXG4gICAgICAgICAgdGhpcy5wbGF5ZXIubm9kZSxcclxuICAgICAgICAgIHNwcml0ZSxcclxuICAgICAgICAgIERhbWFnZVR5cGUuVE9fRU5FTVksXHJcbiAgICAgICAgICBuZXcgVmVjMigwLCAwKSxcclxuICAgICAgICAgIG5ldyBWZWMyKDQ4LCAxNiksXHJcbiAgICAgICAgICB0aGlzLnBsYXllci5ub2RlLmludmVydFgsXHJcbiAgICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgKTtcclxuICAgICAgfSxcclxuICAgICAgZmFsc2UsXHJcbiAgICApO1xyXG5cclxuICAgIHRpbWVyLnN0YXJ0KCk7XHJcbiAgfVxyXG5cclxuICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5vd25lci5hbmltYXRpb24uaXNQbGF5aW5nKFBsYXllckFuaW1hdGlvbnMuU2N5dGhlU2xhc2gpKVxyXG4gICAgICB0aGlzLnBsYXllci5hY3Rpb25TdGF0ZU1hY2hpbmUuY2hhbmdlU3RhdGUoQWN0aW9uU3RhdGUuSWRsZSk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBQbGF5ZXJBY3Rpb25TdGF0ZSBmcm9tIFwiLi9QbGF5ZXJBY3Rpb25TdGF0ZVwiO1xyXG5pbXBvcnQgSGl0Ym94IGZyb20gXCIuLi8uLi8uLi9IaXRib3gvSGl0Ym94XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgeyBBY3Rpb25TdGF0ZSwgUGxheWVyQW5pbWF0aW9ucyB9IGZyb20gXCIuLi8uLi9QbGF5ZXJcIjtcclxuaW1wb3J0IHsgTGF5ZXJzIH0gZnJvbSBcIi4uLy4uLy4uL1NjZW5lcy9HYW1lTGV2ZWxcIjtcclxuaW1wb3J0IFRpbWVyIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9UaW1pbmcvVGltZXJcIjtcclxuaW1wb3J0IHsgRGFtYWdlVHlwZSB9IGZyb20gXCIuLi8uLi8uLi9IaXRib3gvRGFtYWdlVHlwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0YWNrRG93biBleHRlbmRzIFBsYXllckFjdGlvblN0YXRlIHtcclxuICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgIHRoaXMuc3RhdGVOYW1lID0gXCJBdHRhY2tEb3duXCI7XHJcbiAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5SWZOb3RBbHJlYWR5KFBsYXllckFuaW1hdGlvbnMuU2N5dGhlRG93biwgZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IG9mZnNldCA9IG5ldyBWZWMyKDQwLCAwKTtcclxuXHJcbiAgICBjb25zdCBzcHJpdGUgPSB0aGlzLnBsYXllci5ub2RlXHJcbiAgICAgIC5nZXRTY2VuZSgpXHJcbiAgICAgIC5hZGQuYW5pbWF0ZWRTcHJpdGUoXCJTY3l0aGVEb3duXCIsIExheWVycy5NYWluKTtcclxuXHJcbiAgICBjb25zdCB0aW1lciA9IG5ldyBUaW1lcihcclxuICAgICAgMjUwLFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGhpdGJveCA9IG5ldyBIaXRib3goXHJcbiAgICAgICAgICB0aGlzLnBsYXllci5ub2RlLFxyXG4gICAgICAgICAgc3ByaXRlLFxyXG4gICAgICAgICAgRGFtYWdlVHlwZS5UT19FTkVNWSxcclxuICAgICAgICAgIG5ldyBWZWMyKDAsIDApLFxyXG4gICAgICAgICAgbmV3IFZlYzIoMjQsIDQ4KSxcclxuICAgICAgICAgIHRoaXMucGxheWVyLm5vZGUuaW52ZXJ0WCxcclxuICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICApO1xyXG4gICAgICB9LFxyXG4gICAgICBmYWxzZSxcclxuICAgICk7XHJcblxyXG4gICAgdGltZXIuc3RhcnQoKTtcclxuICB9XHJcblxyXG4gIG9uRXhpdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgaWYgKCF0aGlzLm93bmVyLmFuaW1hdGlvbi5pc1BsYXlpbmcoUGxheWVyQW5pbWF0aW9ucy5TY3l0aGVEb3duKSlcclxuICAgICAgdGhpcy5wbGF5ZXIuYWN0aW9uU3RhdGVNYWNoaW5lLmNoYW5nZVN0YXRlKEFjdGlvblN0YXRlLklkbGUpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgUGxheWVyQWN0aW9uU3RhdGUgZnJvbSBcIi4vUGxheWVyQWN0aW9uU3RhdGVcIjtcclxuaW1wb3J0IEhpdGJveCBmcm9tIFwiLi4vLi4vLi4vSGl0Ym94L0hpdGJveFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IHsgQWN0aW9uU3RhdGUsIFBsYXllckFuaW1hdGlvbnMgfSBmcm9tIFwiLi4vLi4vUGxheWVyXCI7XHJcbmltcG9ydCB7IExheWVycyB9IGZyb20gXCIuLi8uLi8uLi9TY2VuZXMvR2FtZUxldmVsXCI7XHJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XHJcbmltcG9ydCB7IERhbWFnZVR5cGUgfSBmcm9tIFwiLi4vLi4vLi4vSGl0Ym94L0RhbWFnZVR5cGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF0dGFja1VwcGVyIGV4dGVuZHMgUGxheWVyQWN0aW9uU3RhdGUge1xyXG4gIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgdGhpcy5zdGF0ZU5hbWUgPSBcIkF0dGFja1VwcGVyXCI7XHJcbiAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5SWZOb3RBbHJlYWR5KFBsYXllckFuaW1hdGlvbnMuU2N5dGhlVXBwZXIpO1xyXG5cclxuICAgIGNvbnN0IG9mZnNldCA9IG5ldyBWZWMyKDQwLCAwKTtcclxuXHJcbiAgICBjb25zdCBzcHJpdGUgPSB0aGlzLnBsYXllci5ub2RlXHJcbiAgICAgIC5nZXRTY2VuZSgpXHJcbiAgICAgIC5hZGQuYW5pbWF0ZWRTcHJpdGUoXCJTY3l0aGVVcHBlclwiLCBMYXllcnMuTWFpbik7XHJcblxyXG4gICAgY29uc3QgdGltZXIgPSBuZXcgVGltZXIoXHJcbiAgICAgIDEyMCxcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIGxldCBoaXRib3ggPSBuZXcgSGl0Ym94KFxyXG4gICAgICAgICAgdGhpcy5wbGF5ZXIubm9kZSxcclxuICAgICAgICAgIHNwcml0ZSxcclxuICAgICAgICAgIERhbWFnZVR5cGUuVE9fRU5FTVksXHJcbiAgICAgICAgICBuZXcgVmVjMigwLCAwKSxcclxuICAgICAgICAgIG5ldyBWZWMyKDI0LCA0OCksXHJcbiAgICAgICAgICB0aGlzLnBsYXllci5ub2RlLmludmVydFgsXHJcbiAgICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgKTtcclxuICAgICAgfSxcclxuICAgICAgZmFsc2UsXHJcbiAgICApO1xyXG5cclxuICAgIHRpbWVyLnN0YXJ0KCk7XHJcbiAgfVxyXG5cclxuICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5vd25lci5hbmltYXRpb24uaXNQbGF5aW5nKFBsYXllckFuaW1hdGlvbnMuU2N5dGhlVXBwZXIpKVxyXG4gICAgICB0aGlzLnBsYXllci5hY3Rpb25TdGF0ZU1hY2hpbmUuY2hhbmdlU3RhdGUoQWN0aW9uU3RhdGUuSWRsZSk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBUaW1lciBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XHJcbmltcG9ydCB7IEFjdGlvblN0YXRlLCBQbGF5ZXJBbmltYXRpb25zIH0gZnJvbSBcIi4uLy4uL1BsYXllclwiO1xyXG5pbXBvcnQgUGxheWVyQWN0aW9uU3RhdGUgZnJvbSBcIi4vUGxheWVyQWN0aW9uU3RhdGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhc2hpbmcgZXh0ZW5kcyBQbGF5ZXJBY3Rpb25TdGF0ZSB7XHJcbiAgcHJpdmF0ZSBkYXNoVGltZXI6IFRpbWVyO1xyXG5cclxuICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgIHRoaXMuc3RhdGVOYW1lID0gXCJEYXNoaW5nXCI7XHJcblxyXG4gICAgdGhpcy5vd25lci5hbmltYXRpb24ucGxheUlmTm90QWxyZWFkeShQbGF5ZXJBbmltYXRpb25zLkRhc2gpO1xyXG5cclxuICAgIHRoaXMuZGFzaFRpbWVyID0gbmV3IFRpbWVyKFxyXG4gICAgICAyMDAsXHJcbiAgICAgICgpID0+IHRoaXMuZmluaXNoZWQoQWN0aW9uU3RhdGUuSWRsZSksXHJcbiAgICAgIGZhbHNlLFxyXG4gICAgKTtcclxuICAgIHRoaXMuZGFzaFRpbWVyLnN0YXJ0KCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpIHtcclxuICAgIGlmICghdGhpcy5vd25lci5vbkdyb3VuZCkgdGhpcy5wbGF5ZXIuY2FuRGFzaCA9IGZhbHNlO1xyXG4gICAgdGhpcy5wbGF5ZXIudmVsb2NpdHkueSA9IHRoaXMucGxheWVyLm5vZGUub25Hcm91bmQgPyAwLjAwMDAxIDogMDtcclxuICAgIGNvbnN0IGRpcmVjdGlvbiA9XHJcbiAgICAgIHRoaXMuZ2V0SW5wdXREaXJlY3Rpb24oKS54ID09IDBcclxuICAgICAgICA/IHRoaXMub3duZXIuaW52ZXJ0WFxyXG4gICAgICAgICAgPyAtMVxyXG4gICAgICAgICAgOiAxXHJcbiAgICAgICAgOiB0aGlzLmdldElucHV0RGlyZWN0aW9uKCkueDtcclxuICAgIHRoaXMucGxheWVyLnNwZWVkID0gNTAwO1xyXG4gIH1cclxuXHJcbiAgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG4gICAgcmV0dXJuIHsgc3RhdGU6IEFjdGlvblN0YXRlLkRhc2ggfTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFBsYXllckFjdGlvblN0YXRlIGZyb20gXCIuL1BsYXllckFjdGlvblN0YXRlXCI7XHJcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvSW5wdXQvSW5wdXRcIjtcclxuaW1wb3J0IHsgQWN0aW9uU3RhdGUgfSBmcm9tIFwiLi4vLi4vUGxheWVyXCI7XHJcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gXCIuLi8uLi8uLi8uLi9nbG9iYWxzXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElkbGUgZXh0ZW5kcyBQbGF5ZXJBY3Rpb25TdGF0ZSB7XHJcbiAgb25FbnRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcbiAgICB0aGlzLnN0YXRlTmFtZSA9IFwiSWRsZVwiO1xyXG4gIH1cclxuXHJcbiAgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCkge1xyXG4gICAgc3VwZXIuaGFuZGxlSW5wdXQoZXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG4gICAgcmV0dXJuIHt9O1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBpZiAoSW5wdXQuaXNKdXN0UHJlc3NlZChBY3Rpb24uRGFzaCkgJiYgdGhpcy5wbGF5ZXIuY2FuRGFzaCkge1xyXG4gICAgICB0aGlzLmZpbmlzaGVkKEFjdGlvblN0YXRlLkRhc2gpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgUGxheWVyQWN0aW9uU3RhdGUgZnJvbSBcIi4vUGxheWVyQWN0aW9uU3RhdGVcIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9JbnB1dC9JbnB1dFwiO1xyXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tIFwiLi4vLi4vLi4vLi4vZ2xvYmFsc1wiO1xyXG5pbXBvcnQgeyBBY3Rpb25TdGF0ZSwgTW92ZW1lbnRTdGF0ZSB9IGZyb20gXCIuLi8uLi9QbGF5ZXJcIjtcclxuaW1wb3J0IElkbGUgZnJvbSBcIi4vSWRsZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSnVtcCBleHRlbmRzIElkbGUge1xyXG4gIGZyb21EYXNoOiBib29sZWFuO1xyXG5cclxuICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgIGlmIChvcHRpb25zKSB0aGlzLmZyb21EYXNoID0gb3B0aW9ucy5zdGF0ZSA9PSBBY3Rpb25TdGF0ZS5EYXNoO1xyXG4gICAgdGhpcy5zdGF0ZU5hbWUgPSBcIkp1bXBcIjtcclxuICAgIHRoaXMucGxheWVyLnZlbG9jaXR5LnkgPSB0aGlzLnBsYXllci5qdW1wVmVsb2NpdHk7XHJcbiAgICB0aGlzLnBsYXllci5tb3ZlbWVudFN0YXRlTWFjaGluZS5jaGFuZ2VTdGF0ZShNb3ZlbWVudFN0YXRlLkFzY2VuZGluZyk7XHJcbiAgfVxyXG5cclxuICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgaWYgKCFJbnB1dC5pc1ByZXNzZWQoQWN0aW9uLkp1bXApKSB7XHJcbiAgICAgIGlmICh0aGlzLnBsYXllci52ZWxvY2l0eS55IDwgMClcclxuICAgICAgICB0aGlzLnBsYXllci5tb3ZlbWVudFN0YXRlTWFjaGluZS5jaGFuZ2VTdGF0ZShNb3ZlbWVudFN0YXRlLkRlc2NlbmRpbmcpO1xyXG4gICAgICB0aGlzLmZpbmlzaGVkKEFjdGlvblN0YXRlLklkbGUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgUGxheWVyU3RhdGUgZnJvbSBcIi4uL1BsYXllclN0YXRlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBQbGF5ZXJBY3Rpb25TdGF0ZSBleHRlbmRzIFBsYXllclN0YXRlIHt9XHJcbiIsImltcG9ydCBJbkFpciBmcm9tIFwiLi9JbkFpclwiO1xyXG5pbXBvcnQgeyBNb3ZlbWVudFN0YXRlIH0gZnJvbSBcIi4uLy4uL1BsYXllclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXNjZW5kaW5nIGV4dGVuZHMgSW5BaXIge1xyXG4gIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pikge1xyXG4gICAgc3VwZXIub25FbnRlcihvcHRpb25zKTtcclxuICAgIHRoaXMuc3RhdGVOYW1lID0gXCJBc2NlbmRpbmdcIjtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcikge1xyXG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgaWYgKHRoaXMucGxheWVyLnZlbG9jaXR5LnkgPiAwKSB0aGlzLmZpbmlzaGVkKE1vdmVtZW50U3RhdGUuRGVzY2VuZGluZyk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBJbkFpciBmcm9tIFwiLi9JbkFpclwiO1xyXG5pbXBvcnQgeyBNb3ZlbWVudFN0YXRlIH0gZnJvbSBcIi4uLy4uL1BsYXllclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVzY2VuZGluZyBleHRlbmRzIEluQWlyIHtcclxuICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcclxuICAgIHN1cGVyLm9uRW50ZXIob3B0aW9ucyk7XHJcbiAgICB0aGlzLnN0YXRlTmFtZSA9IFwiRGVzY2VuZGluZ1wiO1xyXG4gICAgdGhpcy5wbGF5ZXIudmVsb2NpdHkueSA9IDA7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpIHtcclxuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgIGlmICh0aGlzLnBsYXllci52ZWxvY2l0eS55IDwgMCkgdGhpcy5maW5pc2hlZChNb3ZlbWVudFN0YXRlLkFzY2VuZGluZyk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBJbnB1dCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvSW5wdXQvSW5wdXRcIjtcclxuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2dsb2JhbHNcIjtcclxuaW1wb3J0IHsgQWN0aW9uU3RhdGUsIE1vdmVtZW50U3RhdGUsIFBsYXllckFuaW1hdGlvbnMgfSBmcm9tIFwiLi4vLi4vUGxheWVyXCI7XHJcbmltcG9ydCBQbGF5ZXJNb3ZlbWVudFN0YXRlIGZyb20gXCIuL1BsYXllck1vdmVtZW50U3RhdGVcIjtcclxuaW1wb3J0IElkbGUgZnJvbSBcIi4uL0FjdGlvbnMvSWRsZVwiO1xyXG5pbXBvcnQgRGFzaGluZyBmcm9tIFwiLi4vQWN0aW9ucy9EYXNoaW5nXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JvdW5kZWQgZXh0ZW5kcyBQbGF5ZXJNb3ZlbWVudFN0YXRlIHtcclxuICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgIHRoaXMuc3RhdGVOYW1lID0gXCJHcm91bmRlZFwiO1xyXG4gICAgdGhpcy5wbGF5ZXIuY2FuRGFzaCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBwZXJmb3JtaW5nQWN0aW9uKCkge31cclxuXHJcbiAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKSB7XHJcbiAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcclxuICAgIGNvbnN0IGRpciA9IHRoaXMuZ2V0SW5wdXREaXJlY3Rpb24oKTtcclxuXHJcblxyXG4gICAgaWYgKCF0aGlzLmlzQWN0aW9uQW5pbWF0aW9uUGxheWluZygpKSB7XHJcbiAgICAgIGlmIChkaXIueCAhPSAwKSB7XHJcbiAgICAgICAgdGhpcy5vd25lci5hbmltYXRpb24ucGxheUlmTm90QWxyZWFkeShQbGF5ZXJBbmltYXRpb25zLldhbGssIHRydWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMub3duZXIuYW5pbWF0aW9uLnBsYXlJZk5vdEFscmVhZHkoUGxheWVyQW5pbWF0aW9ucy5JZGxlLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghKHRoaXMucGxheWVyLmFjdGlvblN0YXRlTWFjaGluZS5nZXRTdGF0ZSgpIGluc3RhbmNlb2YgRGFzaGluZykpXHJcbiAgICAgIHRoaXMucGxheWVyLnNwZWVkID0gMzAwO1xyXG5cclxuICAgIGlmIChJbnB1dC5pc0p1c3RQcmVzc2VkKEFjdGlvbi5KdW1wKSkge1xyXG4gICAgICB0aGlzLnBsYXllci5hY3Rpb25TdGF0ZU1hY2hpbmUuY2hhbmdlU3RhdGUoQWN0aW9uU3RhdGUuSnVtcCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBsYXllci52ZWxvY2l0eS55ID0gMC4wMDAwMTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIElucHV0LmlzSnVzdFByZXNzZWQoQWN0aW9uLkF0dGFjaykgJiZcclxuICAgICAgdGhpcy5wbGF5ZXIuYWN0aW9uU3RhdGVNYWNoaW5lLmdldFN0YXRlKCkgaW5zdGFuY2VvZiBJZGxlXHJcbiAgICApIHtcclxuICAgICAgdGhpcy5wbGF5ZXIuYWN0aW9uU3RhdGVNYWNoaW5lLmNoYW5nZVN0YXRlKEFjdGlvblN0YXRlLkF0dGFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLm93bmVyLm9uR3JvdW5kKSB0aGlzLmZpbmlzaGVkKE1vdmVtZW50U3RhdGUuRGVzY2VuZGluZyk7XHJcbiAgfVxyXG5cclxuICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICB0aGlzLnBsYXllci5sYXN0R3JvdW5kZWRQb3NpdGlvbiA9IHRoaXMub3duZXIucG9zaXRpb25cclxuICAgICAgLmNsb25lKClcclxuICAgICAgLnN1YihuZXcgVmVjMih0aGlzLmdldElucHV0RGlyZWN0aW9uKCkueCAqIDQwLCAwKSk7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEFjdGlvblN0YXRlLCBNb3ZlbWVudFN0YXRlLCBQbGF5ZXJBbmltYXRpb25zIH0gZnJvbSBcIi4uLy4uL1BsYXllclwiO1xyXG5pbXBvcnQgUGxheWVyTW92ZW1lbnRTdGF0ZSBmcm9tIFwiLi9QbGF5ZXJNb3ZlbWVudFN0YXRlXCI7XHJcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvSW5wdXQvSW5wdXRcIjtcclxuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2dsb2JhbHNcIjtcclxuaW1wb3J0IEp1bXAgZnJvbSBcIi4uL0FjdGlvbnMvSnVtcFwiO1xyXG5pbXBvcnQgSWRsZSBmcm9tIFwiLi4vQWN0aW9ucy9JZGxlXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5BaXIgZXh0ZW5kcyBQbGF5ZXJNb3ZlbWVudFN0YXRlIHtcclxuICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgIHRoaXMuc3RhdGVOYW1lID0gXCJJbkFpclwiO1xyXG4gICAgaWYgKCF0aGlzLmlzQWN0aW9uQW5pbWF0aW9uUGxheWluZygpKVxyXG4gICAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5SWZOb3RBbHJlYWR5KFBsYXllckFuaW1hdGlvbnMuSnVtcCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpIHtcclxuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgIHRoaXMucGxheWVyLnZlbG9jaXR5LnkgPSBNYXRoLm1pbihcclxuICAgICAgdGhpcy5wbGF5ZXIuZ3Jhdml0eSAqIGRlbHRhVCArIHRoaXMucGxheWVyLnZlbG9jaXR5LnksXHJcbiAgICAgIDEwLFxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIElucHV0LmlzSnVzdFByZXNzZWQoQWN0aW9uLkF0dGFjaykgJiZcclxuICAgICAgKHRoaXMucGxheWVyLmFjdGlvblN0YXRlTWFjaGluZS5nZXRTdGF0ZSgpIGluc3RhbmNlb2YgSnVtcCB8fFxyXG4gICAgICAgIHRoaXMucGxheWVyLmFjdGlvblN0YXRlTWFjaGluZS5nZXRTdGF0ZSgpIGluc3RhbmNlb2YgSWRsZSlcclxuICAgICkge1xyXG4gICAgICBpZiAoSW5wdXQuaXNQcmVzc2VkKEFjdGlvbi5VcCkpXHJcbiAgICAgICAgdGhpcy5wbGF5ZXIuYWN0aW9uU3RhdGVNYWNoaW5lLmNoYW5nZVN0YXRlKEFjdGlvblN0YXRlLkF0dGFja1VwcGVyKTtcclxuICAgICAgZWxzZSBpZiAoSW5wdXQuaXNQcmVzc2VkKEFjdGlvbi5Eb3duKSlcclxuICAgICAgICB0aGlzLnBsYXllci5hY3Rpb25TdGF0ZU1hY2hpbmUuY2hhbmdlU3RhdGUoQWN0aW9uU3RhdGUuQXR0YWNrRG93bik7XHJcbiAgICAgIGVsc2UgdGhpcy5wbGF5ZXIuYWN0aW9uU3RhdGVNYWNoaW5lLmNoYW5nZVN0YXRlKEFjdGlvblN0YXRlLkF0dGFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogUmVtb3ZlIGluIGFjdHVhbCBnYW1lIHJlbGVhc2UgOilcclxuICAgIGlmICh0aGlzLm93bmVyLnBvc2l0aW9uLnkgPiAyMDAwKVxyXG4gICAgICB0aGlzLm93bmVyLnBvc2l0aW9uID0gbmV3IFZlYzIodGhpcy5wbGF5ZXIubGFzdEdyb3VuZGVkUG9zaXRpb24ueCwgdGhpcy5wbGF5ZXIubGFzdEdyb3VuZGVkUG9zaXRpb24ueSAtIDE1MCk7XHJcblxyXG4gICAgaWYgKHRoaXMub3duZXIub25Hcm91bmQpIHtcclxuICAgICAgdGhpcy5maW5pc2hlZChNb3ZlbWVudFN0YXRlLkdyb3VuZGVkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRXhpdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFBsYXllclN0YXRlIGZyb20gXCIuLi9QbGF5ZXJTdGF0ZVwiO1xyXG5pbXBvcnQgeyBQbGF5ZXJBbmltYXRpb25zIH0gZnJvbSBcIi4uLy4uL1BsYXllclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUGxheWVyTW92ZW1lbnRTdGF0ZSBleHRlbmRzIFBsYXllclN0YXRlIHtcclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGxldCBkaXIgPSB0aGlzLmdldElucHV0RGlyZWN0aW9uKCk7XHJcbiAgICBpZiAoZGlyLnggPT0gLTEpIHtcclxuICAgICAgdGhpcy5vd25lci5pbnZlcnRYID0gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAoZGlyLnggPT0gMSkge1xyXG4gICAgICB0aGlzLm93bmVyLmludmVydFggPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBsYXllci52ZWxvY2l0eSA9IHRoaXMub3duZXIuZ2V0TGFzdFZlbG9jaXR5KCk7XHJcbiAgICB0aGlzLnBsYXllci52ZWxvY2l0eS54ID0gZGlyLnggKiB0aGlzLnBsYXllci5zcGVlZCAqIGRlbHRhVDtcclxuICB9XHJcblxyXG4gIGlzQWN0aW9uQW5pbWF0aW9uUGxheWluZygpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIFBsYXllckFuaW1hdGlvbnMuU2N5dGhlU2xhc2gsXHJcbiAgICAgIFBsYXllckFuaW1hdGlvbnMuRGFzaCxcclxuICAgICAgUGxheWVyQW5pbWF0aW9ucy5TY3l0aGVVcHBlcixcclxuICAgICAgUGxheWVyQW5pbWF0aW9ucy5TY3l0aGVEb3duLFxyXG4gICAgXS5zb21lKHggPT4gdGhpcy5vd25lci5hbmltYXRpb24uaXNQbGF5aW5nKHgpKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFN0YXRlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhdGUvU3RhdGVcIjtcclxuaW1wb3J0IFN0YXRlTWFjaGluZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1N0YXRlL1N0YXRlTWFjaGluZVwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0lucHV0L0lucHV0XCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IFRpbWVyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9UaW1pbmcvVGltZXJcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBQbGF5ZXIgZnJvbSBcIi4uL1BsYXllclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUGxheWVyU3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XHJcbiAgb3duZXI6IEFuaW1hdGVkU3ByaXRlO1xyXG4gIHBhcmVudDogU3RhdGVNYWNoaW5lO1xyXG4gIHBsYXllcjogUGxheWVyO1xyXG4gIHN0YXRlTmFtZTogc3RyaW5nOyAvLyBGb3IgZGVidWcgcHVycG9zZXNcclxuXHJcbiAgY29uc3RydWN0b3IocGFyZW50OiBTdGF0ZU1hY2hpbmUsIG93bmVyOiBHYW1lTm9kZSwgcGxheWVyOiBQbGF5ZXIpIHtcclxuICAgIHN1cGVyKHBhcmVudCk7XHJcbiAgICB0aGlzLm93bmVyID0gPEFuaW1hdGVkU3ByaXRlPm93bmVyO1xyXG4gICAgdGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XHJcbiAgfVxyXG5cclxuICBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7fVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGlucHV0cyBmcm9tIHRoZSBrZXlib2FyZCwgb3IgVmVjMi5aZXJvIGlmIG5vdGhpbmcgaXMgYmVpbmcgcHJlc3NlZFxyXG4gICAqL1xyXG4gIGdldElucHV0RGlyZWN0aW9uKCk6IFZlYzIge1xyXG4gICAgbGV0IGRpcmVjdGlvbiA9IFZlYzIuWkVSTztcclxuICAgIGRpcmVjdGlvbi54ID1cclxuICAgICAgKElucHV0LmlzUHJlc3NlZChcImxlZnRcIikgPyAtMSA6IDApICsgKElucHV0LmlzUHJlc3NlZChcInJpZ2h0XCIpID8gMSA6IDApO1xyXG4gICAgZGlyZWN0aW9uLnkgPSBJbnB1dC5pc0p1c3RQcmVzc2VkKFwianVtcFwiKSA/IC0xIDogMDtcclxuICAgIHJldHVybiBkaXJlY3Rpb247XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IFBsYXllciBmcm9tIFwiLi4vUGxheWVyL1BsYXllclwiO1xyXG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcclxuaW1wb3J0IENhbWVyYSBmcm9tIFwiLi4vQ2FtZXJhXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgeyBFdmVudHMsIFBoeXNpY3NHcm91cHMgfSBmcm9tIFwiLi4vLi4vZ2xvYmFsc1wiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xyXG5pbXBvcnQgTWFpbk1lbnUgZnJvbSBcIi4vTWFpbk1lbnVcIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9JbnB1dC9JbnB1dFwiO1xyXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tIFwiLi4vLi4vZ2xvYmFsc1wiO1xyXG5pbXBvcnQgUGxheWVyU3RhdGUgZnJvbSBcIi4uL1BsYXllci9TdGF0ZXMvUGxheWVyU3RhdGVcIjtcclxuaW1wb3J0IEdob3N0LCB7IEdob3N0VHlwZSB9IGZyb20gXCIuLi9FbmVteS9HaG9zdC9HaG9zdFwiO1xyXG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcclxuaW1wb3J0IFNjZW5lTWFuYWdlciBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVNYW5hZ2VyXCI7XHJcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xyXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xyXG5cclxuZXhwb3J0IGVudW0gTGF5ZXJzIHtcclxuICBNYWluID0gXCJtYWluXCIsXHJcbiAgVUkgPSBcInVpXCIsXHJcbiAgQmFja2dyb3VuZCA9IFwiYmdcIixcclxuICBIaWRkZW4gPSBcImhpZGRlblwiLFxyXG4gIERlYnVnID0gXCJkZWJnXCIsXHJcbiAgUGF1c2UgPSBcInBhdXNlXCIsXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVMZXZlbCBleHRlbmRzIFNjZW5lIHtcclxuICBwbGF5ZXI6IFBsYXllcjtcclxuICBjYW1lcmE6IENhbWVyYTtcclxuXHJcbiAgLy8gVE9ETzogTWFrZSBFbmVteS50cyBhbmQgZ2hvc3QgaW5oZXJpdCBmcm9tIHRoYXRcclxuICBlbmVtaWVzOiBBcnJheTxHaG9zdD47XHJcblxyXG4gIHBsYXllclN0YXRlTGFiZWw6IExhYmVsO1xyXG4gIHBsYXllckFjdGlvblN0YXRlTGFiZWw6IExhYmVsO1xyXG5cclxuICBuZXh0TGV2ZWw6IG5ldyAoLi4uYXJnczogYW55KSA9PiBHYW1lTGV2ZWw7XHJcbiAgbGV2ZWxFbmRBcmVhOiBSZWN0O1xyXG5cclxuICBoZWFsdGhCYXI6IExhYmVsO1xyXG4gIGhlYWx0aEJhckJnOiBMYWJlbDtcclxuXHJcbiAgdGV4dENvbG9yID0gbmV3IENvbG9yKDIzMSwgMjI0LCAyNDEpO1xyXG4gIGhlYWx0aEJhckNvbG9yID0gbmV3IENvbG9yKDIxNSwgNzQsIDkxKTtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxyXG4gICAgdmlld3BvcnQ6IFZpZXdwb3J0LFxyXG4gICAgc2NlbmVNYW5hZ2VyOiBTY2VuZU1hbmFnZXIsXHJcbiAgICByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyLFxyXG4gICAgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PixcclxuICApIHtcclxuICAgIHN1cGVyKHZpZXdwb3J0LCBzY2VuZU1hbmFnZXIsIHJlbmRlcmluZ01hbmFnZXIsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIFRPRE86IGNoYW5nZSB0byB0eXBlIGVuZW15IHdoZW4gaW1wbGVtZW50ZWRcclxuICAgIHRoaXMuZW5lbWllcyA9IG5ldyBBcnJheTxHaG9zdD4oKTtcclxuICB9XHJcblxyXG4gIGxvYWRTY2VuZSgpIHtcclxuICAgIC8vIHJlYXBlciBhbmQgYW5pbWF0aW9uc1xyXG4gICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwicmVhcGVyXCIsIFwiYXNzZXRzL3Nwcml0ZXNoZWV0cy9SZWFwZXIvcmVhcGVyLmpzb25cIik7XHJcbiAgICB0aGlzLmxvYWQuc3ByaXRlc2hlZXQoXHJcbiAgICAgIFwiU2N5dGhlU2xhc2hcIixcclxuICAgICAgXCJhc3NldHMvc3ByaXRlc2hlZXRzL1JlYXBlci9SZWFwZXJWRlgvU2N5dGhlU2xhc2guanNvblwiLFxyXG4gICAgKTtcclxuICAgIHRoaXMubG9hZC5zcHJpdGVzaGVldChcclxuICAgICAgXCJTY3l0aGVVcHBlclwiLFxyXG4gICAgICBcImFzc2V0cy9zcHJpdGVzaGVldHMvUmVhcGVyL1JlYXBlclZGWC9TY3l0aGVVcHBlci5qc29uXCIsXHJcbiAgICApO1xyXG4gICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFxyXG4gICAgICBcIlNjeXRoZURvd25cIixcclxuICAgICAgXCJhc3NldHMvc3ByaXRlc2hlZXRzL1JlYXBlci9SZWFwZXJWRlgvU2N5dGhlRG93bi5qc29uXCIsXHJcbiAgICApO1xyXG5cclxuICAgIC8vIHJlZCBzb3VsIGVuZW15XHJcbiAgICB0aGlzLmxvYWQuc3ByaXRlc2hlZXQoXHJcbiAgICAgIFwiUmVkU291bFwiLFxyXG4gICAgICBcImFzc2V0cy9zcHJpdGVzaGVldHMvUmVkU291bC9SZWRTb3VsLmpzb25cIixcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5hZGRMYXllcihMYXllcnMuTWFpbiwgMSk7XHJcbiAgICB0aGlzLmFkZFVJTGF5ZXIoTGF5ZXJzLlVJKTtcclxuICAgIHRoaXMuYWRkVUlMYXllcihMYXllcnMuUGF1c2UpLnNldEhpZGRlbih0cnVlKTtcclxuICAgIHRoaXMuYWRkTGF5ZXIoTGF5ZXJzLkRlYnVnLCAyKTtcclxuICAgIHRoaXMuYWRkTGF5ZXIoTGF5ZXJzLkhpZGRlbiwgMSkuc2V0SGlkZGVuKHRydWUpO1xyXG4gIH1cclxuXHJcbiAgdW5sb2FkU2NlbmUoKTogdm9pZCB7XHJcbiAgICB0aGlzLnJlc291cmNlTWFuYWdlci5rZWVwU3ByaXRlc2hlZXQoXCJyZWFwZXJcIik7XHJcbiAgfVxyXG5cclxuICBzdGFydFNjZW5lKCkge1xyXG4gICAgdGhpcy5wbGF5ZXIgPSBuZXcgUGxheWVyKHRoaXMuYWRkLmFuaW1hdGVkU3ByaXRlKFwicmVhcGVyXCIsIExheWVycy5NYWluKSk7XHJcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmEoXHJcbiAgICAgIHRoaXMuYWRkLmdyYXBoaWMoR3JhcGhpY1R5cGUuUE9JTlQsIExheWVycy5IaWRkZW4sIHtcclxuICAgICAgICBwb3NpdGlvbjogdGhpcy5wbGF5ZXIubm9kZS5wb3NpdGlvbi5jbG9uZSgpLFxyXG4gICAgICB9KSxcclxuICAgICAgbmV3IFZlYzIoMCwgLTgwKSxcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5jYW1lcmEuZm9sbG93KHRoaXMucGxheWVyLm5vZGUpO1xyXG5cclxuICAgIHRoaXMucGxheWVyU3RhdGVMYWJlbCA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoXHJcbiAgICAgIFVJRWxlbWVudFR5cGUuTEFCRUwsXHJcbiAgICAgIExheWVycy5EZWJ1ZyxcclxuICAgICAge1xyXG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLnBsYXllci5ub2RlLnBvc2l0aW9uLmNsb25lKCksXHJcbiAgICAgICAgdGV4dDogXCJcIixcclxuICAgICAgfSxcclxuICAgICk7XHJcbiAgICB0aGlzLnBsYXllclN0YXRlTGFiZWwuZm9udCA9IFwiTWlzdGVyIFBpeGVsXCI7XHJcbiAgICB0aGlzLnBsYXllclN0YXRlTGFiZWwudGV4dENvbG9yID0gQ29sb3IuV0hJVEU7XHJcblxyXG4gICAgdGhpcy5wbGF5ZXJBY3Rpb25TdGF0ZUxhYmVsID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChcclxuICAgICAgVUlFbGVtZW50VHlwZS5MQUJFTCxcclxuICAgICAgTGF5ZXJzLkRlYnVnLFxyXG4gICAgICB7XHJcbiAgICAgICAgcG9zaXRpb246IHRoaXMucGxheWVyLm5vZGUucG9zaXRpb24uY2xvbmUoKSxcclxuICAgICAgICB0ZXh0OiBcIlwiLFxyXG4gICAgICB9LFxyXG4gICAgKTtcclxuICAgIHRoaXMucGxheWVyQWN0aW9uU3RhdGVMYWJlbC5mb250ID0gXCJNaXN0ZXIgUGl4ZWxcIjtcclxuICAgIHRoaXMucGxheWVyQWN0aW9uU3RhdGVMYWJlbC50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuXHJcbiAgICB0aGlzLnZpZXdwb3J0LmZvbGxvdyh0aGlzLmNhbWVyYS5ub2RlKTtcclxuICAgIHRoaXMudmlld3BvcnQuc2V0Wm9vbUxldmVsKDIpO1xyXG4gICAgdGhpcy52aWV3cG9ydC5zZXRTbW9vdGhpbmdGYWN0b3IoMCk7XHJcblxyXG4gICAgdGhpcy5pbml0UGF1c2VMYXllcigpO1xyXG4gICAgdGhpcy5pbml0VUkoKTtcclxuXHJcbiAgICAvLyBzdWJzY3JpYmUgdG8gZXZlbnRzXHJcbiAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShFdmVudHMuTUFJTl9NRU5VKTtcclxuICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEV2ZW50cy5FTkVNWV9EQU1BR0UpO1xyXG4gICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoRXZlbnRzLlBMQVlFUl9EQU1BR0UpO1xyXG4gICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoRXZlbnRzLkVORU1ZX0RFQVRIKTtcclxuICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEV2ZW50cy5QTEFZRVJfREVBVEgpO1xyXG4gICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoRXZlbnRzLlBMQVlFUl9IRUFMKTtcclxuXHJcbiAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShFdmVudHMuTEVWRUxfRU5EKTtcclxuICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEV2ZW50cy5FTlRFUl9MRVZFTF9FTkQpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKSB7XHJcbiAgICBpZiAoSW5wdXQuaXNKdXN0UHJlc3NlZChBY3Rpb24uUGF1c2UpKSB7XHJcbiAgICAgIElucHV0LmRpc2FibGVJbnB1dCgpO1xyXG4gICAgICB0aGlzLnVpTGF5ZXJzLmdldChMYXllcnMuUGF1c2UpLnNldEhpZGRlbihmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jYW1lcmEudXBkYXRlKGRlbHRhVCk7XHJcbiAgICB0aGlzLnBsYXllci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICB0aGlzLnBsYXllclN0YXRlTGFiZWwudGV4dCA9ICg8UGxheWVyU3RhdGU+KFxyXG4gICAgICB0aGlzLnBsYXllci5tb3ZlbWVudFN0YXRlTWFjaGluZS5nZXRTdGF0ZSgpXHJcbiAgICApKS5zdGF0ZU5hbWU7XHJcbiAgICB0aGlzLnBsYXllclN0YXRlTGFiZWwucG9zaXRpb24gPSB0aGlzLnBsYXllci5ub2RlLnBvc2l0aW9uXHJcbiAgICAgIC5jbG9uZSgpXHJcbiAgICAgIC5hZGQobmV3IFZlYzIoMCwgLTQwKSk7XHJcblxyXG4gICAgdGhpcy5wbGF5ZXJBY3Rpb25TdGF0ZUxhYmVsLnRleHQgPSAoPFBsYXllclN0YXRlPihcclxuICAgICAgdGhpcy5wbGF5ZXIuYWN0aW9uU3RhdGVNYWNoaW5lLmdldFN0YXRlKClcclxuICAgICkpLnN0YXRlTmFtZTtcclxuICAgIHRoaXMucGxheWVyQWN0aW9uU3RhdGVMYWJlbC5wb3NpdGlvbiA9IHRoaXMucGxheWVyLm5vZGUucG9zaXRpb25cclxuICAgICAgLmNsb25lKClcclxuICAgICAgLmFkZChuZXcgVmVjMigwLCAtODApKTtcclxuICAgIC8vIGhhbmRsZSBldmVudHNcclxuICAgIHdoaWxlICh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XHJcbiAgICAgIHRoaXMuaGFuZGxlRXZlbnQodGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KSB7XHJcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcclxuICAgICAgY2FzZSBFdmVudHMuTUFJTl9NRU5VOiB7XHJcbiAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShNYWluTWVudSk7XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjYXNlIEV2ZW50cy5FTkVNWV9EQU1BR0U6IHtcclxuICAgICAgICBsZXQgZW5lbXkgPSBldmVudC5kYXRhLmdldChcImVuZW15XCIpO1xyXG4gICAgICAgIGVuZW15LmhlYWx0aCAtPSAxO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBFbmVteTogJHtlbmVteS5oZWFsdGh9YCk7XHJcblxyXG4gICAgICAgIGlmIChlbmVteS5oZWFsdGggPD0gMClcclxuICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoRXZlbnRzLkVORU1ZX0RFQVRILCB7IGVuZW15OiBlbmVteSB9KTtcclxuXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgRXZlbnRzLlBMQVlFUl9EQU1BR0U6IHtcclxuICAgICAgICB0aGlzLnBsYXllci5oZWFsdGggLT0gMTtcclxuICAgICAgICB0aGlzLmhlYWx0aEJhci5zaXplLnggPSA2MDAgKiAodGhpcy5wbGF5ZXIuaGVhbHRoIC8gMTApO1xyXG4gICAgICAgIHRoaXMuaGVhbHRoQmFyLnBvc2l0aW9uLnggPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLnBsYXllci5oZWFsdGggPD0gMClcclxuICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoRXZlbnRzLlBMQVlFUl9ERUFUSCk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBQbGF5ZXI6ICR7dGhpcy5wbGF5ZXIuaGVhbHRofWApO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjYXNlIEV2ZW50cy5QTEFZRVJfSEVBTDoge1xyXG4gICAgICAgIGlmICh0aGlzLnBsYXllci5oZWFsdGggKyAxIDw9IHRoaXMucGxheWVyLm1heEhlYWx0aCkge1xyXG4gICAgICAgICAgdGhpcy5wbGF5ZXIuaGVhbHRoICs9IDE7XHJcbiAgICAgICAgICB0aGlzLmhlYWx0aEJhci5zaXplLnggPSA2MDAgKiAodGhpcy5wbGF5ZXIuaGVhbHRoIC8gMTApO1xyXG4gICAgICAgICAgdGhpcy5oZWFsdGhCYXIucG9zaXRpb24ueCA9IDA7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUGxheWVyOiAke3RoaXMucGxheWVyLmhlYWx0aH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRPRE86IERlYXRoIGFuaW1hdGlvbnNcclxuICAgICAgY2FzZSBFdmVudHMuRU5FTVlfREVBVEg6IHtcclxuICAgICAgICBsZXQgZW5lbXkgPSBldmVudC5kYXRhLmdldChcImVuZW15XCIpO1xyXG5cclxuICAgICAgICAvLyBIZWFsIHBsYXllciBpZiByZWQgc291bFxyXG4gICAgICAgIGlmIChlbmVteS50eXBlID09PSBHaG9zdFR5cGUuUkVEKVxyXG4gICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChFdmVudHMuUExBWUVSX0hFQUwpO1xyXG5cclxuICAgICAgICBlbmVteS5ub2RlLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmVuZW1pZXMgPSB0aGlzLmVuZW1pZXMuZmlsdGVyKGUgPT4gZSAhPT0gZW5lbXkpO1xyXG5cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FzZSBFdmVudHMuUExBWUVSX0RFQVRIOiB7XHJcbiAgICAgICAgLy8gZGVhdGggYW5pbSAtPiBzb21lIHNjcmVlbi9tYWluIG1lbnUgZm9yIG5vd1xyXG4gICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoTWFpbk1lbnUpO1xyXG5cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FzZSBFdmVudHMuTEVWRUxfRU5EOiB7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgIFJvd3MgaW4gdGhlIGNvbGxpc2lvbnMgYXJyYXkgcmVwcmVzZW50IGVhY2ggcGh5c2ljcyBncm91cCBieSBpbmRleCwgXHJcbiAgICAgICAgICBmaXJzdCBpbmRleCBvZiB0aGUgZmlyc3Qgcm93IGlzIHRoZSBmaXJzdCBwaHlzIGdyb3VwIGl0c2VsZixcclxuICAgICAgICAgIHNlY29uZCBpbmRleCBpbiB0aGUgc2Vjb25kIHJvdyBpcyB0aGUgc2Vjb25kIHBoeXMgZ3JvdXAgaXRzZWxmLCBldGMuXHJcblxyXG4gICAgICAgICAgMCBpcyBkb2VzIG5vdCBjb2xsaWRlLCAxIGlzIGNvbGxpZGVcclxuICAgICAgICAqL1xyXG4gICAgICAgIGxldCBzY2VuZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgICBwaHlzaWNzOiB7XHJcbiAgICAgICAgICAgIGdyb3VwTmFtZXM6IFtcclxuICAgICAgICAgICAgICBQaHlzaWNzR3JvdXBzLlBMQVlFUl9QSFlTLFxyXG4gICAgICAgICAgICAgIFBoeXNpY3NHcm91cHMuRU5FTVlfUEhZUyxcclxuICAgICAgICAgICAgICBQaHlzaWNzR3JvdXBzLkhJVEJPWF9QSFlTLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBjb2xsaXNpb25zOiBbXHJcbiAgICAgICAgICAgICAgWzAsIDEsIDFdLFxyXG4gICAgICAgICAgICAgIFswLCAxLCAxXSxcclxuICAgICAgICAgICAgICBbMCwgMCwgMF0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZSh0aGlzLm5leHRMZXZlbCwge30sIHNjZW5lT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjYXNlIEV2ZW50cy5FTlRFUl9MRVZFTF9FTkQ6IHtcclxuICAgICAgICBpZiAodGhpcy5lbmVtaWVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoRXZlbnRzLkxFVkVMX0VORCk7XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpbml0VUkoKSB7XHJcbiAgICB0aGlzLmhlYWx0aEJhciA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgTGF5ZXJzLlVJLCB7XHJcbiAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMigwLCAzMCksXHJcbiAgICAgIHRleHQ6IFwiXCIsXHJcbiAgICB9KTtcclxuICAgIHRoaXMuaGVhbHRoQmFyLnNpemUgPSBuZXcgVmVjMig2MDAsIDUwKTtcclxuICAgIHRoaXMuaGVhbHRoQmFyLmJhY2tncm91bmRDb2xvciA9IHRoaXMuaGVhbHRoQmFyQ29sb3I7XHJcbiAgICB0aGlzLmhlYWx0aEJhci5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICB0aGlzLmhlYWx0aEJhci5ib3JkZXJSYWRpdXMgPSAwO1xyXG5cclxuICAgIGNvbnN0IGhlYWx0aEJhckJvcmRlciA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoXHJcbiAgICAgIFVJRWxlbWVudFR5cGUuTEFCRUwsXHJcbiAgICAgIExheWVycy5VSSxcclxuICAgICAge1xyXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMig3MCwgMzApLFxyXG4gICAgICAgIHRleHQ6IFwiXCIsXHJcbiAgICAgIH0sXHJcbiAgICApO1xyXG4gICAgaGVhbHRoQmFyQm9yZGVyLnNpemUgPSBuZXcgVmVjMigzMjAsIDUwKTtcclxuICAgIGhlYWx0aEJhckJvcmRlci5ib3JkZXJDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgaGVhbHRoQmFyQm9yZGVyLmJvcmRlcldpZHRoID0gMjtcclxuICAgIGhlYWx0aEJhckJvcmRlci5ib3JkZXJSYWRpdXMgPSAwO1xyXG4gIH1cclxuXHJcbiAgaW5pdFBhdXNlTGF5ZXIoKSB7XHJcbiAgICBjb25zdCBidXR0b25XaWR0aDogbnVtYmVyID0gNDUwO1xyXG4gICAgY29uc3QgYnV0dG9uSGVpZ2h0OiBudW1iZXIgPSA2NTtcclxuXHJcbiAgICBjb25zdCByZXN1bWVCdXR0b24gPSB0aGlzLm5ld0J1dHRvbihcclxuICAgICAgbmV3IFZlYzIoMTAwLCA3MCksXHJcbiAgICAgIFwiUkVTVU1FXCIsXHJcbiAgICAgIDUyLFxyXG4gICAgICBMYXllcnMuUGF1c2UsXHJcbiAgICApO1xyXG5cclxuICAgIHJlc3VtZUJ1dHRvbi5zaXplLnggPSBidXR0b25XaWR0aDtcclxuICAgIHJlc3VtZUJ1dHRvbi5zaXplLnkgPSBidXR0b25IZWlnaHQ7XHJcbiAgICByZXN1bWVCdXR0b24ub25DbGljayA9ICgpID0+IHtcclxuICAgICAgSW5wdXQuZW5hYmxlSW5wdXQoKTtcclxuICAgICAgdGhpcy51aUxheWVycy5nZXQoTGF5ZXJzLlBhdXNlKS5zZXRIaWRkZW4odHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IG1lbnVCdXR0b24gPSB0aGlzLm5ld0J1dHRvbihcclxuICAgICAgbmV3IFZlYzIoMTAwLCA3MCArIDM4KSxcclxuICAgICAgXCJNRU5VXCIsXHJcbiAgICAgIDUyLFxyXG4gICAgICBMYXllcnMuUGF1c2UsXHJcbiAgICApO1xyXG4gICAgbWVudUJ1dHRvbi5vbkNsaWNrID0gKCkgPT4ge1xyXG4gICAgICBJbnB1dC5lbmFibGVJbnB1dCgpO1xyXG4gICAgfTtcclxuICAgIG1lbnVCdXR0b24ub25DbGlja0V2ZW50SWQgPSBFdmVudHMuTUFJTl9NRU5VO1xyXG4gICAgbWVudUJ1dHRvbi5zaXplLnggPSBidXR0b25XaWR0aDtcclxuICAgIG1lbnVCdXR0b24uc2l6ZS55ID0gYnV0dG9uSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGhhbmRsZUhlYWx0aENoYW5nZShjdXJyZW50SGVhbHRoOiBudW1iZXIsIG1heEhlYWx0aDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBjb25zb2xlLmxvZyhjdXJyZW50SGVhbHRoKTtcclxuICAgIGxldCB1bml0ID0gdGhpcy5oZWFsdGhCYXJCZy5zaXplLnggLyBtYXhIZWFsdGg7XHJcblxyXG4gICAgdGhpcy5oZWFsdGhCYXIuc2l6ZS5zZXQoXHJcbiAgICAgIHRoaXMuaGVhbHRoQmFyQmcuc2l6ZS54IC0gdW5pdCAqIChtYXhIZWFsdGggLSBjdXJyZW50SGVhbHRoKSxcclxuICAgICAgdGhpcy5oZWFsdGhCYXJCZy5zaXplLnksXHJcbiAgICApO1xyXG4gICAgdGhpcy5oZWFsdGhCYXIucG9zaXRpb24uc2V0KFxyXG4gICAgICB0aGlzLmhlYWx0aEJhckJnLnBvc2l0aW9uLnggLVxyXG4gICAgICAgICh1bml0IC8gMiAvIHRoaXMuZ2V0Vmlld1NjYWxlKCkpICogKG1heEhlYWx0aCAtIGN1cnJlbnRIZWFsdGgpLFxyXG4gICAgICB0aGlzLmhlYWx0aEJhckJnLnBvc2l0aW9uLnksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgYWRkTGV2ZWxFbmQoc3RhcnRpbmdUaWxlOiBWZWMyLCBzaXplOiBWZWMyKTogdm9pZCB7XHJcbiAgICB0aGlzLmxldmVsRW5kQXJlYSA9IDxSZWN0PnRoaXMuYWRkLmdyYXBoaWMoR3JhcGhpY1R5cGUuUkVDVCwgTGF5ZXJzLk1haW4sIHtcclxuICAgICAgcG9zaXRpb246IHN0YXJ0aW5nVGlsZSxcclxuICAgICAgc2l6ZTogc2l6ZSxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5sZXZlbEVuZEFyZWEuYWRkUGh5c2ljcyh1bmRlZmluZWQsIHVuZGVmaW5lZCwgZmFsc2UsIHRydWUpO1xyXG4gICAgdGhpcy5sZXZlbEVuZEFyZWEuc2V0VHJpZ2dlcihcclxuICAgICAgUGh5c2ljc0dyb3Vwcy5QTEFZRVJfUEhZUyxcclxuICAgICAgRXZlbnRzLkVOVEVSX0xFVkVMX0VORCxcclxuICAgICAgbnVsbCxcclxuICAgICk7XHJcbiAgICB0aGlzLmxldmVsRW5kQXJlYS5jb2xvciA9IG5ldyBDb2xvcigyNTUsIDI1NSwgMjU1LCAxKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgbmV3QnV0dG9uKFxyXG4gICAgcG9zaXRpb246IFZlYzIsXHJcbiAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgICBmb250U2l6ZTogbnVtYmVyLFxyXG4gICAgbGF5ZXI6IExheWVycyxcclxuICApOiBCdXR0b24ge1xyXG4gICAgY29uc3QgYnV0dG9uID0gPEJ1dHRvbj50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIGxheWVyLCB7XHJcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcclxuICAgICAgdGV4dDogdGV4dCxcclxuICAgIH0pO1xyXG4gICAgYnV0dG9uLmJvcmRlckNvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICBidXR0b24uYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgYnV0dG9uLmJvcmRlclJhZGl1cyA9IDA7XHJcbiAgICBidXR0b24uc2V0UGFkZGluZyhuZXcgVmVjMig1MCwgMTApKTtcclxuICAgIGJ1dHRvbi5mb250ID0gXCJNRUdBUElYXCI7XHJcbiAgICBidXR0b24uZm9udFNpemUgPSBmb250U2l6ZTtcclxuICAgIGJ1dHRvbi50ZXh0Q29sb3IgPSB0aGlzLnRleHRDb2xvcjtcclxuICAgIGJ1dHRvbi5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMTYsIDE0LCAxOCwgMSk7XHJcblxyXG4gICAgYnV0dG9uLnNjYWxlLnNldChcclxuICAgICAgMSAvIHRoaXMudmlld3BvcnQuZ2V0Wm9vbUxldmVsKCksXHJcbiAgICAgIDEgLyB0aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpLFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gYnV0dG9uO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgR2FtZUxldmVsIGZyb20gXCIuL0dhbWVMZXZlbFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdob3N0IGZyb20gXCIuLi9FbmVteS9HaG9zdC9HaG9zdFwiO1xyXG5pbXBvcnQgeyBMYXllcnMgfSBmcm9tIFwiLi9HYW1lTGV2ZWxcIjtcclxuaW1wb3J0IHsgR2hvc3RUeXBlIH0gZnJvbSBcIi4uL0VuZW15L0dob3N0L0dob3N0XCI7XHJcbmltcG9ydCBMZXZlbDIgZnJvbSBcIi4vTGV2ZWwyXCI7XHJcblxyXG5jb25zdCBHaG9zdFBvc2l0aW9uczogQXJyYXk8VmVjMj4gPSBbXHJcbiAgbmV3IFZlYzIoMzg0MCwgNDE2KSxcclxuICBuZXcgVmVjMig0MTYwLCA1MTIpLFxyXG4gIG5ldyBWZWMyKDM5MDQsIDQ0OCksXHJcbl1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsMSBleHRlbmRzIEdhbWVMZXZlbCB7XHJcbiAgXHJcbiAgbG9hZFNjZW5lKCkge1xyXG4gICAgc3VwZXIubG9hZFNjZW5lKCk7XHJcbiAgICB0aGlzLmxvYWQudGlsZW1hcChcInRpbGVtYXBcIiwgXCJhc3NldHMvdGlsZW1hcHMvRGVidWcvTGV2ZWwxLmpzb25cIik7XHJcbiAgfVxyXG5cclxuICBzdGFydFNjZW5lKCkge1xyXG4gICAgc3VwZXIuc3RhcnRTY2VuZSgpO1xyXG4gICAgdGhpcy5wbGF5ZXIubm9kZS5wb3NpdGlvbiA9IG5ldyBWZWMyKDEwMCwgMTAwMCk7XHJcbiAgICB0aGlzLmNhbWVyYS5ub2RlLnBvc2l0aW9uID0gdGhpcy5wbGF5ZXIubm9kZS5wb3NpdGlvbi5jbG9uZSgpO1xyXG4gICAgdGhpcy5hZGQudGlsZW1hcChcInRpbGVtYXBcIiwgbmV3IFZlYzIoMSwgMSkpO1xyXG4gICAgdGhpcy52aWV3cG9ydC5zZXRCb3VuZHMoMCwgMCwgNjQwMCwgMTI4MCk7XHJcblxyXG4gICAgdGhpcy5uZXh0TGV2ZWwgPSBMZXZlbDI7XHJcblxyXG4gICAgdGhpcy5hZGRMZXZlbEVuZChuZXcgVmVjMig0NTc2LCAxNjApLCBuZXcgVmVjMigzMiwgMTI4KSk7XHJcblxyXG4gICAgdGhpcy5pbml0aWFsaXplR2hvc3RzKCk7XHJcbiAgfVxyXG5cclxuICBpbml0aWFsaXplR2hvc3RzKCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBHaG9zdFBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBnaG9zdCA9IG5ldyBHaG9zdChcclxuICAgICAgICB0aGlzLmFkZC5hbmltYXRlZFNwcml0ZShcIlJlZFNvdWxcIiwgTGF5ZXJzLk1haW4pLFxyXG4gICAgICAgIEdob3N0UG9zaXRpb25zW2ldLFxyXG4gICAgICAgIEdob3N0VHlwZS5SRUQsXHJcbiAgICAgICk7XHJcblxyXG4gICAgICB0aGlzLmVuZW1pZXMucHVzaChnaG9zdCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBHYW1lTGV2ZWwgZnJvbSBcIi4vR2FtZUxldmVsXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGV2ZWwyIGV4dGVuZHMgR2FtZUxldmVsIHtcclxuICBsb2FkU2NlbmUoKSB7XHJcbiAgICBzdXBlci5sb2FkU2NlbmUoKTtcclxuICAgIHRoaXMubG9hZC50aWxlbWFwKFwidGlsZW1hcFwiLCBcImFzc2V0cy90aWxlbWFwcy9EZWJ1Zy9MZXZlbDEuanNvblwiKTtcclxuICB9XHJcblxyXG4gIHN0YXJ0U2NlbmUoKSB7XHJcbiAgICBzdXBlci5zdGFydFNjZW5lKCk7XHJcbiAgICB0aGlzLnBsYXllci5ub2RlLnBvc2l0aW9uID0gbmV3IFZlYzIoMTAwLCAxMDAwKTtcclxuICAgIHRoaXMuY2FtZXJhLm5vZGUucG9zaXRpb24gPSB0aGlzLnBsYXllci5ub2RlLnBvc2l0aW9uLmNsb25lKCk7XHJcbiAgICB0aGlzLmFkZC50aWxlbWFwKFwidGlsZW1hcFwiLCBuZXcgVmVjMigxLCAxKSk7XHJcbiAgICB0aGlzLnZpZXdwb3J0LnNldEJvdW5kcygwLCAwLCA2NDAwLCAxMjgwKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IEdhbWVMZXZlbCBmcm9tIFwiLi9HYW1lTGV2ZWxcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbDMgZXh0ZW5kcyBHYW1lTGV2ZWwge1xyXG4gIGxvYWRTY2VuZSgpIHtcclxuICAgIHN1cGVyLmxvYWRTY2VuZSgpO1xyXG4gICAgdGhpcy5sb2FkLnRpbGVtYXAoXCJ0aWxlbWFwXCIsIFwiYXNzZXRzL3RpbGVtYXBzL0RlYnVnL0xldmVsMS5qc29uXCIpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRTY2VuZSgpIHtcclxuICAgIHN1cGVyLnN0YXJ0U2NlbmUoKTtcclxuICAgIHRoaXMucGxheWVyLm5vZGUucG9zaXRpb24gPSBuZXcgVmVjMigxMDAsIDEwMDApO1xyXG4gICAgdGhpcy5jYW1lcmEubm9kZS5wb3NpdGlvbiA9IHRoaXMucGxheWVyLm5vZGUucG9zaXRpb24uY2xvbmUoKTtcclxuICAgIHRoaXMuYWRkLnRpbGVtYXAoXCJ0aWxlbWFwXCIsIG5ldyBWZWMyKDEsIDEpKTtcclxuICAgIHRoaXMudmlld3BvcnQuc2V0Qm91bmRzKDAsIDAsIDY0MDAsIDEyODApO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgR2FtZUxldmVsIGZyb20gXCIuL0dhbWVMZXZlbFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsNCBleHRlbmRzIEdhbWVMZXZlbCB7XHJcbiAgbG9hZFNjZW5lKCkge1xyXG4gICAgc3VwZXIubG9hZFNjZW5lKCk7XHJcbiAgICB0aGlzLmxvYWQudGlsZW1hcChcInRpbGVtYXBcIiwgXCJhc3NldHMvdGlsZW1hcHMvRGVidWcvTGV2ZWwxLmpzb25cIik7XHJcbiAgfVxyXG5cclxuICBzdGFydFNjZW5lKCkge1xyXG4gICAgc3VwZXIuc3RhcnRTY2VuZSgpO1xyXG4gICAgdGhpcy5wbGF5ZXIubm9kZS5wb3NpdGlvbiA9IG5ldyBWZWMyKDEwMCwgMTAwMCk7XHJcbiAgICB0aGlzLmNhbWVyYS5ub2RlLnBvc2l0aW9uID0gdGhpcy5wbGF5ZXIubm9kZS5wb3NpdGlvbi5jbG9uZSgpO1xyXG4gICAgdGhpcy5hZGQudGlsZW1hcChcInRpbGVtYXBcIiwgbmV3IFZlYzIoMSwgMSkpO1xyXG4gICAgdGhpcy52aWV3cG9ydC5zZXRCb3VuZHMoMCwgMCwgNjQwMCwgMTI4MCk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBHYW1lTGV2ZWwgZnJvbSBcIi4vR2FtZUxldmVsXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGV2ZWw1IGV4dGVuZHMgR2FtZUxldmVsIHtcclxuICBsb2FkU2NlbmUoKSB7XHJcbiAgICBzdXBlci5sb2FkU2NlbmUoKTtcclxuICAgIHRoaXMubG9hZC50aWxlbWFwKFwidGlsZW1hcFwiLCBcImFzc2V0cy90aWxlbWFwcy9EZWJ1Zy9MZXZlbDEuanNvblwiKTtcclxuICB9XHJcblxyXG4gIHN0YXJ0U2NlbmUoKSB7XHJcbiAgICBzdXBlci5zdGFydFNjZW5lKCk7XHJcbiAgICB0aGlzLnBsYXllci5ub2RlLnBvc2l0aW9uID0gbmV3IFZlYzIoMTAwLCAxMDAwKTtcclxuICAgIHRoaXMuY2FtZXJhLm5vZGUucG9zaXRpb24gPSB0aGlzLnBsYXllci5ub2RlLnBvc2l0aW9uLmNsb25lKCk7XHJcbiAgICB0aGlzLmFkZC50aWxlbWFwKFwidGlsZW1hcFwiLCBuZXcgVmVjMigxLCAxKSk7XHJcbiAgICB0aGlzLnZpZXdwb3J0LnNldEJvdW5kcygwLCAwLCA2NDAwLCAxMjgwKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IEdhbWVMZXZlbCBmcm9tIFwiLi9HYW1lTGV2ZWxcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbDYgZXh0ZW5kcyBHYW1lTGV2ZWwge1xyXG4gIGxvYWRTY2VuZSgpIHtcclxuICAgIHN1cGVyLmxvYWRTY2VuZSgpO1xyXG4gICAgdGhpcy5sb2FkLnRpbGVtYXAoXCJ0aWxlbWFwXCIsIFwiYXNzZXRzL3RpbGVtYXBzL0RlYnVnL0xldmVsMS5qc29uXCIpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRTY2VuZSgpIHtcclxuICAgIHN1cGVyLnN0YXJ0U2NlbmUoKTtcclxuICAgIHRoaXMucGxheWVyLm5vZGUucG9zaXRpb24gPSBuZXcgVmVjMigxMDAsIDEwMDApO1xyXG4gICAgdGhpcy5jYW1lcmEubm9kZS5wb3NpdGlvbiA9IHRoaXMucGxheWVyLm5vZGUucG9zaXRpb24uY2xvbmUoKTtcclxuICAgIHRoaXMuYWRkLnRpbGVtYXAoXCJ0aWxlbWFwXCIsIG5ldyBWZWMyKDEsIDEpKTtcclxuICAgIHRoaXMudmlld3BvcnQuc2V0Qm91bmRzKDAsIDAsIDY0MDAsIDEyODApO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XHJcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgTGFiZWwsIHsgSEFsaWduIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuaW1wb3J0IFVJTGF5ZXIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL0xheWVycy9VSUxheWVyXCI7XHJcbmltcG9ydCB7IFBoeXNpY3NHcm91cHMgfSBmcm9tIFwiLi4vLi4vZ2xvYmFsc1wiO1xyXG5pbXBvcnQgTGV2ZWwxIGZyb20gXCIuL0xldmVsMVwiO1xyXG5pbXBvcnQgTGV2ZWwyIGZyb20gXCIuL0xldmVsMlwiO1xyXG5pbXBvcnQgTGV2ZWwzIGZyb20gXCIuL0xldmVsM1wiO1xyXG5pbXBvcnQgTGV2ZWw0IGZyb20gXCIuL0xldmVsNFwiO1xyXG5pbXBvcnQgTGV2ZWw1IGZyb20gXCIuL0xldmVsNVwiO1xyXG5pbXBvcnQgTGV2ZWw2IGZyb20gXCIuL0xldmVsNlwiO1xyXG5cclxuZW51bSBMYXllcnMge1xyXG4gIE1haW4gPSBcIm1haW5cIixcclxuICBMZXZlbHMgPSBcImxldmVsXCIsXHJcbiAgQ29udHJvbHMgPSBcImNvbnRyb2xcIixcclxuICBIZWxwID0gXCJoZWxwXCIsXHJcbiAgQmFjayA9IFwiYmFja1wiLFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWluTWVudSBleHRlbmRzIFNjZW5lIHtcclxuICBzY3JlZW5zOiBSZWNvcmQ8TGF5ZXJzIHwgc3RyaW5nLCBVSUxheWVyPjtcclxuICB0ZXh0Q29sb3IgPSBuZXcgQ29sb3IoMjMxLCAyMjQsIDI0MSk7XHJcbiAgY3VycmVudFNjcmVlbjogTGF5ZXJzO1xyXG4gIGxvYWRTY2VuZSgpIHtcclxuICAgIHRoaXMubG9hZC5pbWFnZShcImxvZ29cIiwgXCIvYXNzZXRzL2ltYWdlcy9hdXRvcHN5X2xvZ28ucG5nXCIpO1xyXG4gICAgdGhpcy5zY3JlZW5zID0ge1xyXG4gICAgICBbTGF5ZXJzLk1haW5dOiB0aGlzLmFkZFVJTGF5ZXIoTGF5ZXJzLk1haW4pLFxyXG4gICAgICBbTGF5ZXJzLkxldmVsc106IHRoaXMuYWRkVUlMYXllcihMYXllcnMuTGV2ZWxzKSxcclxuICAgICAgW0xheWVycy5Db250cm9sc106IHRoaXMuYWRkVUlMYXllcihMYXllcnMuQ29udHJvbHMpLFxyXG4gICAgICBbTGF5ZXJzLkhlbHBdOiB0aGlzLmFkZFVJTGF5ZXIoTGF5ZXJzLkhlbHApLFxyXG4gICAgICBbTGF5ZXJzLkJhY2tdOiB0aGlzLmFkZFVJTGF5ZXIoTGF5ZXJzLkJhY2spLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN0YXJ0U2NlbmUoKSB7XHJcbiAgICAvLyBDZW50ZXIgdGhlIHZpZXdwb3J0XHJcbiAgICBjb25zdCBoYWxmU2l6ZSA9IHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKTtcclxuICAgIHRoaXMudmlld3BvcnQuc2V0Rm9jdXMoaGFsZlNpemUpO1xyXG4gICAgdGhpcy52aWV3cG9ydC5zZXRab29tTGV2ZWwoMSk7XHJcbiAgICB0aGlzLmN1cnJlbnRTY3JlZW4gPSBMYXllcnMuTWFpbjtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHNjcmVlbnNLZXkgaW4gdGhpcy5zY3JlZW5zKVxyXG4gICAgICB0aGlzLnNjcmVlbnNbc2NyZWVuc0tleV0uc2V0SGlkZGVuKHRydWUpO1xyXG5cclxuICAgIHRoaXMuaW5pdE1haW5NZW51KCk7XHJcbiAgICB0aGlzLmluaXRMZXZlbHNMYXllcigpO1xyXG4gICAgdGhpcy5pbml0SGVscExheWVyKCk7XHJcbiAgICB0aGlzLmluaXRDb250cm9sc01lbnUoKTtcclxuICAgIHRoaXMuaW5pdEJhY2tMYXllcigpO1xyXG5cclxuICAgIHRoaXMuc2NyZWVuc1tMYXllcnMuTWFpbl0uc2V0SGlkZGVuKGZhbHNlKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2hhbmdlTGF5ZXIobmV3TGF5ZXI6IExheWVycykge1xyXG4gICAgdGhpcy5zY3JlZW5zW3RoaXMuY3VycmVudFNjcmVlbl0uZGlzYWJsZSgpO1xyXG4gICAgdGhpcy5zY3JlZW5zW25ld0xheWVyXS5lbmFibGUoKTtcclxuICAgIHRoaXMuY3VycmVudFNjcmVlbiA9IG5ld0xheWVyO1xyXG4gICAgdGhpcy5zY3JlZW5zW0xheWVycy5CYWNrXS5zZXRIaWRkZW4odGhpcy5jdXJyZW50U2NyZWVuID09IExheWVycy5NYWluKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaW5pdEJhY2tMYXllcigpIHtcclxuICAgIGNvbnN0IGJ1dHRvbldpZHRoID0gMTIwO1xyXG4gICAgY29uc3QgYmFja0J1dHRvbiA9IHRoaXMubmV3QnV0dG9uKFxyXG4gICAgICBuZXcgVmVjMihidXR0b25XaWR0aCAvIDIsIHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS55ICogMiAtIDEwMCksXHJcbiAgICAgIFwiQkFDS1wiLFxyXG4gICAgICA0MCxcclxuICAgICAgTGF5ZXJzLkJhY2ssXHJcbiAgICApO1xyXG4gICAgYmFja0J1dHRvbi5zaXplLnggPSBidXR0b25XaWR0aDtcclxuICAgIGJhY2tCdXR0b24uc2l6ZS55ID0gNzA7XHJcbiAgICBiYWNrQnV0dG9uLm9uQ2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuY2hhbmdlTGF5ZXIoTGF5ZXJzLk1haW4pO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaW5pdEhlbHBMYXllcigpIHtcclxuICAgIFtcclxuICAgICAgXCJZb3UgcGxheSBhcyBhbiB1bmRlcnRha2VyIGFuZCBoYXZlIHRvIGh1bnQgc291bHMgdGhhdFwiLFxyXG4gICAgICBcIiBoYXZlIGVzY2FwZWQgZnJvbSBoZWxsIHVzaW5nIGFuIGFyc2VuYWwgb2Ygd2VhcG9ucy4gXCIsXHJcbiAgICBdLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCBoZWxwTGluZSA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoXHJcbiAgICAgICAgVUlFbGVtZW50VHlwZS5MQUJFTCxcclxuICAgICAgICBMYXllcnMuSGVscCxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIodGhpcy52aWV3cG9ydC5nZXRDZW50ZXIoKS54LCAxMDAgKyBpbmRleCAqIDQwKSxcclxuICAgICAgICAgIHRleHQ6IHZhbHVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICk7XHJcbiAgICAgIGhlbHBMaW5lLnRleHRDb2xvciA9IHRoaXMudGV4dENvbG9yO1xyXG4gICAgICBoZWxwTGluZS5mb250ID0gXCJNaXN0ZXIgUGl4ZWxcIjtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGF1dGhvckxpbmVXaWR0aCA9IDUwMDtcclxuICAgIGNvbnN0IGF1dGhvckxpbmUgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFxyXG4gICAgICBVSUVsZW1lbnRUeXBlLkxBQkVMLFxyXG4gICAgICBMYXllcnMuSGVscCxcclxuICAgICAge1xyXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMihcclxuICAgICAgICAgIHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS54ICogMiAtIGF1dGhvckxpbmVXaWR0aCAvIDIgLSAxMCxcclxuICAgICAgICAgIHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS55ICogMiAtIDIwLFxyXG4gICAgICAgICksXHJcbiAgICAgICAgdGV4dDogXCJCeSBBbHZpbiBNZWksIFl1LVhpYW5nIFpoZW5nLCBBbmRyZXcgVG9uXCIsXHJcbiAgICAgIH0sXHJcbiAgICApO1xyXG4gICAgYXV0aG9yTGluZS5zaXplLnggPSBhdXRob3JMaW5lV2lkdGg7XHJcbiAgICBhdXRob3JMaW5lLnNldEhBbGlnbihIQWxpZ24uUklHSFQpO1xyXG4gICAgYXV0aG9yTGluZS50ZXh0Q29sb3IgPSB0aGlzLnRleHRDb2xvcjtcclxuICAgIGF1dGhvckxpbmUuZm9udCA9IFwiTWlzdGVyIFBpeGVsXCI7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGluaXRMZXZlbHNMYXllcigpIHtcclxuICAgIGNvbnN0IGZvbnRTaXplID0gNDA7XHJcbiAgICBjb25zdCBidXR0b25TaXplID0gbmV3IFZlYzIoNzAsIDcwKTtcclxuICAgIGNvbnN0IHBhZGRpbmdTaXplID0gbmV3IFZlYzIoMTUsIDE1KTtcclxuXHJcbiAgICBjb25zdCBsZXZlbE9uZSA9IHRoaXMubmV3QnV0dG9uKFxyXG4gICAgICBuZXcgVmVjMigyNDAsIDU5MCksXHJcbiAgICAgIFwiMVwiLFxyXG4gICAgICBmb250U2l6ZSxcclxuICAgICAgTGF5ZXJzLkxldmVscyxcclxuICAgICk7XHJcbiAgICBjb25zdCBsZXZlbFR3byA9IHRoaXMubmV3QnV0dG9uKFxyXG4gICAgICBuZXcgVmVjMigzODAsIDI5MCksXHJcbiAgICAgIFwiMlwiLFxyXG4gICAgICBmb250U2l6ZSxcclxuICAgICAgTGF5ZXJzLkxldmVscyxcclxuICAgICk7XHJcbiAgICBjb25zdCBsZXZlbFRocmVlID0gdGhpcy5uZXdCdXR0b24oXHJcbiAgICAgIG5ldyBWZWMyKDU2MCwgNDgwKSxcclxuICAgICAgXCIzXCIsXHJcbiAgICAgIGZvbnRTaXplLFxyXG4gICAgICBMYXllcnMuTGV2ZWxzLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IGxldmVsRm91ciA9IHRoaXMubmV3QnV0dG9uKFxyXG4gICAgICBuZXcgVmVjMig3ODAsIDU1MCksXHJcbiAgICAgIFwiNFwiLFxyXG4gICAgICBmb250U2l6ZSxcclxuICAgICAgTGF5ZXJzLkxldmVscyxcclxuICAgICk7XHJcbiAgICBjb25zdCBsZXZlbEZpdmUgPSB0aGlzLm5ld0J1dHRvbihcclxuICAgICAgbmV3IFZlYzIoOTUwLCAzNTApLFxyXG4gICAgICBcIjVcIixcclxuICAgICAgZm9udFNpemUsXHJcbiAgICAgIExheWVycy5MZXZlbHMsXHJcbiAgICApO1xyXG4gICAgY29uc3QgbGV2ZWxTaXggPSB0aGlzLm5ld0J1dHRvbihcclxuICAgICAgbmV3IFZlYzIoODIwLCAxMjApLFxyXG4gICAgICBcIjZcIixcclxuICAgICAgZm9udFNpemUsXHJcbiAgICAgIExheWVycy5MZXZlbHMsXHJcbiAgICApO1xyXG5cclxuICAgIGxldmVsT25lLmZvbnQgPSBcIk1pc3RlciBQaXhlbFwiO1xyXG4gICAgbGV2ZWxPbmUuc2V0UGFkZGluZyhwYWRkaW5nU2l6ZSk7XHJcbiAgICBsZXZlbE9uZS5zaXplID0gYnV0dG9uU2l6ZTtcclxuICAgIGxldmVsT25lLm9uQ2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoTGV2ZWwxKTtcclxuICAgIH07XHJcblxyXG4gICAgbGV2ZWxUd28uZm9udCA9IFwiTWlzdGVyIFBpeGVsXCI7XHJcbiAgICBsZXZlbFR3by5zZXRQYWRkaW5nKHBhZGRpbmdTaXplKTtcclxuICAgIGxldmVsVHdvLnNpemUgPSBidXR0b25TaXplO1xyXG4gICAgbGV2ZWxUd28ub25DbGljayA9ICgpID0+IHtcclxuICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShMZXZlbDIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsZXZlbFRocmVlLmZvbnQgPSBcIk1pc3RlciBQaXhlbFwiO1xyXG4gICAgbGV2ZWxUaHJlZS5zZXRQYWRkaW5nKHBhZGRpbmdTaXplKTtcclxuICAgIGxldmVsVGhyZWUuc2l6ZSA9IGJ1dHRvblNpemU7XHJcbiAgICBsZXZlbFRocmVlLm9uQ2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoTGV2ZWwzKTtcclxuICAgIH07XHJcblxyXG4gICAgbGV2ZWxGb3VyLmZvbnQgPSBcIk1pc3RlciBQaXhlbFwiO1xyXG4gICAgbGV2ZWxGb3VyLnNldFBhZGRpbmcocGFkZGluZ1NpemUpO1xyXG4gICAgbGV2ZWxGb3VyLnNpemUgPSBidXR0b25TaXplO1xyXG4gICAgbGV2ZWxGb3VyLm9uQ2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoTGV2ZWw0KTtcclxuICAgIH07XHJcblxyXG4gICAgbGV2ZWxGaXZlLmZvbnQgPSBcIk1pc3RlciBQaXhlbFwiO1xyXG4gICAgbGV2ZWxGaXZlLnNldFBhZGRpbmcocGFkZGluZ1NpemUpO1xyXG4gICAgbGV2ZWxGaXZlLnNpemUgPSBidXR0b25TaXplO1xyXG4gICAgbGV2ZWxGaXZlLm9uQ2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoTGV2ZWw1KTtcclxuICAgIH07XHJcblxyXG4gICAgbGV2ZWxTaXguZm9udCA9IFwiTWlzdGVyIFBpeGVsXCI7XHJcbiAgICBsZXZlbFNpeC5zZXRQYWRkaW5nKHBhZGRpbmdTaXplKTtcclxuICAgIGxldmVsU2l4LnNpemUgPSBidXR0b25TaXplO1xyXG4gICAgbGV2ZWxTaXgub25DbGljayA9ICgpID0+IHtcclxuICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShMZXZlbDYpO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaW5pdENvbnRyb2xzTWVudSgpIHtcclxuICAgIFtcclxuICAgICAgXCIoQSksIChEKTogTW92ZSBsZWZ0IGFuZCByaWdodCByZXNwZWN0aXZlbHkuXCIsXHJcbiAgICAgIFwiKFNwYWNlKTogSnVtcC5cIixcclxuICAgICAgXCIoSik6IEF0dGFjay5cIixcclxuICAgICAgXCIoU2hpZnQpOiBEYXNoLlwiLFxyXG4gICAgICBcIihFU0MpOiBQYXVzZSBnYW1lLlwiLFxyXG4gICAgXS5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgY29udHJvbExpbmUgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFxyXG4gICAgICAgIFVJRWxlbWVudFR5cGUuTEFCRUwsXHJcbiAgICAgICAgTGF5ZXJzLkNvbnRyb2xzLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMig2MDAsIDIwMCArIDQwICogaW5kZXgpLFxyXG4gICAgICAgICAgdGV4dDogdmFsdWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgKTtcclxuICAgICAgY29udHJvbExpbmUudGV4dENvbG9yID0gdGhpcy50ZXh0Q29sb3I7XHJcbiAgICAgIGNvbnRyb2xMaW5lLmZvbnQgPSBcIk1pc3RlciBQaXhlbFwiO1xyXG4gICAgICBjb250cm9sTGluZS5zaXplLnggPSAxMDAwO1xyXG4gICAgICBjb250cm9sTGluZS5zZXRIQWxpZ24oSEFsaWduLkxFRlQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGluaXRNYWluTWVudSgpIHtcclxuICAgIHRoaXMuYWRkLnNwcml0ZShcImxvZ29cIiwgTGF5ZXJzLk1haW4pLnBvc2l0aW9uID0gbmV3IFZlYzIoXHJcbiAgICAgIHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS54LFxyXG4gICAgICAyMDAsXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGJ1dHRvbldpZHRoOiBudW1iZXIgPSA1MDA7XHJcblxyXG4gICAgY29uc3QgcGxheUJ1dHRvbiA9IHRoaXMubmV3QnV0dG9uKFxyXG4gICAgICBuZXcgVmVjMihidXR0b25XaWR0aCAvIDIsIDQwMCksXHJcbiAgICAgIFwiUExBWVwiLFxyXG4gICAgICA2MCxcclxuICAgICAgTGF5ZXJzLk1haW4sXHJcbiAgICApO1xyXG4gICAgcGxheUJ1dHRvbi5zZXRIQWxpZ24oSEFsaWduLkxFRlQpO1xyXG4gICAgcGxheUJ1dHRvbi5zaXplLnggPSBidXR0b25XaWR0aDtcclxuICAgIHBsYXlCdXR0b24uc2l6ZS55ID0gODA7XHJcbiAgICBwbGF5QnV0dG9uLm9uQ2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgIGxldCBzY2VuZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgcGh5c2ljczoge1xyXG4gICAgICAgICAgZ3JvdXBOYW1lczogW1xyXG4gICAgICAgICAgICBQaHlzaWNzR3JvdXBzLlBMQVlFUl9QSFlTLFxyXG4gICAgICAgICAgICBQaHlzaWNzR3JvdXBzLkVORU1ZX1BIWVMsXHJcbiAgICAgICAgICAgIFBoeXNpY3NHcm91cHMuSElUQk9YX1BIWVMsXHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgY29sbGlzaW9uczogW1xyXG4gICAgICAgICAgICBbMCwgMSwgMV0sXHJcbiAgICAgICAgICAgIFswLCAxLCAxXSxcclxuICAgICAgICAgICAgWzAsIDAsIDBdLFxyXG4gICAgICAgICAgXSxcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKExldmVsMSwge30sIHNjZW5lT3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGxldmVsc0J1dHRvbiA9IHRoaXMubmV3QnV0dG9uKFxyXG4gICAgICBuZXcgVmVjMihidXR0b25XaWR0aCAvIDIsIDQwMCArIDkwKSxcclxuICAgICAgXCJMRVZFTFNcIixcclxuICAgICAgNjAsXHJcbiAgICAgIExheWVycy5NYWluLFxyXG4gICAgKTtcclxuICAgIGxldmVsc0J1dHRvbi5zZXRIQWxpZ24oSEFsaWduLkxFRlQpO1xyXG4gICAgbGV2ZWxzQnV0dG9uLnNpemUueCA9IGJ1dHRvbldpZHRoO1xyXG4gICAgbGV2ZWxzQnV0dG9uLnNpemUueSA9IDgwO1xyXG4gICAgbGV2ZWxzQnV0dG9uLm9uQ2xpY2sgPSAoKSA9PiB0aGlzLmNoYW5nZUxheWVyKExheWVycy5MZXZlbHMpO1xyXG5cclxuICAgIGNvbnN0IGNvbnRyb2xzQnV0dG9uID0gdGhpcy5uZXdCdXR0b24oXHJcbiAgICAgIG5ldyBWZWMyKGJ1dHRvbldpZHRoIC8gMiwgNDAwICsgOTAgKiAyKSxcclxuICAgICAgXCJDT05UUk9MU1wiLFxyXG4gICAgICA2MCxcclxuICAgICAgTGF5ZXJzLk1haW4sXHJcbiAgICApO1xyXG4gICAgY29udHJvbHNCdXR0b24uc2V0SEFsaWduKEhBbGlnbi5MRUZUKTtcclxuICAgIGNvbnRyb2xzQnV0dG9uLnNpemUueCA9IGJ1dHRvbldpZHRoO1xyXG4gICAgY29udHJvbHNCdXR0b24uc2l6ZS55ID0gODA7XHJcbiAgICBjb250cm9sc0J1dHRvbi5vbkNsaWNrID0gKCkgPT4gdGhpcy5jaGFuZ2VMYXllcihMYXllcnMuQ29udHJvbHMpO1xyXG5cclxuICAgIGNvbnN0IGhlbHBCdXR0b25XaWR0aDogbnVtYmVyID0gMTMwO1xyXG4gICAgY29uc3QgaGVscEJ1dHRvbiA9IHRoaXMubmV3QnV0dG9uKFxyXG4gICAgICBuZXcgVmVjMih0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueCAqIDIgLSBoZWxwQnV0dG9uV2lkdGggLyAyLCA3MDApLFxyXG4gICAgICBcIkhFTFBcIixcclxuICAgICAgNTAsXHJcbiAgICAgIExheWVycy5NYWluLFxyXG4gICAgKTtcclxuICAgIGhlbHBCdXR0b24uc2V0SEFsaWduKEhBbGlnbi5DRU5URVIpO1xyXG4gICAgaGVscEJ1dHRvbi5zaXplLnggPSBoZWxwQnV0dG9uV2lkdGg7XHJcbiAgICBoZWxwQnV0dG9uLnNpemUueSA9IDgwO1xyXG4gICAgaGVscEJ1dHRvbi5vbkNsaWNrID0gKCkgPT4gdGhpcy5jaGFuZ2VMYXllcihMYXllcnMuSGVscCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG5ld0J1dHRvbihcclxuICAgIHBvc2l0aW9uOiBWZWMyLFxyXG4gICAgdGV4dDogc3RyaW5nLFxyXG4gICAgZm9udFNpemU6IG51bWJlcixcclxuICAgIGxheWVyOiBMYXllcnMsXHJcbiAgKTogQnV0dG9uIHtcclxuICAgIGNvbnN0IGJ1dHRvbiA9IDxCdXR0b24+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBsYXllciwge1xyXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24sXHJcbiAgICAgIHRleHQ6IHRleHQsXHJcbiAgICB9KTtcclxuICAgIGJ1dHRvbi5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgIGJ1dHRvbi5ib3JkZXJDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgYnV0dG9uLmJvcmRlcldpZHRoID0gMjtcclxuICAgIGJ1dHRvbi5ib3JkZXJSYWRpdXMgPSAwO1xyXG4gICAgYnV0dG9uLnNldFBhZGRpbmcobmV3IFZlYzIoNTAsIDEwKSk7XHJcbiAgICBidXR0b24uZm9udCA9IFwiTUVHQVBJWFwiO1xyXG4gICAgYnV0dG9uLmZvbnRTaXplID0gZm9udFNpemU7XHJcbiAgICBidXR0b24udGV4dENvbG9yID0gdGhpcy50ZXh0Q29sb3I7XHJcblxyXG4gICAgY29uc3QgdHJhbnNXaGl0ZSA9IG5ldyBDb2xvcigyNTUsIDI1NSwgMjU1LCAwLjEpO1xyXG4gICAgY29uc3QgaW52aXNpYmxlV2hpdGUgPSBuZXcgQ29sb3IoMjU1LCAyNTUsIDI1NSwgMCk7XHJcbiAgICBidXR0b24ub25FbnRlciA9ICgpID0+IHtcclxuICAgICAgYnV0dG9uLmJhY2tncm91bmRDb2xvciA9IHRyYW5zV2hpdGU7XHJcbiAgICB9O1xyXG4gICAgYnV0dG9uLm9uTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgIGJ1dHRvbi5iYWNrZ3JvdW5kQ29sb3IgPSBpbnZpc2libGVXaGl0ZTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGJ1dHRvbjtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IEFjdG9yIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BY3RvclwiO1xyXG5pbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xyXG5pbXBvcnQgQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FJXCI7XHJcbmltcG9ydCBHb2FwQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0dvYXBBSVwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcblxyXG4vKipcclxuICogQSBtYW5hZ2VyIGNsYXNzIGZvciBhbGwgb2YgdGhlIEFJIGluIGEgc2NlbmUuXHJcbiAqIEtlZXBzIGEgbGlzdCBvZiByZWdpc3RlcmVkIGFjdG9ycyBhbmQgaGFuZGxlcyBBSSBnZW5lcmF0aW9uIGZvciBhY3RvcnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBSU1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuICAvKiogVGhlIGFycmF5IG9mIHJlZ2lzdGVyZWQgYWN0b3JzICovXHJcbiAgYWN0b3JzOiBBcnJheTxBY3Rvcj47XHJcbiAgLyoqIE1hcHMgQUkgbmFtZXMgdG8gdGhlaXIgY29uc3RydWN0b3JzICovXHJcbiAgcmVnaXN0ZXJlZEFJOiBNYXA8QUlDb25zdHJ1Y3Rvcj47XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5hY3RvcnMgPSBuZXcgQXJyYXkoKTtcclxuICAgIHRoaXMucmVnaXN0ZXJlZEFJID0gbmV3IE1hcCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0ZXJzIGFuIGFjdG9yIHdpdGggdGhlIEFJTWFuYWdlclxyXG4gICAqIEBwYXJhbSBhY3RvciBUaGUgYWN0b3IgdG8gcmVnaXN0ZXJcclxuICAgKi9cclxuICByZWdpc3RlckFjdG9yKGFjdG9yOiBBY3Rvcik6IHZvaWQge1xyXG4gICAgdGhpcy5hY3RvcnMucHVzaChhY3Rvcik7XHJcbiAgfVxyXG5cclxuICByZW1vdmVBY3RvcihhY3RvcjogQWN0b3IpOiB2b2lkIHtcclxuICAgIGxldCBpbmRleCA9IHRoaXMuYWN0b3JzLmluZGV4T2YoYWN0b3IpO1xyXG5cclxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgdGhpcy5hY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVycyBhbiBBSSB3aXRoIHRoZSBBSU1hbmFnZXIgZm9yIHVzZSBsYXRlciBvblxyXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBBSSB0byByZWdpc3RlclxyXG4gICAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgQUlcclxuICAgKi9cclxuICByZWdpc3RlckFJKG5hbWU6IHN0cmluZywgY29uc3RyOiBuZXcgPFQgZXh0ZW5kcyBBSSB8IEdvYXBBST4oKSA9PiBUKTogdm9pZCB7XHJcbiAgICB0aGlzLnJlZ2lzdGVyZWRBSS5hZGQobmFtZSwgY29uc3RyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhbiBBSSBpbnN0YW5jZSBmcm9tIGl0cyBuYW1lXHJcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIEFJIHRvIGFkZFxyXG4gICAqIEByZXR1cm5zIEEgbmV3IEFJIGluc3RhbmNlXHJcbiAgICovXHJcbiAgZ2VuZXJhdGVBSShuYW1lOiBzdHJpbmcpOiBBSSB8IEdvYXBBSSB7XHJcbiAgICBpZiAodGhpcy5yZWdpc3RlcmVkQUkuaGFzKG5hbWUpKSB7XHJcbiAgICAgIHJldHVybiBuZXcgKHRoaXMucmVnaXN0ZXJlZEFJLmdldChuYW1lKSkoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IGBDYW5ub3QgY3JlYXRlIEFJIHdpdGggbmFtZSAke25hbWV9LCBubyBBSSB3aXRoIHRoYXQgbmFtZSBpcyByZWdpc3RlcmVkYDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgLy8gUnVuIHRoZSBhaSBmb3IgZXZlcnkgYWN0aXZlIGFjdG9yXHJcbiAgICB0aGlzLmFjdG9ycy5mb3JFYWNoKGFjdG9yID0+IHtcclxuICAgICAgaWYgKGFjdG9yLmFpQWN0aXZlKSBhY3Rvci5haS51cGRhdGUoZGVsdGFUKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxudHlwZSBBSUNvbnN0cnVjdG9yID0gbmV3IDxUIGV4dGVuZHMgQUk+KCkgPT4gVDtcclxuIiwiaW1wb3J0IEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BSVwiO1xyXG5pbXBvcnQgU3RhdGVNYWNoaW5lIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhdGUvU3RhdGVNYWNoaW5lXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHZlcnNpb24gb2YgYSBAcmVmZXJlbmNlW1N0YXRlTWFjaGluZV0gdGhhdCBpcyBjb25maWd1cmVkIHRvIHdvcmsgYXMgYW4gQUkgY29udHJvbGxlciBmb3IgYSBAcmVmZXJlbmNlW0dhbWVOb2RlXVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVNYWNoaW5lQUkgZXh0ZW5kcyBTdGF0ZU1hY2hpbmUgaW1wbGVtZW50cyBBSSB7XHJcbiAgLyoqXHRUaGUgR2FtZU5vZGUgdGhhdCB1c2VzIHRoaXMgU3RhdGVNYWNoaW5lIGZvciBpdHMgQUkgKi9cclxuICBwcm90ZWN0ZWQgb3duZXI6IEdhbWVOb2RlO1xyXG5cclxuICAvLyBAaW1wbGVtZW50ZWRcclxuICBpbml0aWFsaXplQUkob3duZXI6IEdhbWVOb2RlLCBjb25maWc6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHt9XHJcblxyXG4gIC8vIEBpbXBsZW1lbnRlZFxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICAvLyBHZXQgcmlkIG9mIG91ciByZWZlcmVuY2UgdG8gdGhlIG93bmVyXHJcbiAgICBkZWxldGUgdGhpcy5vd25lcjtcclxuICAgIHRoaXMucmVjZWl2ZXIuZGVzdHJveSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGltcGxlbWVudGVkXHJcbiAgYWN0aXZhdGUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge31cclxufVxyXG4iLCIvLyBAaWdub3JlUGFnZVxyXG5cclxuLyoqXHJcbiAqIEEgcGxhY2Vob2xkZXIgZnVuY3Rpb24gZm9yIE5vIE9wZXJhdGlvbi4gRG9lcyBub3RoaW5nXHJcbiAqL1xyXG5jb25zdCBOdWxsRnVuYyA9ICgpID0+IHt9O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTnVsbEZ1bmM7XHJcbiIsIi8qKlxyXG4gKiBBIGxpbmtlZC1saXN0IGZvciB0aGUgZWRnZXMgaW4gYSBAcmVmZXJlbmNlW0dyYXBoXS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkZ2VOb2RlIHtcclxuICAvKiogVGhlIG5vZGUgaW4gdGhlIEdyYXBoIHRoaXMgZWRnZSBjb25uZWN0cyB0byAqL1xyXG4gIHk6IG51bWJlcjtcclxuICAvKiogVGhlIHdlaWdodCBvZiB0aGlzIEVkZ2VOb2RlICovXHJcbiAgd2VpZ2h0OiBudW1iZXI7XHJcbiAgLyoqIFRoZSBuZXh0IEVkZ2VOb2RlIGluIHRoZSBsaW5rZWQtbGlzdCAqL1xyXG4gIG5leHQ6IEVkZ2VOb2RlO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IEVkZ2VOb2RlXHJcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0aGlzIGVkZ2UgY29ubmVjdHMgdG9cclxuICAgKiBAcGFyYW0gd2VpZ2h0IFRoZSB3ZWlnaHQgb2YgdGhpcyBlZGdlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoaW5kZXg6IG51bWJlciwgd2VpZ2h0PzogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnkgPSBpbmRleDtcclxuICAgIHRoaXMubmV4dCA9IG51bGw7XHJcbiAgICB0aGlzLndlaWdodCA9IHdlaWdodCA/IHdlaWdodCA6IDE7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBFZGdlTm9kZSBmcm9tIFwiLi9FZGdlTm9kZVwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1BWF9WID0gMTAwO1xyXG5cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgZ3JhcGggZGF0YSBzdHJ1Y3R1cmUgdXNpbmcgZWRnZSBsaXN0cy4gSW5zcGlyZWQgYnkgVGhlIEFsZ29yaXRobSBEZXNpZ24gTWFudWFsLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGgge1xyXG4gIC8qKiBBbiBhcnJheSBvZiBlZGdlcyBhdCB0aGUgbm9kZSBzcGVjaWZpZWQgYnkgdGhlIGluZGV4ICovXHJcbiAgZWRnZXM6IEFycmF5PEVkZ2VOb2RlPjtcclxuICAvKiogQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBkZWdyZWUgb2YgdGhlIG5vZGUgc3BlY2lmaWVkIGJ5IHRoZSBpbmRleCAqL1xyXG4gIGRlZ3JlZTogQXJyYXk8bnVtYmVyPjtcclxuICAvKiogVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgZ3JhcGggKi9cclxuICBudW1WZXJ0aWNlczogbnVtYmVyO1xyXG4gIC8qKiBUaGUgbnVtYmVyIG9mIGVkZ2VzIGluIHRoZSBncmFwaCAqL1xyXG4gIG51bUVkZ2VzOiBudW1iZXI7XHJcbiAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBncmFwaCBpcyBkaXJlY3RlZCAqL1xyXG4gIGRpcmVjdGVkOiBib29sZWFuO1xyXG4gIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ3JhcGggaXMgd2VpZ2h0ZWQgKi9cclxuICB3ZWlnaHRlZDogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0cyBhIG5ldyBncmFwaFxyXG4gICAqIEBwYXJhbSBkaXJlY3RlZCBXaGV0aGVyIG9yIG5vdCB0aGlzIGdyYXBoIGlzIGRpcmVjdGVkXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZGlyZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgdGhpcy5kaXJlY3RlZCA9IGRpcmVjdGVkO1xyXG4gICAgdGhpcy53ZWlnaHRlZCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMubnVtVmVydGljZXMgPSAwO1xyXG4gICAgdGhpcy5udW1FZGdlcyA9IDA7XHJcblxyXG4gICAgdGhpcy5lZGdlcyA9IG5ldyBBcnJheShNQVhfVik7XHJcbiAgICB0aGlzLmRlZ3JlZSA9IG5ldyBBcnJheShNQVhfVik7XHJcbiAgfVxyXG5cclxuICAvKiogQWRkcyBhIG5vZGUgdG8gdGhpcyBncmFwaCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2YgaXRcclxuICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIG5ldyBub2RlXHJcbiAgICovXHJcbiAgYWRkTm9kZSgpOiBudW1iZXIge1xyXG4gICAgdGhpcy5udW1WZXJ0aWNlcysrO1xyXG4gICAgcmV0dXJuIHRoaXMubnVtVmVydGljZXM7XHJcbiAgfVxyXG5cclxuICAvKiogQWRkcyBhbiBlZGdlIGJldHdlZW4gbm9kZSB4IGFuZCB5LCB3aXRoIGFuIG9wdGlvbmFsIHdlaWdodFxyXG4gICAqIEBwYXJhbSB4IFRoZSBpbmRleCBvZiB0aGUgc3RhcnQgb2YgdGhlIGVkZ2VcclxuICAgKiBAcGFyYW0geSBUaGUgaW5kZXggb2YgdGhlIGVuZCBvZiB0aGUgZWRnZVxyXG4gICAqIEBwYXJhbSB3ZWlnaHQgVGhlIG9wdGlvbmFsIHdlaWdodCBvZiB0aGUgbmV3IGVkZ2VcclxuICAgKi9cclxuICBhZGRFZGdlKHg6IG51bWJlciwgeTogbnVtYmVyLCB3ZWlnaHQ/OiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGxldCBlZGdlID0gbmV3IEVkZ2VOb2RlKHksIHdlaWdodCk7XHJcblxyXG4gICAgaWYgKHRoaXMuZWRnZXNbeF0pIHtcclxuICAgICAgZWRnZS5uZXh0ID0gdGhpcy5lZGdlc1t4XTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmVkZ2VzW3hdID0gZWRnZTtcclxuXHJcbiAgICBpZiAoIXRoaXMuZGlyZWN0ZWQpIHtcclxuICAgICAgZWRnZSA9IG5ldyBFZGdlTm9kZSh4LCB3ZWlnaHQpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuZWRnZXNbeV0pIHtcclxuICAgICAgICBlZGdlLm5leHQgPSB0aGlzLmVkZ2VzW3ldO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmVkZ2VzW3ldID0gZWRnZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm51bUVkZ2VzICs9IDE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgYW4gZWRnZSBleGlzdHMgYmV0d2VlbiB0d28gbm9kZXMuXHJcbiAgICogVGhpcyBjaGVjayBpcyBkaXJlY3Rpb25hbCBpZiB0aGlzIGlzIGEgZGlyZWN0ZWQgZ3JhcGguXHJcbiAgICogQHBhcmFtIHggVGhlIGZpcnN0IG5vZGVcclxuICAgKiBAcGFyYW0geSBUaGUgc2Vjb25kIG5vZGVcclxuICAgKiBAcmV0dXJucyB0cnVlIGlmIGFuIGVkZ2UgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcclxuICAgKi9cclxuICBlZGdlRXhpc3RzKHg6IG51bWJlciwgeTogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICBsZXQgZWRnZSA9IHRoaXMuZWRnZXNbeF07XHJcblxyXG4gICAgd2hpbGUgKGVkZ2UgIT09IG51bGwpIHtcclxuICAgICAgaWYgKGVkZ2UueSA9PT0geSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGVkZ2UgPSBlZGdlLm5leHQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBlZGdlIGxpc3QgYXNzb2NpYXRlZCB3aXRoIG5vZGUgeFxyXG4gICAqIEBwYXJhbSB4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxyXG4gICAqIEByZXR1cm5zIFRoZSBoZWFkIG9mIGEgbGlua2VkLWxpc3Qgb2YgZWRnZXNcclxuICAgKi9cclxuICBnZXRFZGdlcyh4OiBudW1iZXIpOiBFZGdlTm9kZSB7XHJcbiAgICByZXR1cm4gdGhpcy5lZGdlc1t4XTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGRlZ3JlZSBhc3NvY2lhdGVkIHdpdGggbm9kZSB4XHJcbiAgICogQHBhcmFtIHggVGhlIGluZGV4IG9mIHRoZSBub2RlXHJcbiAgICovXHJcbiAgZ2V0RGVncmVlKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5kZWdyZWVbeF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0cyB0aGUgc3BlY2lmZWQgbm9kZSBpbnRvIGEgc3RyaW5nXHJcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBjb252ZXJ0IHRvIGEgc3RyaW5nXHJcbiAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbm9kZTogXCJOb2RlIHhcIlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBub2RlVG9TdHJpbmcoaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gXCJOb2RlIFwiICsgaW5kZXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0cyB0aGUgR3JhcGggaW50byBhIHN0cmluZyBmb3JtYXRcclxuICAgKiBAcmV0dXJucyBUaGUgZ3JhcGggYXMgYSBzdHJpbmdcclxuICAgKi9cclxuICB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgbGV0IHJldHZhbCA9IFwiXCI7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bVZlcnRpY2VzOyBpKyspIHtcclxuICAgICAgbGV0IGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xyXG4gICAgICBsZXQgZWRnZVN0ciA9IFwiXCI7XHJcbiAgICAgIHdoaWxlIChlZGdlICE9PSB1bmRlZmluZWQgJiYgZWRnZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGVkZ2VTdHIgKz0gZWRnZS55LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHRoaXMud2VpZ2h0ZWQpIHtcclxuICAgICAgICAgIGVkZ2VTdHIgKz0gXCIgKFwiICsgZWRnZS53ZWlnaHQgKyBcIilcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVkZ2UubmV4dCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgZWRnZVN0ciArPSBcIiwgXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlZGdlID0gZWRnZS5uZXh0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR2YWwgKz0gdGhpcy5ub2RlVG9TdHJpbmcoaSkgKyBcIjogXCIgKyBlZGdlU3RyICsgXCJcXG5cIjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0dmFsO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgR3JhcGgsIHsgTUFYX1YgfSBmcm9tIFwiLi9HcmFwaFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xyXG5pbXBvcnQgRGVidWdSZW5kZXJhYmxlIGZyb20gXCIuLi9JbnRlcmZhY2VzL0RlYnVnUmVuZGVyYWJsZVwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGV4dGVuc2lvbiBvZiBHcmFwaCB0aGF0IGhhcyBub2RlcyB3aXRoIHBvc2l0aW9ucyBpbiAyRCBzcGFjZS5cclxuICogVGhpcyBpcyBhIHdlaWdodGVkIGdyYXBoICh0aG91Z2ggbm90IGluaGVyZW50bHkgZGlyZWN0ZClcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc2l0aW9uR3JhcGggZXh0ZW5kcyBHcmFwaCBpbXBsZW1lbnRzIERlYnVnUmVuZGVyYWJsZSB7XHJcbiAgLyoqIEFuIGFycmF5IG9mIHRoZSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzIGluIHRoaXMgZ3JhcGggKi9cclxuICBwb3NpdGlvbnM6IEFycmF5PFZlYzI+O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVlcyBhIG5ldyBQb3NpdGlvbkdyYXBoXHJcbiAgICogQHBhcmFtIGRpcmVjdGVkIFdoZXRoZXIgb3Igbm90IHRoaXMgZ3JhcGggaXMgZGlyZWN0ZWRcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkaXJlY3RlZDogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICBzdXBlcihkaXJlY3RlZCk7XHJcbiAgICB0aGlzLnBvc2l0aW9ucyA9IG5ldyBBcnJheShNQVhfVik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgcG9zaXRpb25lZCBub2RlIHRvIHRoaXMgZ3JhcGhcclxuICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIHRvIGFkZFxyXG4gICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgYWRkZWQgbm9kZVxyXG4gICAqL1xyXG4gIGFkZFBvc2l0aW9uZWROb2RlKHBvc2l0aW9uOiBWZWMyKTogbnVtYmVyIHtcclxuICAgIHRoaXMucG9zaXRpb25zW3RoaXMubnVtVmVydGljZXNdID0gcG9zaXRpb247XHJcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGFuZ2VzIHRoZSBwb3NpdGlvbiBvZiBhIG5vZGUuXHJcbiAgICogQXV0b21hdGljYWxseSBhZGp1c3RzIHRoZSB3ZWlnaHRzIG9mIHRoZSBncmFwaCB0aWVkIHRvIHRoaXMgbm9kZS5cclxuICAgKiBBcyBzdWNoLCBiZSB3YXJuZWQgdGhhdCB0aGlzIGZ1bmN0aW9uIGhhcyBhbiBPKG4gKyBtKSBydW5uaW5nIHRpbWUsIGFuZCB1c2UgaXQgc3BhcmluZ2x5LlxyXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcclxuICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgbm9kZVxyXG4gICAqL1xyXG4gIHNldE5vZGVQb3NpdGlvbihpbmRleDogbnVtYmVyLCBwb3NpdGlvbjogVmVjMik6IHZvaWQge1xyXG4gICAgdGhpcy5wb3NpdGlvbnNbaW5kZXhdID0gcG9zaXRpb247XHJcblxyXG4gICAgLy8gUmVjYWxjdWxhdGUgYWxsIHdlaWdodHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5kZXhcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1FZGdlczsgaSsrKSB7XHJcbiAgICAgIGxldCBlZGdlID0gdGhpcy5lZGdlc1tpXTtcclxuXHJcbiAgICAgIHdoaWxlIChlZGdlICE9PSBudWxsKSB7XHJcbiAgICAgICAgLy8gSWYgdGhpcyBub2RlIGlzIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBlZGdlLCByZWNhbGN1bGF0ZSB3ZWlnaHRcclxuICAgICAgICBpZiAoaSA9PT0gaW5kZXggfHwgZWRnZS55ID09PSBpbmRleCkge1xyXG4gICAgICAgICAgZWRnZS53ZWlnaHQgPSB0aGlzLnBvc2l0aW9uc1tpXS5kaXN0YW5jZVRvKHRoaXMucG9zaXRpb25zW2VkZ2UueV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgcG9zaXRpb24gb2YgYSBub2RlXHJcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxyXG4gICAqIEByZXR1cm5zIFRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZVxyXG4gICAqL1xyXG4gIGdldE5vZGVQb3NpdGlvbihpbmRleDogbnVtYmVyKTogVmVjMiB7XHJcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnNbaW5kZXhdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhbiBlZGdlIHRvIHRoaXMgZ3JhcGggYmV0d2VlbiBub2RlIHggYW5kIHkuXHJcbiAgICogQXV0b21hdGljYWxseSBjYWxjdWxhdGVzIHRoZSB3ZWlnaHQgb2YgdGhlIGVkZ2UgYXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG5vZGVzLlxyXG4gICAqIEBwYXJhbSB4IFRoZSBiZWdpbm5pbmcgb2YgdGhlIGVkZ2VcclxuICAgKiBAcGFyYW0geSBUaGUgZW5kIG9mIHRoZSBlZGdlXHJcbiAgICovXHJcbiAgYWRkRWRnZSh4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgaWYgKCF0aGlzLnBvc2l0aW9uc1t4XSB8fCAhdGhpcy5wb3NpdGlvbnNbeV0pIHtcclxuICAgICAgdGhyb3cgXCJDYW4ndCBhZGQgZWRnZSB0byB1bi1wb3NpdGlvbmVkIG5vZGUhXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2VpZ2h0IGlzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBub2Rlc1xyXG4gICAgbGV0IHdlaWdodCA9IHRoaXMucG9zaXRpb25zW3hdLmRpc3RhbmNlVG8odGhpcy5wb3NpdGlvbnNbeV0pO1xyXG5cclxuICAgIHN1cGVyLmFkZEVkZ2UoeCwgeSwgd2VpZ2h0KTtcclxuICB9XHJcblxyXG4gIC8vIEBvdmVycmlkZVxyXG4gIHByb3RlY3RlZCBub2RlVG9TdHJpbmcoaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gXCJOb2RlIFwiICsgaW5kZXggKyBcIiAtIFwiICsgdGhpcy5wb3NpdGlvbnNbaW5kZXhdLnRvU3RyaW5nKCk7XHJcbiAgfVxyXG5cclxuICBkZWJ1Z1JlbmRlciA9ICgpOiB2b2lkID0+IHtcclxuICAgIC8vIGZvcihsZXQgcG9pbnQgb2YgdGhpcy5wb3NpdGlvbnMpe1xyXG4gICAgLy8gXHRjdHguZmlsbFJlY3QoKHBvaW50LnggLSBvcmlnaW4ueCAtIDQpKnpvb20sIChwb2ludC55IC0gb3JpZ2luLnkgLSA0KSp6b29tLCA4LCA4KTtcclxuICAgIC8vIH1cclxuICB9O1xyXG59XHJcbiIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9TaGFwZXMvQUFCQlwiO1xyXG5cclxuLyoqIEFuIG9iamVjdCB0aGF0IGlzIGEgcmVnaW9uLCB3aXRoIGEgc2l6ZSwgc2NhbGUsIGFuZCBib3VuZGFyeS4gKi9cclxuZXhwb3J0IGRlZmF1bHQgaW50ZXJmYWNlIFJlZ2lvbiB7XHJcbiAgLyoqIFRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LiAqL1xyXG4gIHNpemU6IFZlYzI7XHJcblxyXG4gIC8qKiBUaGUgc2NhbGUgb2YgdGhpcyBvYmplY3QuICovXHJcbiAgc2NhbGU6IFZlYzI7XHJcblxyXG4gIC8qKiBUaGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHRha2luZyBpbnRvIGFjY291bnQgdGhlIHpvb20gYW5kIHNjYWxlICovXHJcbiAgcmVhZG9ubHkgc2l6ZVdpdGhab29tOiBWZWMyO1xyXG5cclxuICAvKiogVGhlIGJvdW5kaW5nIGJveCBvZiB0aGlzIG9iamVjdC4gKi9cclxuICBib3VuZGFyeTogQUFCQjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVnaW9uKGFyZzogYW55KTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIGFyZyAmJiBhcmcuc2l6ZSAmJiBhcmcuc2NhbGUgJiYgYXJnLmJvdW5kYXJ5O1xyXG59XHJcbiIsImltcG9ydCBDb2xsZWN0aW9uIGZyb20gXCIuL0NvbGxlY3Rpb25cIjtcclxuXHJcbi8qKlxyXG4gKiBBc3NvY2lhdGVzIHN0cmluZ3Mgd2l0aCBlbGVtZW50cyBvZiB0eXBlIFRcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcDxUPiBpbXBsZW1lbnRzIENvbGxlY3Rpb24ge1xyXG4gIHByaXZhdGUgbWFwOiBSZWNvcmQ8c3RyaW5nLCBUPjtcclxuXHJcbiAgLyoqIENyZWF0ZXMgYSBuZXcgbWFwICovXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLm1hcCA9IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIHZhbHVlIFQgc3RvcmVkIGF0IGEga2V5LlxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBiZSBzdG9yZWRcclxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIGl0ZW0gdG8gYmUgc3RvcmVkXHJcbiAgICovXHJcbiAgYWRkKGtleTogc3RyaW5nLCB2YWx1ZTogVCk6IHZvaWQge1xyXG4gICAgdGhpcy5tYXBba2V5XSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBrZXkuXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtXHJcbiAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGtleSBvciB1bmRlZmluZWRcclxuICAgKi9cclxuICBnZXQoa2V5OiBzdHJpbmcpOiBUIHtcclxuICAgIHJldHVybiB0aGlzLm1hcFtrZXldO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW4gYWxpYXMgb2YgYWRkLiBTZXRzIHRoZSB2YWx1ZSBzdG9yZWQgYXQga2V5IHRvIHRoZSBuZXcgc3BlY2lmaWVkIHZhbHVlXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGJlIHN0b3JlZFxyXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgaXRlbSB0byBiZSBzdG9yZWRcclxuICAgKi9cclxuICBzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBUKTogdm9pZCB7XHJcbiAgICB0aGlzLmFkZChrZXksIHZhbHVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhIHZhbHVlIHN0b3JlZCBhdCB0aGUgc3BlY2lmaWVkIGtleSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBjaGVja1xyXG4gICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGUgZ2l2ZW4ga2V5LlxyXG4gICAqL1xyXG4gIGhhcyhrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMubWFwW2tleV0gIT09IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBrZXlzIGluIHRoaXMgbWFwLlxyXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGtleXMgaW4gdGhlIG1hcC5cclxuICAgKi9cclxuICBrZXlzKCk6IEFycmF5PHN0cmluZz4ge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWFwKTtcclxuICB9XHJcblxyXG4gIC8vIEBpbXBsZW1lbnRlZFxyXG4gIGZvckVhY2goZnVuYzogKGtleTogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICBPYmplY3Qua2V5cyh0aGlzLm1hcCkuZm9yRWFjaChrZXkgPT4gZnVuYyhrZXkpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZXMgYW4gaXRlbSBhc3NvY2lhdGVkIHdpdGggYSBrZXlcclxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgYXQgd2hpY2ggdG8gZGVsZXRlIGFuIGl0ZW1cclxuICAgKi9cclxuICBkZWxldGUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGRlbGV0ZSB0aGlzLm1hcFtrZXldO1xyXG4gIH1cclxuXHJcbiAgLy8gQGltcGxlbWVudGVkXHJcbiAgY2xlYXIoKTogdm9pZCB7XHJcbiAgICB0aGlzLmZvckVhY2goa2V5ID0+IGRlbGV0ZSB0aGlzLm1hcFtrZXldKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRoaXMgbWFwIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG4gICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBtYXAuXHJcbiAgICovXHJcbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgIGxldCBzdHIgPSBcIlwiO1xyXG5cclxuICAgIHRoaXMuZm9yRWFjaChcclxuICAgICAga2V5ID0+IChzdHIgKz0ga2V5ICsgXCIgLT4gXCIgKyB0aGlzLmdldChrZXkpLnRvU3RyaW5nKCkgKyBcIlxcblwiKSxcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4vVmVjMlwiO1xyXG5cclxuLyoqIEEgNHg0IG1hdHJpeDAgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0NHg0IHtcclxuICBwcml2YXRlIG1hdDogRmxvYXQzMkFycmF5O1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMubWF0ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXHJcbiAgICBdKTtcclxuICB9XHJcblxyXG4gIC8vIFN0YXRpYyBtZW1iZXJzXHJcbiAgc3RhdGljIGdldCBJREVOVElUWSgpOiBNYXQ0eDQge1xyXG4gICAgcmV0dXJuIG5ldyBNYXQ0eDQoKS5pZGVudGl0eSgpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldCBaRVJPKCk6IE1hdDR4NCB7XHJcbiAgICByZXR1cm4gbmV3IE1hdDR4NCgpLnplcm8oKTtcclxuICB9XHJcblxyXG4gIC8vIEFjY2Vzc29yc1xyXG4gIHNldCBfMDAoeDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLm1hdFswXSA9IHg7XHJcbiAgfVxyXG5cclxuICBzZXQoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogTWF0NHg0IHtcclxuICAgIGlmIChjb2wgPCAwIHx8IGNvbCA+IDMgfHwgcm93IDwgMCB8fCByb3cgPiAzKSB7XHJcbiAgICAgIHRocm93IGBFcnJvciAtIGluZGV4ICgke2NvbH0sICR7cm93fSkgaXMgb3V0IG9mIGJvdW5kcyBmb3IgTWF0NHg0YDtcclxuICAgIH1cclxuICAgIHRoaXMubWF0W3JvdyAqIDQgKyBjb2xdID0gdmFsdWU7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBnZXQoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm1hdFtyb3cgKiA0ICsgY29sXTtcclxuICB9XHJcblxyXG4gIHNldEFsbCguLi5pdGVtczogQXJyYXk8bnVtYmVyPik6IE1hdDR4NCB7XHJcbiAgICB0aGlzLm1hdC5zZXQoaXRlbXMpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBpZGVudGl0eSgpOiBNYXQ0eDQge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0QWxsKDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpO1xyXG4gIH1cclxuXHJcbiAgemVybygpOiBNYXQ0eDQge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0QWxsKDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWFrZXMgdGhpcyBNYXQ0eDQgYSByb3RhdGlvbiBtYXRyaXggb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgcmFkaWFucyBjY3dcclxuICAgKiBAcGFyYW0gelJhZGlhbnMgVGhlIG51bWJlciBvZiByYWRpYW5zIHRvIHJvdGF0ZVxyXG4gICAqIEByZXR1cm5zIHRoaXMgTWF0NHg0XHJcbiAgICovXHJcbiAgcm90YXRlKHpSYWRpYW5zOiBudW1iZXIpOiBNYXQ0eDQge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0QWxsKFxyXG4gICAgICBNYXRoLmNvcyh6UmFkaWFucyksXHJcbiAgICAgIC1NYXRoLnNpbih6UmFkaWFucyksXHJcbiAgICAgIDAsXHJcbiAgICAgIDAsXHJcbiAgICAgIE1hdGguc2luKHpSYWRpYW5zKSxcclxuICAgICAgTWF0aC5jb3MoelJhZGlhbnMpLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAxLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAxLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFR1cm5zIHRoaXMgTWF0NHg0IGludG8gYSB0cmFuc2xhdGlvbiBtYXRyaXggb2YgdGhlIHNwZWNpZmllZCB0cmFuc2xhdGlvblxyXG4gICAqIEBwYXJhbSB0cmFuc2xhdGlvbiBUaGUgdHJhbnNsYXRpb24gaW4geCBhbmQgeVxyXG4gICAqIEByZXR1cm5zIHRoaXMgTWF0NHg0XHJcbiAgICovXHJcbiAgdHJhbnNsYXRlKHRyYW5zbGF0aW9uOiBWZWMyIHwgRmxvYXQzMkFycmF5KTogTWF0NHg0IHtcclxuICAgIC8vIElmIHRyYW5zbGF0aW9uIGlzIGEgdmVjLCBnZXQgaXRzIGFycmF5XHJcbiAgICBpZiAodHJhbnNsYXRpb24gaW5zdGFuY2VvZiBWZWMyKSB7XHJcbiAgICAgIHRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb24udG9BcnJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnNldEFsbChcclxuICAgICAgMSxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgdHJhbnNsYXRpb25bMF0sXHJcbiAgICAgIDAsXHJcbiAgICAgIDEsXHJcbiAgICAgIDAsXHJcbiAgICAgIHRyYW5zbGF0aW9uWzFdLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAxLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAxLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHNjYWxlKHNjYWxlOiBWZWMyIHwgRmxvYXQzMkFycmF5IHwgbnVtYmVyKTogTWF0NHg0IHtcclxuICAgIC8vIE1ha2Ugc3VyZSBzY2FsZSBpcyBhIGZsb2F0MzJBcnJheVxyXG4gICAgaWYgKHNjYWxlIGluc3RhbmNlb2YgVmVjMikge1xyXG4gICAgICBzY2FsZSA9IHNjYWxlLnRvQXJyYXkoKTtcclxuICAgIH0gZWxzZSBpZiAoIShzY2FsZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHtcclxuICAgICAgc2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KFtzY2FsZSwgc2NhbGVdKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5zZXRBbGwoXHJcbiAgICAgIHNjYWxlWzBdLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICBzY2FsZVsxXSxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMSxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IE1hdDR4NCB0aGF0IHJlcHJlc2VudHMgdGhlIHJpZ2h0IHNpZGUgbXVsdGlwbGljYXRpb24gVEhJUyB4IE9USEVSXHJcbiAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBNYXQ0eDQgdG8gbXVsdGlwbHkgYnlcclxuICAgKiBAcmV0dXJucyBhIG5ldyBNYXQ0eDQgY29udGFpbmluZyB0aGUgcHJvZHVjdCBvZiB0aGVzZSB0d28gTWF0NHg0c1xyXG4gICAqL1xyXG4gIG11bHQob3RoZXI6IE1hdDR4NCwgb3V0PzogTWF0NHg0KTogTWF0NHg0IHtcclxuICAgIGxldCB0ZW1wID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgNDsgaysrKSB7XHJcbiAgICAgICAgICB2YWx1ZSArPSB0aGlzLmdldChrLCBpKSAqIG90aGVyLmdldChqLCBrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGVtcFtqICogNCArIGldID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAob3V0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIG91dC5zZXRBbGwoLi4udGVtcCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbmV3IE1hdDR4NCgpLnNldEFsbCguLi50ZW1wKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE11bHRpcGxpZXMgYWxsIGdpdmVuIG1hdHJpY2llcyBpbiBvcmRlci4gZS5nLiBNVUxUKEEsIEIsIEMpIC0+IEEqQipDXHJcbiAgICogQHBhcmFtIG1hdHMgQSBsaXN0IG9mIE1hdDR4NHMgdG8gbXVsdGlwbHkgaW4gb3JkZXJcclxuICAgKiBAcmV0dXJucyBBIG5ldyBNYXQ0eDQgaG9sZGluZyB0aGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cclxuICAgKi9cclxuICBzdGF0aWMgTVVMVCguLi5tYXRzOiBBcnJheTxNYXQ0eDQ+KTogTWF0NHg0IHtcclxuICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheVxyXG4gICAgbGV0IHRlbXAgPSBNYXQ0eDQuSURFTlRJVFk7XHJcblxyXG4gICAgLy8gTXVsdGlwbHkgYnkgZXZlcnkgYXJyYXkgaW4gb3JkZXIsIGluIHBsYWNlXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGVtcC5tdWx0KG1hdHNbaV0sIHRlbXApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZW1wO1xyXG4gIH1cclxuXHJcbiAgdG9BcnJheSgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgcmV0dXJuIHRoaXMubWF0O1xyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIGB8JHt0aGlzLm1hdFswXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsyXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFszXS50b0ZpeGVkKDIpfXxcXG5gICtcclxuICAgICAgYHwke3RoaXMubWF0WzRdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzVdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzZdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzddLnRvRml4ZWQoMil9fFxcbmAgK1xyXG4gICAgICBgfCR7dGhpcy5tYXRbOF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbOV0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTBdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzExXS50b0ZpeGVkKDIpfXxcXG5gICtcclxuICAgICAgYHwke3RoaXMubWF0WzEyXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxM10udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTRdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzE1XS50b0ZpeGVkKDIpfXxgXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgUGh5c2ljYWwgZnJvbSBcIi4uL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCBIaXQgZnJvbSBcIi4vSGl0XCI7XHJcblxyXG4vKipcclxuICogQSBjbGFzcyB0aGF0IGNvbnRhaW5zIHRoZSBhcmVhIG9mIG92ZXJsYXAgb2YgdHdvIGNvbGxpZGluZyBvYmplY3RzIHRvIGFsbG93IGZvciBzb3J0aW5nIGJ5IHRoZSBwaHlzaWNzIHN5c3RlbS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyZWFDb2xsaXNpb24ge1xyXG4gIC8qKiBUaGUgYXJlYSBvZiB0aGUgb3ZlcmxhcCBmb3IgdGhlIGNvbGxpZGluZyBvYmplY3RzICovXHJcbiAgYXJlYTogbnVtYmVyO1xyXG5cclxuICAvKiogVGhlIEFBQkIgb2YgdGhlIG90aGVyIGNvbGxpZGVyIGluIHRoaXMgY29sbGlzaW9uICovXHJcbiAgY29sbGlkZXI6IEFBQkI7XHJcblxyXG4gIC8qKiBUeXBlIG9mIHRoZSBjb2xsaXNpb24gKi9cclxuICB0eXBlOiBzdHJpbmc7XHJcblxyXG4gIC8qKiBUaGVyIG90aGVyIG9iamVjdCBpbiB0aGUgY29sbGlzaW9uICovXHJcbiAgb3RoZXI6IFBoeXNpY2FsO1xyXG5cclxuICAvKiogVGhlIHRpbGUsIGlmIHRoaXMgd2FzIGEgdGlsZW1hcCBjb2xsaXNpb24gKi9cclxuICB0aWxlOiBWZWMyO1xyXG5cclxuICAvKiogVGhlIHBoeXNpY3MgaGl0IGZvciB0aGlzIG9iamVjdCAqL1xyXG4gIGhpdDogSGl0O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IEFyZWFDb2xsaXNpb24gb2JqZWN0XHJcbiAgICogQHBhcmFtIGFyZWEgVGhlIGFyZWEgb2YgdGhlIGNvbGxpc2lvblxyXG4gICAqIEBwYXJhbSBjb2xsaWRlciBUaGUgb3RoZXIgY29sbGlkZXJcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGFyZWE6IG51bWJlcixcclxuICAgIGNvbGxpZGVyOiBBQUJCLFxyXG4gICAgb3RoZXI6IFBoeXNpY2FsLFxyXG4gICAgdHlwZTogc3RyaW5nLFxyXG4gICAgdGlsZTogVmVjMixcclxuICApIHtcclxuICAgIHRoaXMuYXJlYSA9IGFyZWE7XHJcbiAgICB0aGlzLmNvbGxpZGVyID0gY29sbGlkZXI7XHJcbiAgICB0aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgdGhpcy50aWxlID0gdGlsZTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRhIGNvbGxlY3RlZCBmcm9tIGEgcGh5c2ljcyBoaXQgYmV0d2VlbiB0d28gZ2VvbWV0cmljIG9iamVjdHMuXHJcbiAqIEluc3BpcmVkIGJ5IHRoZSBoZWxwZnVsIGNvbGxpc2lvbiBkb2N1bWVudGF0aW9uIEBsaW5rKGhlcmUpKGh0dHBzOi8vbm9vbmF0LmdpdGh1Yi5pby9pbnRlcnNlY3QvKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpdCB7XHJcbiAgLyoqIFRoZSB0aW1lIG9mIHRoZSBjb2xsaXNpb24uIE9ubHkgbnVtYmVycyAwIHRocm91Z2ggMSBoYXBwZW4gaW4gdGhpcyBmcmFtZS4gKi9cclxuICB0aW1lOiBudW1iZXI7XHJcbiAgLyoqIFRoZSBuZWFyIHRpbWVzIG9mIHRoZSBjb2xsaXNpb24gKi9cclxuICBuZWFyVGltZXM6IFZlYzIgPSBWZWMyLlpFUk87XHJcbiAgLyoqIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29sbGlzaW9uICovXHJcbiAgcG9zOiBWZWMyID0gVmVjMi5aRVJPO1xyXG4gIC8qKiBUaGUgb3ZlcmxhcCBkaXN0YW5jZSBvZiB0aGUgaGl0ICovXHJcbiAgZGVsdGE6IFZlYzIgPSBWZWMyLlpFUk87XHJcbiAgLyoqIFRoZSBub3JtYWwgdmVjdG9yIG9mIHRoZSBoaXQgKi9cclxuICBub3JtYWw6IFZlYzIgPSBWZWMyLlpFUk87XHJcbn1cclxuIiwiaW1wb3J0IENvbGxlY3Rpb24gZnJvbSBcIi4vQ29sbGVjdGlvblwiO1xyXG5cclxuLyoqXHJcbiAqIEEgRklGTyBxdWV1ZSB3aXRoIGVsZW1lbnRzIG9mIHR5cGUgVFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVldWU8VD4gaW1wbGVtZW50cyBDb2xsZWN0aW9uIHtcclxuICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBRdWV1ZSAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgTUFYX0VMRU1FTlRTOiBudW1iZXI7XHJcblxyXG4gIC8qKiBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHF1ZXVlICovXHJcbiAgcHJpdmF0ZSBxOiBBcnJheTxUPjtcclxuXHJcbiAgLyoqIFRoZSBoZWFkIG9mIHRoZSBxdWV1ZSAqL1xyXG4gIHByaXZhdGUgaGVhZDogbnVtYmVyO1xyXG5cclxuICAvKiogVGhlIHRhaWwgb2YgdGhlIHF1ZXVlICovXHJcbiAgcHJpdmF0ZSB0YWlsOiBudW1iZXI7XHJcblxyXG4gIC8qKiBUaGUgY3VycmVudCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHF1ZXVlICovXHJcbiAgcHJpdmF0ZSBzaXplOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgcXVldWVcclxuICAgKiBAcGFyYW0gbWF4RWxlbWVudHMgVGhlIG1heGltdW0gc2l6ZSBvZiB0aGUgc3RhY2tcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihtYXhFbGVtZW50czogbnVtYmVyID0gMTAwKSB7XHJcbiAgICB0aGlzLk1BWF9FTEVNRU5UUyA9IG1heEVsZW1lbnRzO1xyXG4gICAgdGhpcy5xID0gbmV3IEFycmF5KHRoaXMuTUFYX0VMRU1FTlRTKTtcclxuICAgIHRoaXMuaGVhZCA9IDA7XHJcbiAgICB0aGlzLnRhaWwgPSAwO1xyXG4gICAgdGhpcy5zaXplID0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgYmFjayBvZiB0aGUgcXVldWVcclxuICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGJhY2sgb2YgdGhlIHF1ZXVlXHJcbiAgICovXHJcbiAgZW5xdWV1ZShpdGVtOiBUKTogdm9pZCB7XHJcbiAgICBpZiAoKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFMgPT09IHRoaXMuaGVhZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWV1ZSBmdWxsIC0gY2Fubm90IGFkZCBlbGVtZW50XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2l6ZSArPSAxO1xyXG4gICAgdGhpcy5xW3RoaXMudGFpbF0gPSBpdGVtO1xyXG4gICAgdGhpcy50YWlsID0gKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZXMgYW4gaXRlbSBmcm9tIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcclxuICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXHJcbiAgICovXHJcbiAgZGVxdWV1ZSgpOiBUIHtcclxuICAgIGlmICh0aGlzLmhlYWQgPT09IHRoaXMudGFpbCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWV1ZSBlbXB0eSAtIGNhbm5vdCByZW1vdmUgZWxlbWVudFwiKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNpemUgLT0gMTtcclxuICAgIGxldCBpdGVtID0gdGhpcy5xW3RoaXMuaGVhZF07XHJcbiAgICAvLyBOb3cgZGVsZXRlIHRoZSBpdGVtXHJcbiAgICBkZWxldGUgdGhpcy5xW3RoaXMuaGVhZF07XHJcbiAgICB0aGlzLmhlYWQgPSAodGhpcy5oZWFkICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUztcclxuXHJcbiAgICByZXR1cm4gaXRlbTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZSwgYnV0IGRvZXMgbm90IHJlbW92ZSBpdFxyXG4gICAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSBmcm9udCBvZiB0aGUgcXVldWVcclxuICAgKi9cclxuICBwZWVrTmV4dCgpOiBUIHtcclxuICAgIGlmICh0aGlzLmhlYWQgPT09IHRoaXMudGFpbCkge1xyXG4gICAgICB0aHJvdyBcIlF1ZXVlIGVtcHR5IC0gY2Fubm90IGdldCBlbGVtZW50XCI7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGl0ZW0gPSB0aGlzLnFbdGhpcy5oZWFkXTtcclxuXHJcbiAgICByZXR1cm4gaXRlbTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcXVldWUgaGFzIGl0ZW1zIGluIGl0LCBmYWxzZSBvdGhlcndpc2VcclxuICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgcXVldWUgaGFzIGl0ZW1zXHJcbiAgICovXHJcbiAgaGFzSXRlbXMoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5oZWFkICE9PSB0aGlzLnRhaWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHF1ZXVlLlxyXG4gICAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBxdWV1ZVxyXG4gICAqL1xyXG4gIGdldFNpemUoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLnNpemU7XHJcbiAgfVxyXG5cclxuICAvLyBAaW1wbGVtZW50ZWRcclxuICBjbGVhcigpOiB2b2lkIHtcclxuICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IGRlbGV0ZSB0aGlzLnFbaW5kZXhdKTtcclxuICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWw7XHJcbiAgfVxyXG5cclxuICAvLyBAaW1wbGVtZW50ZWRcclxuICBmb3JFYWNoKGZ1bmM6IChpdGVtOiBULCBpbmRleD86IG51bWJlcikgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgbGV0IGkgPSB0aGlzLmhlYWQ7XHJcbiAgICB3aGlsZSAoaSAhPT0gdGhpcy50YWlsKSB7XHJcbiAgICAgIGZ1bmModGhpcy5xW2ldLCBpKTtcclxuICAgICAgaSA9IChpICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRoaXMgcXVldWUgaW50byBhIHN0cmluZyBmb3JtYXRcclxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBxdWV1ZVxyXG4gICAqL1xyXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICBsZXQgcmV0dmFsID0gXCJcIjtcclxuXHJcbiAgICB0aGlzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgIGxldCBzdHIgPSBpdGVtLnRvU3RyaW5nKCk7XHJcbiAgICAgIGlmIChpbmRleCAhPT0gMCkge1xyXG4gICAgICAgIHN0ciArPSBcIiAtPiBcIjtcclxuICAgICAgfVxyXG4gICAgICByZXR2YWwgPSBzdHIgKyByZXR2YWw7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gXCJUb3AgLT4gXCIgKyByZXR2YWw7XHJcbiAgfVxyXG59XHJcbiIsIi8qKiBBIGNvbnRhaW5lciBmb3IgaW5mbyBhYm91dCBhIHdlYkdMIHNoYWRlciBwcm9ncmFtICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMUHJvZ3JhbVR5cGUge1xyXG4gIC8qKiBBIHdlYkdMIHByb2dyYW0gKi9cclxuICBwcm9ncmFtOiBXZWJHTFByb2dyYW07XHJcblxyXG4gIC8qKiBBIHZlcnRleCBzaGFkZXIgKi9cclxuICB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyO1xyXG5cclxuICAvKiogQSBmcmFnbWVudCBzaGFkZXIgKi9cclxuICBmcmFnbWVudFNoYWRlcjogV2ViR0xTaGFkZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZXMgdGhpcyBzaGFkZXIgcHJvZ3JhbVxyXG4gICAqL1xyXG4gIGRlbGV0ZShnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogdm9pZCB7XHJcbiAgICAvLyBDbGVhbiB1cCBhbGwgYXNwZWN0cyBvZiB0aGlzIHByb2dyYW1cclxuICAgIGlmICh0aGlzLnByb2dyYW0pIHtcclxuICAgICAgZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnZlcnRleFNoYWRlcikge1xyXG4gICAgICBnbC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmZyYWdtZW50U2hhZGVyKSB7XHJcbiAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFNoYXBlIGZyb20gXCIuL1NoYXBlXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uLy4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5pbXBvcnQgQ2lyY2xlIGZyb20gXCIuL0NpcmNsZVwiO1xyXG5pbXBvcnQgSGl0IGZyb20gXCIuLi9QaHlzaWNzL0hpdFwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIEF4aXMtQWxpZ25lZCBCb3VuZGluZyBCb3guIEluIG90aGVyIHdvcmRzLCBhIHJlY3RhbmdsZSB0aGF0IGlzIGFsd2F5cyBhbGlnbmVkIHRvIHRoZSB4LXkgZ3JpZC5cclxuICogSW5zcGlyZWQgYnkgdGhlIGhlbHBmdWwgY29sbGlzaW9uIGRvY3VtZW50YXRpb24gQGxpbmsoaGVyZSkoaHR0cHM6Ly9ub29uYXQuZ2l0aHViLmlvL2ludGVyc2VjdC8pLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUFCQiBleHRlbmRzIFNoYXBlIHtcclxuICBjZW50ZXI6IFZlYzI7XHJcbiAgaGFsZlNpemU6IFZlYzI7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgQUFCQlxyXG4gICAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgQUFCQlxyXG4gICAqIEBwYXJhbSBoYWxmU2l6ZSBUaGUgaGFsZiBzaXplIG9mIHRoZSBBQUJCIC0gVGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byBhbiBlZGdlIGluIHggYW5kIHlcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihjZW50ZXI/OiBWZWMyLCBoYWxmU2l6ZT86IFZlYzIpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLmNlbnRlciA9IGNlbnRlciA/IGNlbnRlciA6IG5ldyBWZWMyKDAsIDApO1xyXG4gICAgdGhpcy5oYWxmU2l6ZSA9IGhhbGZTaXplID8gaGFsZlNpemUgOiBuZXcgVmVjMigwLCAwKTtcclxuICB9XHJcblxyXG4gIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cclxuICBnZXQgdG9wTGVmdCgpOiBWZWMyIHtcclxuICAgIHJldHVybiBuZXcgVmVjMih0aGlzLmxlZnQsIHRoaXMudG9wKTtcclxuICB9XHJcblxyXG4gIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSBBQUJCICovXHJcbiAgZ2V0IHRvcFJpZ2h0KCk6IFZlYzIge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMucmlnaHQsIHRoaXMudG9wKTtcclxuICB9XHJcblxyXG4gIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cclxuICBnZXQgYm90dG9tTGVmdCgpOiBWZWMyIHtcclxuICAgIHJldHVybiBuZXcgVmVjMih0aGlzLmxlZnQsIHRoaXMuYm90dG9tKTtcclxuICB9XHJcblxyXG4gIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBBQUJCICovXHJcbiAgZ2V0IGJvdHRvbVJpZ2h0KCk6IFZlYzIge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMucmlnaHQsIHRoaXMuYm90dG9tKTtcclxuICB9XHJcblxyXG4gIC8vIEBvdmVycmlkZVxyXG4gIGdldEJvdW5kaW5nUmVjdCgpOiBBQUJCIHtcclxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcbiAgfVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICBnZXRCb3VuZGluZ0NpcmNsZSgpOiBDaXJjbGUge1xyXG4gICAgbGV0IHIgPSBNYXRoLm1heCh0aGlzLmh3LCB0aGlzLmhoKTtcclxuICAgIHJldHVybiBuZXcgQ2lyY2xlKHRoaXMuY2VudGVyLmNsb25lKCksIHIpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGRlcHJlY2F0ZWRcclxuICBnZXRIYWxmU2l6ZSgpOiBWZWMyIHtcclxuICAgIHJldHVybiB0aGlzLmhhbGZTaXplO1xyXG4gIH1cclxuXHJcbiAgLy8gQGRlcHJlY2F0ZWRcclxuICBzZXRIYWxmU2l6ZShoYWxmU2l6ZTogVmVjMik6IHZvaWQge1xyXG4gICAgdGhpcy5oYWxmU2l6ZSA9IGhhbGZTaXplO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETyAtIG1vdmUgdGhlc2UgYWxsIHRvIHRoZSBTaGFwZSBjbGFzc1xyXG4gIC8qKlxyXG4gICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludFxyXG4gICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcclxuICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcclxuICAgKi9cclxuICBjb250YWluc1BvaW50KHBvaW50OiBWZWMyKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBwb2ludC54ID49IHRoaXMueCAtIHRoaXMuaHcgJiZcclxuICAgICAgcG9pbnQueCA8PSB0aGlzLnggKyB0aGlzLmh3ICYmXHJcbiAgICAgIHBvaW50LnkgPj0gdGhpcy55IC0gdGhpcy5oaCAmJlxyXG4gICAgICBwb2ludC55IDw9IHRoaXMueSArIHRoaXMuaGhcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIGEgcG9pbnRcclxuICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXHJcbiAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyB0aGUgc3BlY2lmaWVkIHBvaW50XHJcbiAgICovXHJcbiAgaW50ZXJzZWN0UG9pbnQocG9pbnQ6IFZlYzIpOiBib29sZWFuIHtcclxuICAgIGxldCBkeCA9IHBvaW50LnggLSB0aGlzLng7XHJcbiAgICBsZXQgcHggPSB0aGlzLmh3IC0gTWF0aC5hYnMoZHgpO1xyXG5cclxuICAgIGlmIChweCA8PSAwKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG4gICAgbGV0IHB5ID0gdGhpcy5oaCAtIE1hdGguYWJzKGR5KTtcclxuXHJcbiAgICBpZiAocHkgPD0gMCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludCB3aXRoIHNvZnQgbGVmdCBhbmQgdG9wIGJvdW5kYXJpZXMuXHJcbiAgICogSW4gb3RoZXIgd29yZHMsIGlmIHRoZSB0b3AgbGVmdCBpcyAoMCwgMCksIHRoZSBwb2ludCAoMCwgMCkgaXMgbm90IGluIHRoZSBBQUJCXHJcbiAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjaGVja1xyXG4gICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxyXG4gICAqL1xyXG4gIGNvbnRhaW5zUG9pbnRTb2Z0KHBvaW50OiBWZWMyKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBwb2ludC54ID4gdGhpcy54IC0gdGhpcy5odyAmJlxyXG4gICAgICBwb2ludC54IDw9IHRoaXMueCArIHRoaXMuaHcgJiZcclxuICAgICAgcG9pbnQueSA+IHRoaXMueSAtIHRoaXMuaGggJiZcclxuICAgICAgcG9pbnQueSA8PSB0aGlzLnkgKyB0aGlzLmhoXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgZGF0YSBmcm9tIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBBQUJCIHdpdGggYSBsaW5lIHNlZ21lbnQgZnJvbSBhIHBvaW50IGluIGEgZGlyZWN0aW9uXHJcbiAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0aGF0IHRoZSBsaW5lIHNlZ21lbnQgc3RhcnRzIGZyb21cclxuICAgKiBAcGFyYW0gZGVsdGEgVGhlIGRpcmVjdGlvbiBhbmQgZGlzdGFuY2Ugb2YgdGhlIHNlZ21lbnRcclxuICAgKiBAcGFyYW0gcGFkZGluZyBQYWRzIHRoZSBBQUJCIHRvIG1ha2UgaXQgd2lkZXIgZm9yIHRoZSBpbnRlcnNlY3Rpb24gdGVzdFxyXG4gICAqIEByZXR1cm5zIFRoZSBIaXQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW50ZXJzZWN0aW9uLCBvciBudWxsIGlmIHRoZXJlIHdhcyBubyBpbnRlcnNlY3Rpb25cclxuICAgKi9cclxuICBpbnRlcnNlY3RTZWdtZW50KHBvaW50OiBWZWMyLCBkZWx0YTogVmVjMiwgcGFkZGluZz86IFZlYzIpOiBIaXQge1xyXG4gICAgbGV0IHBhZGRpbmdYID0gcGFkZGluZyA/IHBhZGRpbmcueCA6IDA7XHJcbiAgICBsZXQgcGFkZGluZ1kgPSBwYWRkaW5nID8gcGFkZGluZy55IDogMDtcclxuXHJcbiAgICBsZXQgc2NhbGVYID0gMSAvIGRlbHRhLng7XHJcbiAgICBsZXQgc2NhbGVZID0gMSAvIGRlbHRhLnk7XHJcblxyXG4gICAgbGV0IHNpZ25YID0gTWF0aFV0aWxzLnNpZ24oc2NhbGVYKTtcclxuICAgIGxldCBzaWduWSA9IE1hdGhVdGlscy5zaWduKHNjYWxlWSk7XHJcblxyXG4gICAgbGV0IHRuZWFyeCA9IHNjYWxlWCAqICh0aGlzLnggLSBzaWduWCAqICh0aGlzLmh3ICsgcGFkZGluZ1gpIC0gcG9pbnQueCk7XHJcbiAgICBsZXQgdG5lYXJ5ID0gc2NhbGVZICogKHRoaXMueSAtIHNpZ25ZICogKHRoaXMuaGggKyBwYWRkaW5nWSkgLSBwb2ludC55KTtcclxuICAgIGxldCB0ZmFyeCA9IHNjYWxlWCAqICh0aGlzLnggKyBzaWduWCAqICh0aGlzLmh3ICsgcGFkZGluZ1gpIC0gcG9pbnQueCk7XHJcbiAgICBsZXQgdGZhcnkgPSBzY2FsZVkgKiAodGhpcy55ICsgc2lnblkgKiAodGhpcy5oaCArIHBhZGRpbmdZKSAtIHBvaW50LnkpO1xyXG5cclxuICAgIGlmICh0bmVhcnggPiB0ZmFyeSB8fCB0bmVhcnkgPiB0ZmFyeCkge1xyXG4gICAgICAvLyBXZSBhcmVuJ3QgY29sbGlkaW5nIC0gd2UgY2xlYXIgb25lIGF4aXMgYmVmb3JlIGludGVyc2VjdGluZyBhbm90aGVyXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB0bmVhciA9IE1hdGgubWF4KHRuZWFyeCwgdG5lYXJ5KTtcclxuXHJcbiAgICAvLyBEb3VibGUgY2hlY2sgZm9yIE5hTnNcclxuICAgIGlmICh0bmVhcnggIT09IHRuZWFyeCkge1xyXG4gICAgICB0bmVhciA9IHRuZWFyeTtcclxuICAgIH0gZWxzZSBpZiAodG5lYXJ5ICE9PSB0bmVhcnkpIHtcclxuICAgICAgdG5lYXIgPSB0bmVhcng7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHRmYXIgPSBNYXRoLm1pbih0ZmFyeCwgdGZhcnkpO1xyXG5cclxuICAgIGlmICh0bmVhciA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0bmVhciA+PSAxIHx8IHRmYXIgPD0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBXZSBhcmUgY29sbGlkaW5nXHJcbiAgICBsZXQgaGl0ID0gbmV3IEhpdCgpO1xyXG4gICAgaGl0LnRpbWUgPSBNYXRoVXRpbHMuY2xhbXAwMSh0bmVhcik7XHJcbiAgICBoaXQubmVhclRpbWVzLnggPSB0bmVhcng7XHJcbiAgICBoaXQubmVhclRpbWVzLnkgPSB0bmVhcnk7XHJcblxyXG4gICAgaWYgKHRuZWFyeCA+IHRuZWFyeSkge1xyXG4gICAgICAvLyBXZSBoaXQgb24gdGhlIGxlZnQgb3IgcmlnaHQgc2l6ZVxyXG4gICAgICBoaXQubm9ybWFsLnggPSAtc2lnblg7XHJcbiAgICAgIGhpdC5ub3JtYWwueSA9IDA7XHJcbiAgICB9IGVsc2UgaWYgKE1hdGguYWJzKHRuZWFyeCAtIHRuZWFyeSkgPCAwLjAwMDEpIHtcclxuICAgICAgLy8gV2UgaGl0IG9uIHRoZSBjb3JuZXJcclxuICAgICAgaGl0Lm5vcm1hbC54ID0gLXNpZ25YO1xyXG4gICAgICBoaXQubm9ybWFsLnkgPSAtc2lnblk7XHJcbiAgICAgIGhpdC5ub3JtYWwubm9ybWFsaXplKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBXZSBoaXQgb24gdGhlIHRvcCBvciBib3R0b21cclxuICAgICAgaGl0Lm5vcm1hbC54ID0gMDtcclxuICAgICAgaGl0Lm5vcm1hbC55ID0gLXNpZ25ZO1xyXG4gICAgfVxyXG5cclxuICAgIGhpdC5kZWx0YS54ID0gKDEuMCAtIGhpdC50aW1lKSAqIC1kZWx0YS54O1xyXG4gICAgaGl0LmRlbHRhLnkgPSAoMS4wIC0gaGl0LnRpbWUpICogLWRlbHRhLnk7XHJcbiAgICBoaXQucG9zLnggPSBwb2ludC54ICsgZGVsdGEueCAqIGhpdC50aW1lO1xyXG4gICAgaGl0LnBvcy55ID0gcG9pbnQueSArIGRlbHRhLnkgKiBoaXQudGltZTtcclxuXHJcbiAgICByZXR1cm4gaGl0O1xyXG4gIH1cclxuXHJcbiAgLy8gQG92ZXJyaWRlXHJcbiAgb3ZlcmxhcHMob3RoZXI6IFNoYXBlKTogYm9vbGVhbiB7XHJcbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBBQUJCKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm92ZXJsYXBzQUFCQihvdGhlcik7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBcIk92ZXJsYXAgbm90IGRlZmluZWQgYmV0d2VlbiB0aGVzZSBzaGFwZXMuXCI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIG92ZXJsYXBzIGFub3RoZXJcclxuICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkIgdG8gY2hlY2sgYWdhaW5zdFxyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBBQUJCIG92ZXJsYXBzIHRoZSBvdGhlciwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIG92ZXJsYXBzQUFCQihvdGhlcjogQUFCQik6IGJvb2xlYW4ge1xyXG4gICAgbGV0IGR4ID0gb3RoZXIueCAtIHRoaXMueDtcclxuICAgIGxldCBweCA9IHRoaXMuaHcgKyBvdGhlci5odyAtIE1hdGguYWJzKGR4KTtcclxuXHJcbiAgICBpZiAocHggPD0gMCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGR5ID0gb3RoZXIueSAtIHRoaXMueTtcclxuICAgIGxldCBweSA9IHRoaXMuaGggKyBvdGhlci5oaCAtIE1hdGguYWJzKGR5KTtcclxuXHJcbiAgICBpZiAocHkgPD0gMCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlc2UgQUFCQnMgYXJlIEpVU1QgdG91Y2hpbmcgLSBub3Qgb3ZlcmxhcHBpbmcuXHJcbiAgICogVmVjMi54IGlzIC0xIGlmIHRoZSBvdGhlciBpcyB0byB0aGUgbGVmdCwgMSBpZiB0byB0aGUgcmlnaHQuXHJcbiAgICogTGlrZXdpc2UsIFZlYzIueSBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgb24gdG9wLCAxIGlmIG9uIGJvdHRvbS5cclxuICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkIgdG8gY2hlY2tcclxuICAgKiBAcmV0dXJucyBUaGUgY29sbGlzaW9uIHNpZGVzIHN0b3JlZCBpbiBhIFZlYzIgaWYgdGhlIEFBQkJzIGFyZSB0b3VjaGluZywgbnVsbCBvdGhlcndpc2VcclxuICAgKi9cclxuICB0b3VjaGVzQUFCQihvdGhlcjogQUFCQik6IFZlYzIge1xyXG4gICAgbGV0IGR4ID0gb3RoZXIueCAtIHRoaXMueDtcclxuICAgIGxldCBweCA9IHRoaXMuaHcgKyBvdGhlci5odyAtIE1hdGguYWJzKGR4KTtcclxuXHJcbiAgICBsZXQgZHkgPSBvdGhlci55IC0gdGhpcy55O1xyXG4gICAgbGV0IHB5ID0gdGhpcy5oaCArIG90aGVyLmhoIC0gTWF0aC5hYnMoZHkpO1xyXG5cclxuICAgIC8vIElmIG9uZSBheGlzIGlzIGp1c3QgdG91Y2hpbmcgYW5kIHRoZSBvdGhlciBpcyBvdmVybGFwcGluZywgdHJ1ZVxyXG4gICAgaWYgKChweCA9PT0gMCAmJiBweSA+PSAwKSB8fCAocHkgPT09IDAgJiYgcHggPj0gMCkpIHtcclxuICAgICAgbGV0IHJldCA9IG5ldyBWZWMyKCk7XHJcblxyXG4gICAgICBpZiAocHggPT09IDApIHtcclxuICAgICAgICByZXQueCA9IG90aGVyLnggPCB0aGlzLnggPyAtMSA6IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChweSA9PT0gMCkge1xyXG4gICAgICAgIHJldC55ID0gb3RoZXIueSA8IHRoaXMueSA/IC0xIDogMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZXNlIEFBQkJzIGFyZSBKVVNUIHRvdWNoaW5nIC0gbm90IG92ZXJsYXBwaW5nLlxyXG4gICAqIEFsc28sIGlmIHRoZXkgYXJlIG9ubHkgdG91Y2hpbmcgY29ybmVycywgdGhleSBhcmUgY29uc2lkZXJlZCBub3QgdG91Y2hpbmcuXHJcbiAgICogVmVjMi54IGlzIC0xIGlmIHRoZSBvdGhlciBpcyB0byB0aGUgbGVmdCwgMSBpZiB0byB0aGUgcmlnaHQuXHJcbiAgICogTGlrZXdpc2UsIFZlYzIueSBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgb24gdG9wLCAxIGlmIG9uIGJvdHRvbS5cclxuICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkIgdG8gY2hlY2tcclxuICAgKiBAcmV0dXJucyBUaGUgc2lkZSBvZiB0aGUgdG91Y2gsIHN0b3JlZCBhcyBhIFZlYzIsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gdG91Y2hcclxuICAgKi9cclxuICB0b3VjaGVzQUFCQldpdGhvdXRDb3JuZXJzKG90aGVyOiBBQUJCKTogVmVjMiB7XHJcbiAgICBsZXQgZHggPSBvdGhlci54IC0gdGhpcy54O1xyXG4gICAgbGV0IHB4ID0gdGhpcy5odyArIG90aGVyLmh3IC0gTWF0aC5hYnMoZHgpO1xyXG5cclxuICAgIGxldCBkeSA9IG90aGVyLnkgLSB0aGlzLnk7XHJcbiAgICBsZXQgcHkgPSB0aGlzLmhoICsgb3RoZXIuaGggLSBNYXRoLmFicyhkeSk7XHJcblxyXG4gICAgLy8gSWYgb25lIGF4aXMgaXMgdG91Y2hpbmcsIGFuZCB0aGUgb3RoZXIgaXMgc3RyaWN0bHkgb3ZlcmxhcHBpbmdcclxuICAgIGlmICgocHggPT09IDAgJiYgcHkgPiAwKSB8fCAocHkgPT09IDAgJiYgcHggPiAwKSkge1xyXG4gICAgICBsZXQgcmV0ID0gbmV3IFZlYzIoKTtcclxuXHJcbiAgICAgIGlmIChweCA9PT0gMCkge1xyXG4gICAgICAgIHJldC54ID0gb3RoZXIueCA8IHRoaXMueCA/IC0xIDogMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXQueSA9IG90aGVyLnkgPCB0aGlzLnkgPyAtMSA6IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIGFyZWEgb2YgdGhlIG92ZXJsYXAgYmV0d2VlbiB0aGlzIEFBQkIgYW5kIGFub3RoZXJcclxuICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkJcclxuICAgKiBAcmV0dXJucyBUaGUgYXJlYSBvZiB0aGUgb3ZlcmxhcCBiZXR3ZWVuIHRoZSBBQUJCc1xyXG4gICAqL1xyXG4gIG92ZXJsYXBBcmVhKG90aGVyOiBBQUJCKTogbnVtYmVyIHtcclxuICAgIGxldCBsZWZ0eCA9IE1hdGgubWF4KHRoaXMueCAtIHRoaXMuaHcsIG90aGVyLnggLSBvdGhlci5odyk7XHJcbiAgICBsZXQgcmlnaHR4ID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy5odywgb3RoZXIueCArIG90aGVyLmh3KTtcclxuICAgIGxldCBkeCA9IHJpZ2h0eCAtIGxlZnR4O1xyXG5cclxuICAgIGxldCBsZWZ0eSA9IE1hdGgubWF4KHRoaXMueSAtIHRoaXMuaGgsIG90aGVyLnkgLSBvdGhlci5oaCk7XHJcbiAgICBsZXQgcmlnaHR5ID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oaCwgb3RoZXIueSArIG90aGVyLmhoKTtcclxuICAgIGxldCBkeSA9IHJpZ2h0eSAtIGxlZnR5O1xyXG5cclxuICAgIGlmIChkeCA8IDAgfHwgZHkgPCAwKSByZXR1cm4gMDtcclxuXHJcbiAgICByZXR1cm4gZHggKiBkeTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdmVzIGFuZCByZXNpemVzIHRoaXMgcmVjdCBmcm9tIGl0cyBjdXJyZW50IHBvc2l0aW9uIHRvIHRoZSBwb3NpdGlvbiBzcGVjaWZpZWRcclxuICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIG1vdmVtZW50IG9mIHRoZSByZWN0IGZyb20gaXRzIHBvc2l0aW9uXHJcbiAgICogQHBhcmFtIGZyb21Qb3NpdGlvbiBBIHBvc2l0aW9uIHNwZWNpZmllZCB0byBiZSB0aGUgc3RhcnRpbmcgcG9pbnQgb2Ygc3dlZXBpbmdcclxuICAgKiBAcGFyYW0gaGFsZlNpemUgVGhlIGhhbGZTaXplIG9mIHRoZSBzd2VlcGluZyByZWN0XHJcbiAgICovXHJcbiAgc3dlZXAodmVsb2NpdHk6IFZlYzIsIGZyb21Qb3NpdGlvbj86IFZlYzIsIGhhbGZTaXplPzogVmVjMik6IHZvaWQge1xyXG4gICAgaWYgKCFmcm9tUG9zaXRpb24pIHtcclxuICAgICAgZnJvbVBvc2l0aW9uID0gdGhpcy5jZW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFoYWxmU2l6ZSkge1xyXG4gICAgICBoYWxmU2l6ZSA9IHRoaXMuaGFsZlNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNlbnRlclggPSBmcm9tUG9zaXRpb24ueCArIHZlbG9jaXR5LnggLyAyO1xyXG4gICAgbGV0IGNlbnRlclkgPSBmcm9tUG9zaXRpb24ueSArIHZlbG9jaXR5LnkgLyAyO1xyXG5cclxuICAgIGxldCBtaW5YID0gTWF0aC5taW4oXHJcbiAgICAgIGZyb21Qb3NpdGlvbi54IC0gaGFsZlNpemUueCxcclxuICAgICAgZnJvbVBvc2l0aW9uLnggKyB2ZWxvY2l0eS54IC0gaGFsZlNpemUueCxcclxuICAgICk7XHJcbiAgICBsZXQgbWluWSA9IE1hdGgubWluKFxyXG4gICAgICBmcm9tUG9zaXRpb24ueSAtIGhhbGZTaXplLnksXHJcbiAgICAgIGZyb21Qb3NpdGlvbi55ICsgdmVsb2NpdHkueSAtIGhhbGZTaXplLnksXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuY2VudGVyLnNldChjZW50ZXJYLCBjZW50ZXJZKTtcclxuICAgIHRoaXMuaGFsZlNpemUuc2V0KGNlbnRlclggLSBtaW5YLCBjZW50ZXJZIC0gbWluWSk7XHJcbiAgfVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICBjbG9uZSgpOiBBQUJCIHtcclxuICAgIHJldHVybiBuZXcgQUFCQih0aGlzLmNlbnRlci5jbG9uZSgpLCB0aGlzLmhhbGZTaXplLmNsb25lKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgdGhpcyBBQUJCIHRvIGEgc3RyaW5nIGZvcm1hdFxyXG4gICAqIEByZXR1cm5zIChjZW50ZXI6ICh4LCB5KSwgaGFsZlNpemU6ICh4LCB5KSlcclxuICAgKi9cclxuICB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgXCIoY2VudGVyOiBcIiArXHJcbiAgICAgIHRoaXMuY2VudGVyLnRvU3RyaW5nKCkgK1xyXG4gICAgICBcIiwgaGFsZi1zaXplOiBcIiArXHJcbiAgICAgIHRoaXMuaGFsZlNpemUudG9TdHJpbmcoKSArXHJcbiAgICAgIFwiKVwiXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi9BQUJCXCI7XHJcbmltcG9ydCBTaGFwZSBmcm9tIFwiLi9TaGFwZVwiO1xyXG5cclxuLyoqXHJcbiAqIEEgQ2lyY2xlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXJjbGUgZXh0ZW5kcyBTaGFwZSB7XHJcbiAgcHJpdmF0ZSBfY2VudGVyOiBWZWMyO1xyXG4gIHJhZGl1czogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IENpcmNsZVxyXG4gICAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcbiAgICogQHBhcmFtIHJhZGl1cyBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihjZW50ZXI6IFZlYzIsIHJhZGl1czogbnVtYmVyKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5fY2VudGVyID0gY2VudGVyID8gY2VudGVyIDogbmV3IFZlYzIoMCwgMCk7XHJcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyA/IHJhZGl1cyA6IDA7XHJcbiAgfVxyXG5cclxuICBnZXQgY2VudGVyKCk6IFZlYzIge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NlbnRlcjtcclxuICB9XHJcblxyXG4gIHNldCBjZW50ZXIoY2VudGVyOiBWZWMyKSB7XHJcbiAgICB0aGlzLl9jZW50ZXIgPSBjZW50ZXI7XHJcbiAgfVxyXG5cclxuICBnZXQgaGFsZlNpemUoKTogVmVjMiB7XHJcbiAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5yYWRpdXMsIHRoaXMucmFkaXVzKTtcclxuICB9XHJcblxyXG4gIGdldCByKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5yYWRpdXM7XHJcbiAgfVxyXG5cclxuICBzZXQgcihyYWRpdXM6IG51bWJlcikge1xyXG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcbiAgfVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICAvKipcclxuICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIGEgcG9pbnRcclxuICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXHJcbiAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyB0aGUgc3BlY2lmaWVkIHBvaW50XHJcbiAgICovXHJcbiAgY29udGFpbnNQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuY2VudGVyLmRpc3RhbmNlU3FUbyhwb2ludCkgPD0gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cztcclxuICB9XHJcblxyXG4gIC8vIEBvdmVycmlkZVxyXG4gIGdldEJvdW5kaW5nUmVjdCgpOiBBQUJCIHtcclxuICAgIHJldHVybiBuZXcgQUFCQih0aGlzLl9jZW50ZXIuY2xvbmUoKSwgbmV3IFZlYzIodGhpcy5yYWRpdXMsIHRoaXMucmFkaXVzKSk7XHJcbiAgfVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICBnZXRCb3VuZGluZ0NpcmNsZSgpOiBDaXJjbGUge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcclxuICB9XHJcblxyXG4gIC8vIEBvdmVycmlkZVxyXG4gIG92ZXJsYXBzKG90aGVyOiBTaGFwZSk6IGJvb2xlYW4ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XHJcbiAgfVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICBjbG9uZSgpOiBDaXJjbGUge1xyXG4gICAgcmV0dXJuIG5ldyBDaXJjbGUodGhpcy5fY2VudGVyLmNsb25lKCksIHRoaXMucmFkaXVzKTtcclxuICB9XHJcblxyXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBcIihjZW50ZXI6IFwiICsgdGhpcy5jZW50ZXIudG9TdHJpbmcoKSArIFwiLCByYWRpdXM6IFwiICsgdGhpcy5yYWRpdXMgKyBcIilcIlxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4vQUFCQlwiO1xyXG5pbXBvcnQgQ2lyY2xlIGZyb20gXCIuL0NpcmNsZVwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFic3RyYWN0IFNoYXBlIGNsYXNzIHRoYXQgYWN0cyBhcyBhbiBpbnRlcmZhY2UgZm9yIGJldHRlciBpbnRlcmFjdGlvbnMgd2l0aCBzdWJjbGFzc2VzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU2hhcGUge1xyXG4gIGFic3RyYWN0IGdldCBjZW50ZXIoKTogVmVjMjtcclxuXHJcbiAgYWJzdHJhY3Qgc2V0IGNlbnRlcihjZW50ZXI6IFZlYzIpO1xyXG5cclxuICBhYnN0cmFjdCBnZXQgaGFsZlNpemUoKTogVmVjMjtcclxuXHJcbiAgZ2V0IHgoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNlbnRlci54O1xyXG4gIH1cclxuXHJcbiAgZ2V0IHkoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNlbnRlci55O1xyXG4gIH1cclxuXHJcbiAgZ2V0IGh3KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5oYWxmU2l6ZS54O1xyXG4gIH1cclxuXHJcbiAgZ2V0IGhoKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5oYWxmU2l6ZS55O1xyXG4gIH1cclxuXHJcbiAgZ2V0IHRvcCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMueSAtIHRoaXMuaGg7XHJcbiAgfVxyXG5cclxuICBnZXQgYm90dG9tKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oaDtcclxuICB9XHJcblxyXG4gIGdldCBsZWZ0KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy54IC0gdGhpcy5odztcclxuICB9XHJcblxyXG4gIGdldCByaWdodCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMueCArIHRoaXMuaHc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGEgYm91bmRpbmcgcmVjdGFuZ2xlIGZvciB0aGlzIHNoYXBlLiBXYXJuaW5nIC0gbWF5IGJlIHRoZSBzYW1lIGFzIHRoaXMgU2hhcGUuXHJcbiAgICogRm9yIGluc3RhbmNlLCB0aGUgYm91bmRpbmcgY2lyY2xlIG9mIGFuIEFBQkIgaXMgaXRzZWxmLiBVc2UgY2xvbmUoKSBpZiB5b3UgbmVlZCBhIG5ldyBzaGFwZS5cclxuICAgKiBAcmV0dXJucyBBbiBBQUJCIHRoYXQgYm91bmRzIHRoaXMgc2hhcGVcclxuICAgKi9cclxuICBhYnN0cmFjdCBnZXRCb3VuZGluZ1JlY3QoKTogQUFCQjtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhIGJvdW5kaW5nIGNpcmNsZSBmb3IgdGhpcyBzaGFwZS4gV2FybmluZyAtIG1heSBiZSB0aGUgc2FtZSBhcyB0aGlzIFNoYXBlLlxyXG4gICAqIEZvciBpbnN0YW5jZSwgdGhlIGJvdW5kaW5nIGNpcmNsZSBvZiBhIENpcmNsZSBpcyBpdHNlbGYuIFVzZSBjbG9uZSgpIGlmIHlvdSBuZWVkIGEgbmV3IHNoYXBlLlxyXG4gICAqIEByZXR1cm5zIEEgQ2lyY2xlIHRoYXQgYm91bmRzIHRoaXMgc2hhcGVcclxuICAgKi9cclxuICBhYnN0cmFjdCBnZXRCb3VuZGluZ0NpcmNsZSgpOiBDaXJjbGU7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgU2hhcGVcclxuICAgKiBAcmV0dXJucyBBIG5ldyBjb3B5IG9mIHRoaXMgc2hhcGVcclxuICAgKi9cclxuICBhYnN0cmFjdCBjbG9uZSgpOiBTaGFwZTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoaXMgc2hhcGUgb3ZlcmxhcHMgYW5vdGhlclxyXG4gICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgc2hhcGUgdG8gY2hlY2sgYWdhaW5zdFxyXG4gICAqIEByZXR1cm5zIGEgYm9vbGVhbiB0aGF0IHJlcHJlc2VudHMgd2hldGhlciB0aGlzIFNoYXBlIG92ZXJsYXBzIHRoZSBvdGhlciBvbmVcclxuICAgKi9cclxuICBhYnN0cmFjdCBvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuO1xyXG5cclxuICAvKipcclxuICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBTaGFwZSBjb250YWlucyBhIHBvaW50XHJcbiAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjaGVja1xyXG4gICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIFNoYXBlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcclxuICAgKi9cclxuICBhYnN0cmFjdCBjb250YWluc1BvaW50KHBvaW50OiBWZWMyKTogYm9vbGVhbjtcclxuXHJcbiAgc3RhdGljIGdldFRpbWVPZkNvbGxpc2lvbihcclxuICAgIEE6IFNoYXBlLFxyXG4gICAgdmVsQTogVmVjMixcclxuICAgIEI6IFNoYXBlLFxyXG4gICAgdmVsQjogVmVjMixcclxuICApOiBbVmVjMiwgVmVjMiwgYm9vbGVhbiwgYm9vbGVhbl0ge1xyXG4gICAgaWYgKEEgaW5zdGFuY2VvZiBBQUJCICYmIEIgaW5zdGFuY2VvZiBBQUJCKSB7XHJcbiAgICAgIHJldHVybiBTaGFwZS5nZXRUaW1lT2ZDb2xsaXNpb25fQUFCQl9BQUJCKEEsIHZlbEEsIEIsIHZlbEIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VGltZU9mQ29sbGlzaW9uX0FBQkJfQUFCQihcclxuICAgIEE6IEFBQkIsXHJcbiAgICB2ZWxBOiBWZWMyLFxyXG4gICAgQjogU2hhcGUsXHJcbiAgICB2ZWxCOiBWZWMyLFxyXG4gICk6IFtWZWMyLCBWZWMyLCBib29sZWFuLCBib29sZWFuXSB7XHJcbiAgICBsZXQgcG9zU21hbGxlciA9IEEuY2VudGVyO1xyXG4gICAgbGV0IHBvc0xhcmdlciA9IEIuY2VudGVyO1xyXG5cclxuICAgIGxldCBzaXplU21hbGxlciA9IEEuaGFsZlNpemU7XHJcbiAgICBsZXQgc2l6ZUxhcmdlciA9IEIuaGFsZlNpemU7XHJcblxyXG4gICAgbGV0IGZpcnN0Q29udGFjdCA9IG5ldyBWZWMyKDAsIDApO1xyXG4gICAgbGV0IGxhc3RDb250YWN0ID0gbmV3IFZlYzIoMCwgMCk7XHJcblxyXG4gICAgbGV0IGNvbGxpZGluZ1ggPSBmYWxzZTtcclxuICAgIGxldCBjb2xsaWRpbmdZID0gZmFsc2U7XHJcblxyXG4gICAgLy8gU29ydCBieSBwb3NpdGlvblxyXG4gICAgaWYgKHBvc0xhcmdlci54IDwgcG9zU21hbGxlci54KSB7XHJcbiAgICAgIC8vIFN3YXAsIGJlY2F1c2Ugc21hbGxlciBpcyBmdXJ0aGVyIHJpZ2h0IHRoYW4gbGFyZ2VyXHJcbiAgICAgIGxldCB0ZW1wOiBWZWMyO1xyXG4gICAgICB0ZW1wID0gc2l6ZVNtYWxsZXI7XHJcbiAgICAgIHNpemVTbWFsbGVyID0gc2l6ZUxhcmdlcjtcclxuICAgICAgc2l6ZUxhcmdlciA9IHRlbXA7XHJcblxyXG4gICAgICB0ZW1wID0gcG9zU21hbGxlcjtcclxuICAgICAgcG9zU21hbGxlciA9IHBvc0xhcmdlcjtcclxuICAgICAgcG9zTGFyZ2VyID0gdGVtcDtcclxuXHJcbiAgICAgIHRlbXAgPSB2ZWxBO1xyXG4gICAgICB2ZWxBID0gdmVsQjtcclxuICAgICAgdmVsQiA9IHRlbXA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQSBpcyBsZWZ0LCBCIGlzIHJpZ2h0XHJcbiAgICBmaXJzdENvbnRhY3QueCA9IEluZmluaXR5O1xyXG4gICAgbGFzdENvbnRhY3QueCA9IEluZmluaXR5O1xyXG5cclxuICAgIGlmIChwb3NMYXJnZXIueCAtIHNpemVMYXJnZXIueCA+PSBwb3NTbWFsbGVyLnggKyBzaXplU21hbGxlci54KSB7XHJcbiAgICAgIC8vIElmIHdlIGFyZW4ndCBjdXJyZW50bHkgY29sbGlkaW5nXHJcbiAgICAgIGxldCByZWxWZWwgPSB2ZWxBLnggLSB2ZWxCLng7XHJcblxyXG4gICAgICBpZiAocmVsVmVsID4gMCkge1xyXG4gICAgICAgIC8vIElmIHRoZXkgYXJlIG1vdmluZyB0b3dhcmRzIGVhY2ggb3RoZXJcclxuICAgICAgICBmaXJzdENvbnRhY3QueCA9XHJcbiAgICAgICAgICAocG9zTGFyZ2VyLnggLSBzaXplTGFyZ2VyLnggLSAocG9zU21hbGxlci54ICsgc2l6ZVNtYWxsZXIueCkpIC9cclxuICAgICAgICAgIHJlbFZlbDtcclxuICAgICAgICBsYXN0Q29udGFjdC54ID1cclxuICAgICAgICAgIChwb3NMYXJnZXIueCArIHNpemVMYXJnZXIueCAtIChwb3NTbWFsbGVyLnggLSBzaXplU21hbGxlci54KSkgL1xyXG4gICAgICAgICAgcmVsVmVsO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb2xsaWRpbmdYID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocG9zTGFyZ2VyLnkgPCBwb3NTbWFsbGVyLnkpIHtcclxuICAgICAgLy8gU3dhcCwgYmVjYXVzZSBzbWFsbGVyIGlzIGZ1cnRoZXIgdXAgdGhhbiBsYXJnZXJcclxuICAgICAgbGV0IHRlbXA6IFZlYzI7XHJcbiAgICAgIHRlbXAgPSBzaXplU21hbGxlcjtcclxuICAgICAgc2l6ZVNtYWxsZXIgPSBzaXplTGFyZ2VyO1xyXG4gICAgICBzaXplTGFyZ2VyID0gdGVtcDtcclxuXHJcbiAgICAgIHRlbXAgPSBwb3NTbWFsbGVyO1xyXG4gICAgICBwb3NTbWFsbGVyID0gcG9zTGFyZ2VyO1xyXG4gICAgICBwb3NMYXJnZXIgPSB0ZW1wO1xyXG5cclxuICAgICAgdGVtcCA9IHZlbEE7XHJcbiAgICAgIHZlbEEgPSB2ZWxCO1xyXG4gICAgICB2ZWxCID0gdGVtcDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBIGlzIHRvcCwgQiBpcyBib3R0b21cclxuICAgIGZpcnN0Q29udGFjdC55ID0gSW5maW5pdHk7XHJcbiAgICBsYXN0Q29udGFjdC55ID0gSW5maW5pdHk7XHJcblxyXG4gICAgaWYgKHBvc0xhcmdlci55IC0gc2l6ZUxhcmdlci55ID49IHBvc1NtYWxsZXIueSArIHNpemVTbWFsbGVyLnkpIHtcclxuICAgICAgLy8gSWYgd2UgYXJlbid0IGN1cnJlbnRseSBjb2xsaWRpbmdcclxuICAgICAgbGV0IHJlbFZlbCA9IHZlbEEueSAtIHZlbEIueTtcclxuXHJcbiAgICAgIGlmIChyZWxWZWwgPiAwKSB7XHJcbiAgICAgICAgLy8gSWYgdGhleSBhcmUgbW92aW5nIHRvd2FyZHMgZWFjaCBvdGhlclxyXG4gICAgICAgIGZpcnN0Q29udGFjdC55ID1cclxuICAgICAgICAgIChwb3NMYXJnZXIueSAtIHNpemVMYXJnZXIueSAtIChwb3NTbWFsbGVyLnkgKyBzaXplU21hbGxlci55KSkgL1xyXG4gICAgICAgICAgcmVsVmVsO1xyXG4gICAgICAgIGxhc3RDb250YWN0LnkgPVxyXG4gICAgICAgICAgKHBvc0xhcmdlci55ICsgc2l6ZUxhcmdlci55IC0gKHBvc1NtYWxsZXIueSAtIHNpemVTbWFsbGVyLnkpKSAvXHJcbiAgICAgICAgICByZWxWZWw7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbGxpZGluZ1kgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbZmlyc3RDb250YWN0LCBsYXN0Q29udGFjdCwgY29sbGlkaW5nWCwgY29sbGlkaW5nWV07XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBDb2xsZWN0aW9uIGZyb20gXCIuL0NvbGxlY3Rpb25cIjtcclxuXHJcbi8qKlxyXG4gKiBBIExJRk8gc3RhY2sgd2l0aCBpdGVtcyBvZiB0eXBlIFRcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YWNrPFQ+IGltcGxlbWVudHMgQ29sbGVjdGlvbiB7XHJcbiAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgU3RhY2sgKi9cclxuICBwcml2YXRlIE1BWF9FTEVNRU5UUzogbnVtYmVyO1xyXG5cclxuICAvKiogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdGFjayAqL1xyXG4gIHByaXZhdGUgc3RhY2s6IEFycmF5PFQ+O1xyXG5cclxuICAvKiogVGhlIGhlYWQgb2YgdGhlIHN0YWNrICovXHJcbiAgcHJpdmF0ZSBoZWFkOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgc3RhY2tcclxuICAgKiBAcGFyYW0gbWF4RWxlbWVudHMgVGhlIG1heGltdW0gc2l6ZSBvZiB0aGUgc3RhY2tcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihtYXhFbGVtZW50czogbnVtYmVyID0gMTAwKSB7XHJcbiAgICB0aGlzLk1BWF9FTEVNRU5UUyA9IG1heEVsZW1lbnRzO1xyXG4gICAgdGhpcy5zdGFjayA9IG5ldyBBcnJheTxUPih0aGlzLk1BWF9FTEVNRU5UUyk7XHJcbiAgICB0aGlzLmhlYWQgPSAtMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAqIEBwYXJhbSBpdGVtIFRoZSBuZXcgaXRlbSB0byBhZGQgdG8gdGhlIHN0YWNrXHJcbiAgICovXHJcbiAgcHVzaChpdGVtOiBUKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5oZWFkICsgMSA9PT0gdGhpcy5NQVhfRUxFTUVOVFMpIHtcclxuICAgICAgdGhyb3cgXCJTdGFjayBmdWxsIC0gY2Fubm90IGFkZCBlbGVtZW50XCI7XHJcbiAgICB9XHJcbiAgICB0aGlzLmhlYWQgKz0gMTtcclxuICAgIHRoaXMuc3RhY2tbdGhpcy5oZWFkXSA9IGl0ZW07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICovXHJcbiAgcG9wKCk6IFQge1xyXG4gICAgaWYgKHRoaXMuaGVhZCA9PT0gLTEpIHtcclxuICAgICAgdGhyb3cgXCJTdGFjayBlbXB0eSAtIGNhbm5vdCByZW1vdmUgZWxlbWVudFwiO1xyXG4gICAgfVxyXG4gICAgdGhpcy5oZWFkIC09IDE7XHJcbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLmhlYWQgKyAxXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnQgY3VycmVudGx5IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcclxuICAgKi9cclxuICBwZWVrKCk6IFQge1xyXG4gICAgaWYgKHRoaXMuaGVhZCA9PT0gLTEpIHtcclxuICAgICAgdGhyb3cgXCJTdGFjayBlbXB0eSAtIGNhbm5vdCBnZXQgZWxlbWVudFwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5oZWFkXTtcclxuICB9XHJcblxyXG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBzdGFjayBpcyBlbXB0eVxyXG4gICAqIEByZXR1cm5zIEEgYm9vbGVhbiB0aGF0IHJlcHJlc2VudHMgd2hldGhlciBvciBub3QgdGhlIHN0YWNrIGlzIGVtcHR5XHJcbiAgICovXHJcbiAgaXNFbXB0eSgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmhlYWQgPT09IC0xO1xyXG4gIH1cclxuXHJcbiAgLy8gQGltcGxlbWVudGVkXHJcbiAgY2xlYXIoKTogdm9pZCB7XHJcbiAgICB0aGlzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiBkZWxldGUgdGhpcy5zdGFja1tpbmRleF0pO1xyXG4gICAgdGhpcy5oZWFkID0gLTE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgaXRlbXMgY3VycmVudGx5IGluIHRoZSBzdGFja1xyXG4gICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHN0YWNrXHJcbiAgICovXHJcbiAgc2l6ZSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuaGVhZCArIDE7XHJcbiAgfVxyXG5cclxuICAvLyBAaW1wbGVtZW50ZWRcclxuICBmb3JFYWNoKGZ1bmM6IChpdGVtOiBULCBpbmRleD86IG51bWJlcikgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPD0gdGhpcy5oZWFkKSB7XHJcbiAgICAgIGZ1bmModGhpcy5zdGFja1tpXSwgaSk7XHJcbiAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRoaXMgc3RhY2sgaW50byBhIHN0cmluZyBmb3JtYXRcclxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBzdGFja1xyXG4gICAqL1xyXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICBsZXQgcmV0dmFsID0gXCJcIjtcclxuXHJcbiAgICB0aGlzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgIGxldCBzdHIgPSBpdGVtLnRvU3RyaW5nKCk7XHJcbiAgICAgIGlmIChpbmRleCAhPT0gMCkge1xyXG4gICAgICAgIHN0ciArPSBcIiAtPiBcIjtcclxuICAgICAgfVxyXG4gICAgICByZXR2YWwgPSBzdHIgKyByZXR2YWw7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gXCJUb3AgLT4gXCIgKyByZXR2YWw7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi9FdmVudHMvRW1pdHRlclwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IFN0YXRlTWFjaGluZSBmcm9tIFwiLi9TdGF0ZU1hY2hpbmVcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiBhIHN0YXRlIGZvciBhIEByZWZlcmVuY2VbU3RhdGVNYWNoaW5lXS5cclxuICogVGhpcyBjbGFzcyBzaG91bGQgYmUgZXh0ZW5kZWQgdG8gYWxsb3cgZm9yIGN1c3RvbSBzdGF0ZSBiZWhhdmlvcnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBTdGF0ZSBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG4gIC8qKiBUaGUgU3RhdGVNYWNoaW5lIHRoYXQgdXNlcyB0aGlzIFN0YXRlICovXHJcbiAgcHJvdGVjdGVkIHBhcmVudDogU3RhdGVNYWNoaW5lO1xyXG5cclxuICAvKiogQW4gZXZlbnQgZW1pdHRlciAqL1xyXG4gIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFN0YXRlXHJcbiAgICogQHBhcmFtIHBhcmVudCBUaGUgcGFyZW50IFN0YXRlTWFjaGluZSBvZiB0aGlzIHN0YXRlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IocGFyZW50OiBTdGF0ZU1hY2hpbmUpIHtcclxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhpcyBzdGF0ZSBpcyBlbnRlcmVkLiBVc2UgdGhpcyB0byBpbml0aWFsaXplIGFueSB2YXJpYWJsZXMgYmVmb3JlIHVwZGF0ZXMgb2NjdXIuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgSW5mb3JtYXRpb24gdG8gcGFzcyB0byB0aGlzIHN0YXRlXHJcbiAgICovXHJcbiAgYWJzdHJhY3Qgb25FbnRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgaGFuZGxlcyBhbiBpbnB1dCBldmVudCwgc3VjaCBhcyB0YWtpbmcgZGFtYWdlLlxyXG4gICAqIEBwYXJhbSBldmVudCBUaGUgR2FtZUV2ZW50IHRvIHByb2Nlc3NcclxuICAgKi9cclxuICBhYnN0cmFjdCBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZDtcclxuXHJcbiAgLy8gQGltcGxlbWVudGVkXHJcbiAgYWJzdHJhY3QgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogVGVsbHMgdGhlIHN0YXRlIG1hY2hpbmUgdGhhdCB0aGlzIHN0YXRlIGhhcyBlbmRlZCwgYW5kIG1ha2VzIGl0IHRyYW5zaXRpb24gdG8gdGhlIG5ldyBzdGF0ZSBzcGVjaWZpZWRcclxuICAgKiBAcGFyYW0gc3RhdGVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGZpbmlzaGVkKHN0YXRlTmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLnBhcmVudC5jaGFuZ2VTdGF0ZShzdGF0ZU5hbWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBsaWZlY3ljbGUgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSBzdGF0ZSBpcyBlbmRpbmcuXHJcbiAgICogQHJldHVybnMgaW5mbyB0byBwYXNzIHRvIHRoZSBuZXh0IHN0YXRlXHJcbiAgICovXHJcbiAgYWJzdHJhY3Qgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT47XHJcbn1cclxuIiwiaW1wb3J0IFN0YWNrIGZyb20gXCIuLi9TdGFja1wiO1xyXG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4vU3RhdGVcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vTWFwXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi8uLi9FdmVudHMvUmVjZWl2ZXJcIjtcclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9FbWl0dGVyXCI7XHJcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIFB1c2ggRG93biBBdXRvbWF0YSBTdGF0ZSBtYWNoaW5lLiBTdGF0ZXMgY2FuIGFsc28gYmUgaGllcmFyY2hpY2FsXHJcbiAqIGZvciBtb3JlIGZsZXhpYmlsaXR5LCBhcyBkZXNjcmliZWQgaW4gQGxpbmsoR2FtZSBQcm9ncmFtbWluZyBQYXR0ZXJucykoaHR0cHM6Ly9nYW1lcHJvZ3JhbW1pbmdwYXR0ZXJucy5jb20vc3RhdGUuaHRtbCkuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZU1hY2hpbmUgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuICAvKiogQSBzdGFjayBvZiB0aGUgY3VycmVudCBzdGF0ZXMgKi9cclxuICBwcm90ZWN0ZWQgc3RhY2s6IFN0YWNrPFN0YXRlPjtcclxuICAvKiogQSBtYXBlIG9mIHN0YXRlIGtleXMgdG8gYWN0dWFsIHN0YXRlIGluc3RhbmNlcyAqL1xyXG4gIHByb3RlY3RlZCBzdGF0ZU1hcDogTWFwPFN0YXRlPjtcclxuICAvKiogVGhlIGN1cnJlbnQgc3RhdGUgKi9cclxuICBwcm90ZWN0ZWQgY3VycmVudFN0YXRlOiBTdGF0ZTtcclxuICAvKiogQW4gZXZlbnQgcmVjZWl2ZXIgKi9cclxuICBwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xyXG4gIC8qKiBBbiBldmVudCBlbWl0dGVyICovXHJcbiAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcbiAgLyoqIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhpcyBTdGF0ZU1hY2hpbmUgaXMgY3VycmVudGx5IGFjdGl2ZSAqL1xyXG4gIHByb3RlY3RlZCBhY3RpdmU6IGJvb2xlYW47XHJcbiAgLyoqIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhpcyBTdGF0ZU1hY2hpbmUgc2hvdWxkIGVtaXQgYW4gZXZlbnQgb24gc3RhdGUgY2hhbmdlICovXHJcbiAgcHJvdGVjdGVkIGVtaXRFdmVudE9uU3RhdGVDaGFuZ2U6IGJvb2xlYW47XHJcbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSBlbWl0dGVkIG9uIHN0YXRlIGNoYW5nZSAqL1xyXG4gIHByb3RlY3RlZCBzdGF0ZUNoYW5nZUV2ZW50TmFtZTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IFN0YXRlTWFjaGluZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5zdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgdGhpcy5zdGF0ZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcclxuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICB0aGlzLmVtaXRFdmVudE9uU3RhdGVDaGFuZ2UgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHN1YnNjcmliZShldmVudFR5cGVzOiBzdHJpbmcgfCBzdHJpbmdbXSkge1xyXG4gICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoZXZlbnRUeXBlcyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGdldFN0YXRlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFN0YXRlO1xyXG4gIH1cclxuXHJcbiAgaXNTdGF0ZShzdGF0ZTogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGF0ZU1hcC5nZXQoc3RhdGUpID09IHRoaXMuY3VycmVudFN0YXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgYWN0aXZpdHkgc3RhdGUgb2YgdGhpcyBzdGF0ZSBtYWNoaW5lXHJcbiAgICogQHBhcmFtIGZsYWcgVHJ1ZSBpZiB5b3Ugd2FudCB0byBzZXQgdGhpcyBtYWNoaW5lIHJ1bm5pbmcsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIHNldEFjdGl2ZShmbGFnOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICB0aGlzLmFjdGl2ZSA9IGZsYWc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNYWtlcyB0aGlzIHN0YXRlIG1hY2hpbmUgZW1pdCBhbiBldmVudCBhbnkgdGltZSBpdHMgc3RhdGUgY2hhbmdlc1xyXG4gICAqIEBwYXJhbSBzdGF0ZUNoYW5nZUV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdFxyXG4gICAqL1xyXG4gIHNldEVtaXRFdmVudE9uU3RhdGVDaGFuZ2Uoc3RhdGVDaGFuZ2VFdmVudE5hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdGhpcy5lbWl0RXZlbnRPblN0YXRlQ2hhbmdlID0gdHJ1ZTtcclxuICAgIHRoaXMuc3RhdGVDaGFuZ2VFdmVudE5hbWUgPSBzdGF0ZUNoYW5nZUV2ZW50TmFtZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3BzIHRoaXMgc3RhdGUgbWFjaGluZSBmcm9tIGVtaXR0aW5nIGV2ZW50cyBvbiBzdGF0ZSBjaGFuZ2UuXHJcbiAgICovXHJcbiAgY2FuY2VsRW1pdEV2ZW50T25TdGF0ZUNoYW5nZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgdGhpcyBzdGF0ZSBtYWNoaW5lIHdpdGggYW4gaW5pdGlhbCBzdGF0ZSBhbmQgc2V0cyBpdCBydW5uaW5nXHJcbiAgICogQHBhcmFtIGluaXRpYWxTdGF0ZSBUaGUgbmFtZSBvZiBpbml0aWFsIHN0YXRlIG9mIHRoZSBzdGF0ZSBtYWNoaW5lXHJcbiAgICovXHJcbiAgaW5pdGlhbGl6ZShpbml0aWFsU3RhdGU6IHN0cmluZywgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlTWFwLmdldChpbml0aWFsU3RhdGUpKTtcclxuICAgIHRoaXMuY3VycmVudFN0YXRlID0gdGhpcy5zdGFjay5wZWVrKCk7XHJcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZS5vbkVudGVyKG9wdGlvbnMpO1xyXG4gICAgdGhpcy5zZXRBY3RpdmUodHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgc3RhdGUgdG8gdGhpcyBzdGF0ZSBtYWNoaW5lXHJcbiAgICogQHBhcmFtIHN0YXRlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgdG8gYWRkXHJcbiAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0byBhZGRcclxuICAgKi9cclxuICBhZGRTdGF0ZShzdGF0ZU5hbWU6IHN0cmluZywgc3RhdGU6IFN0YXRlKSB7XHJcbiAgICB0aGlzLnN0YXRlTWFwLmFkZChzdGF0ZU5hbWUsIHN0YXRlKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hhbmdlcyB0aGUgc3RhdGUgb2YgdGhpcyBzdGF0ZSBtYWNoaW5lIHRvIHRoZSBwcm92aWRlZCBzdHJpbmdcclxuICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0cmluZyBuYW1lIG9mIHRoZSBzdGF0ZSB0byBjaGFuZ2UgdG9cclxuICAgKi9cclxuICBjaGFuZ2VTdGF0ZShzdGF0ZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAvLyBFeGl0IHRoZSBjdXJyZW50IHN0YXRlXHJcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuY3VycmVudFN0YXRlLm9uRXhpdCgpO1xyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgY29ycmVjdCBzdGF0ZSBpcyBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgaWYgKHN0YXRlID09PSBcInByZXZpb3VzXCIpIHtcclxuICAgICAgLy8gUG9wIHRoZSBjdXJyZW50IHN0YXRlIG9mZiB0aGUgc3RhY2tcclxuICAgICAgdGhpcy5zdGFjay5wb3AoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFJldHJpZXZlIHRoZSBuZXcgc3RhdGUgZnJvbSB0aGUgc3RhdGVtYXAgYW5kIHB1dCBpdCBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZU1hcC5nZXQoc3RhdGUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXRyZWl2ZSB0aGUgbmV3IHN0YXRlIGZyb20gdGhlIHN0YWNrXHJcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RhY2sucGVlaygpO1xyXG5cclxuICAgIC8vIEVtaXQgYW4gZXZlbnQgaWYgdHVybmVkIG9uXHJcbiAgICBpZiAodGhpcy5lbWl0RXZlbnRPblN0YXRlQ2hhbmdlKSB7XHJcbiAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5zdGF0ZUNoYW5nZUV2ZW50TmFtZSwge1xyXG4gICAgICAgIHN0YXRlOiB0aGlzLmN1cnJlbnRTdGF0ZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRW50ZXIgdGhlIG5ldyBzdGF0ZVxyXG4gICAgdGhpcy5jdXJyZW50U3RhdGUub25FbnRlcihvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgaW5wdXQuIFRoaXMgaGFwcGVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhpcyBzdGF0ZSBtYWNoaW5lJ3MgdXBkYXRlIGN5Y2xlLlxyXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZ2FtZSBldmVudCB0byBwcm9jZXNzXHJcbiAgICovXHJcbiAgaGFuZGxlRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudFN0YXRlLmhhbmRsZUlucHV0KGV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEBpbXBsZW1lbnRlZFxyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgLy8gRGlzdHJpYnV0ZSBldmVudHNcclxuICAgIHdoaWxlICh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XHJcbiAgICAgIGxldCBldmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XHJcbiAgICAgIHRoaXMuaGFuZGxlRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlbGVnYXRlIHRoZSB1cGRhdGUgdG8gdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgIHRoaXMuY3VycmVudFN0YXRlLnVwZGF0ZShkZWx0YVQpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCB7IFRpbGVkVGlsZXNldERhdGEgfSBmcm9tIFwiLi9UaWxlZERhdGFcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgZGF0YSByZXByZXNlbnRhdGlvbiBvZiBhIFRpbGVzZXQgZm9yIHRoZSBnYW1lIGVuZ2luZS4gVGhpcyByZXByZXNlbnRzIG9uZSBpbWFnZSxcclxuICogd2l0aCBhIHN0YXJ0SW5kZXggaWYgcmVxdWlyZWQgKGFzIGl0IGlzIHdpdGggVGlsZWQgdXNpbmcgdHdvIGltYWdlcyBpbiBvbmUgdGlsc2V0KS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVzZXQge1xyXG4gIC8qKiBUaGUga2V5IG9mIHRoZSBpbWFnZSB1c2VkIGJ5IHRoaXMgdGlsZXNldCAqL1xyXG4gIHByb3RlY3RlZCBpbWFnZUtleTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgc2l6ZSBvZiB0aGUgdGlsZXNldCBpbWFnZSAqL1xyXG4gIHByb3RlY3RlZCBpbWFnZVNpemU6IFZlYzI7XHJcbiAgLyoqIFRoZSBpbmRleCBvZiAwdGggaW1hZ2Ugb2YgdGhpcyB0aWxlc2V0ICovXHJcbiAgcHJvdGVjdGVkIHN0YXJ0SW5kZXg6IG51bWJlcjtcclxuICAvKiogVGhlIGluZGV4IG9mIHRoZSBsYXN0IGltYWdlIG9mIHRoaXMgdGlsc2V0ICovXHJcbiAgcHJvdGVjdGVkIGVuZEluZGV4OiBudW1iZXI7XHJcbiAgLyoqIFRoZSBzaXplIG9mIHRoZSB0aWxlcyBpbiB0aGlzIHRpbGVzZXQgKi9cclxuICBwcm90ZWN0ZWQgdGlsZVNpemU6IFZlYzI7XHJcbiAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGlzIHRpbGVzZXQgKi9cclxuICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xyXG4gIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhpcyB0aWxlc2V0ICovXHJcbiAgcHJvdGVjdGVkIG51bUNvbHM6IG51bWJlcjtcclxuXHJcbiAgLy8gVE9ETzogQ2hhbmdlIHRoaXMgdG8gYmUgbW9yZSBnZW5lcmFsIGFuZCB3b3JrIHdpdGggb3RoZXIgdGlsZXNldCBmb3JtYXRzXHJcbiAgY29uc3RydWN0b3IodGlsZXNldERhdGE6IFRpbGVkVGlsZXNldERhdGEpIHtcclxuICAgIC8vIERlZmVyIGhhbmRsaW5nIG9mIHRoZSBkYXRhIHRvIGEgaGVscGVyIGNsYXNzXHJcbiAgICB0aGlzLmluaXRGcm9tVGlsZWREYXRhKHRpbGVzZXREYXRhKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgdGhlIHRpbGVzZXQgZnJvbSB0aGUgZGF0YSBmcm9tIGEgVGlsZWQganNvbiBmaWxlXHJcbiAgICogQHBhcmFtIHRpbGVkRGF0YSBUaGUgcGFyc2VkIG9iamVjdCBmcm9tIGEgVGlsZWQganNvbiBmaWxlXHJcbiAgICovXHJcbiAgaW5pdEZyb21UaWxlZERhdGEodGlsZWREYXRhOiBUaWxlZFRpbGVzZXREYXRhKTogdm9pZCB7XHJcbiAgICB0aGlzLm51bVJvd3MgPSB0aWxlZERhdGEudGlsZWNvdW50IC8gdGlsZWREYXRhLmNvbHVtbnM7XHJcbiAgICB0aGlzLm51bUNvbHMgPSB0aWxlZERhdGEuY29sdW1ucztcclxuICAgIHRoaXMuc3RhcnRJbmRleCA9IHRpbGVkRGF0YS5maXJzdGdpZDtcclxuICAgIHRoaXMuZW5kSW5kZXggPSB0aGlzLnN0YXJ0SW5kZXggKyB0aWxlZERhdGEudGlsZWNvdW50IC0gMTtcclxuICAgIHRoaXMudGlsZVNpemUgPSBuZXcgVmVjMih0aWxlZERhdGEudGlsZXdpZHRoLCB0aWxlZERhdGEudGlsZXdpZHRoKTtcclxuICAgIHRoaXMuaW1hZ2VLZXkgPSB0aWxlZERhdGEuaW1hZ2U7XHJcbiAgICB0aGlzLmltYWdlU2l6ZSA9IG5ldyBWZWMyKHRpbGVkRGF0YS5pbWFnZXdpZHRoLCB0aWxlZERhdGEuaW1hZ2VoZWlnaHQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgaW1hZ2Uga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRpbGVtYXBcclxuICAgKiBAcmV0dXJucyBUaGUgaW1hZ2Uga2V5IG9mIHRoaXMgdGlsZW1hcFxyXG4gICAqL1xyXG4gIGdldEltYWdlS2V5KCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5pbWFnZUtleTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBWZWMyIGNvbnRhaW5pbmcgdGhlIGxlZnQgYW5kIHRvcCBvZmZzZXQgZnJvbSB0aGUgaW1hZ2Ugb3JpZ2luIGZvciB0aGlzIHRpbGUuXHJcbiAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgZnJvbSBzdGFydEluZGV4IHRvIGVuZEluZGV4IG9mIHRoaXMgdGlsZXNldFxyXG4gICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBvZmZzZXQgZm9yIHRoZSBzcGVjaWZpZWQgdGlsZS5cclxuICAgKi9cclxuICBnZXRJbWFnZU9mZnNldEZvclRpbGUodGlsZUluZGV4OiBudW1iZXIpOiBWZWMyIHtcclxuICAgIC8vIEdldCB0aGUgdHJ1ZSBpbmRleFxyXG4gICAgbGV0IGluZGV4ID0gdGlsZUluZGV4IC0gdGhpcy5zdGFydEluZGV4O1xyXG4gICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpO1xyXG4gICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xyXG4gICAgbGV0IHdpZHRoID0gdGhpcy50aWxlU2l6ZS54O1xyXG4gICAgbGV0IGhlaWdodCA9IHRoaXMudGlsZVNpemUueTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIHRvIHN0YXJ0IGEgY3JvcCBpbiB0aGUgdGlsZXNldCBpbWFnZVxyXG4gICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcclxuICAgIGxldCB0b3AgPSByb3cgKiBoZWlnaHQ7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBWZWMyKGxlZnQsIHRvcCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBzdGFydCBpbmRleFxyXG4gICAqIEByZXR1cm5zIFRoZSBzdGFydCBpbmRleFxyXG4gICAqL1xyXG4gIGdldFN0YXJ0SW5kZXgoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXJ0SW5kZXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB0aWxlIHNldFxyXG4gICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSB0aWxlIHNpemVcclxuICAgKi9cclxuICBnZXRUaWxlU2l6ZSgpOiBWZWMyIHtcclxuICAgIHJldHVybiB0aGlzLnRpbGVTaXplO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRpbGVzZXRcclxuICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHJvd3NcclxuICAgKi9cclxuICBnZXROdW1Sb3dzKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5udW1Sb3dzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRpbHNldFxyXG4gICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY29sdW1uc1xyXG4gICAqL1xyXG4gIGdldE51bUNvbHMoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm51bUNvbHM7XHJcbiAgfVxyXG5cclxuICBnZXRUaWxlQ291bnQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmVuZEluZGV4IC0gdGhpcy5zdGFydEluZGV4ICsgMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRpbHNldCBjb250YWlucyB0aGUgc3BlY2lmaWVkIHRpbGUgaW5kZXguIFRoaXMgaXMgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIHRvIGNoZWNrXHJcbiAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRpbHNldCB1c2VzIHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuICAgKi9cclxuICBoYXNUaWxlKHRpbGVJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGlsZUluZGV4ID49IHRoaXMuc3RhcnRJbmRleCAmJiB0aWxlSW5kZXggPD0gdGhpcy5lbmRJbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlciBhIHNpbmd1bGFyIHRpbGUgd2l0aCBpbmRleCB0aWxlSW5kZXggZnJvbSB0aGUgdGlsZXNldCBsb2NhdGVkIGF0IHBvc2l0aW9uIGRhdGFJbmRleFxyXG4gICAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgdmFsdWUgb2YgdGhlIHRpbGUgdG8gcmVuZGVyXHJcbiAgICogQHBhcmFtIGRhdGFJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIGRhdGEgYXJyYXlcclxuICAgKiBAcGFyYW0gd29ybGRTaXplIFRoZSBzaXplIG9mIHRoZSB3b3JsZFxyXG4gICAqIEBwYXJhbSBvcmlnaW4gVGhlIHZpZXdwb3J0IG9yaWdpbiBpbiB0aGUgY3VycmVudCBsYXllclxyXG4gICAqIEBwYXJhbSBzY2FsZSBUaGUgc2NhbGUgb2YgdGhlIHRpbGVtYXBcclxuICAgKi9cclxuICByZW5kZXJUaWxlKFxyXG4gICAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXHJcbiAgICB0aWxlSW5kZXg6IG51bWJlcixcclxuICAgIGRhdGFJbmRleDogbnVtYmVyLFxyXG4gICAgbWF4Q29sczogbnVtYmVyLFxyXG4gICAgb3JpZ2luOiBWZWMyLFxyXG4gICAgc2NhbGU6IFZlYzIsXHJcbiAgICB6b29tOiBudW1iZXIsXHJcbiAgKTogdm9pZCB7XHJcbiAgICBsZXQgaW1hZ2UgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRJbWFnZSh0aGlzLmltYWdlS2V5KTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIHRydWUgaW5kZXhcclxuICAgIGxldCBpbmRleCA9IHRpbGVJbmRleCAtIHRoaXMuc3RhcnRJbmRleDtcclxuICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKTtcclxuICAgIGxldCBjb2wgPSBpbmRleCAlIHRoaXMubnVtQ29scztcclxuICAgIGxldCB3aWR0aCA9IHRoaXMudGlsZVNpemUueDtcclxuICAgIGxldCBoZWlnaHQgPSB0aGlzLnRpbGVTaXplLnk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcclxuICAgIGxldCBsZWZ0ID0gY29sICogd2lkdGg7XHJcbiAgICBsZXQgdG9wID0gcm93ICogaGVpZ2h0O1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gaW4gdGhlIHdvcmxkIHRvIHJlbmRlciB0aGUgdGlsZVxyXG4gICAgbGV0IHggPSBNYXRoLmZsb29yKChkYXRhSW5kZXggJSBtYXhDb2xzKSAqIHdpZHRoICogc2NhbGUueCk7XHJcbiAgICBsZXQgeSA9IE1hdGguZmxvb3IoTWF0aC5mbG9vcihkYXRhSW5kZXggLyBtYXhDb2xzKSAqIGhlaWdodCAqIHNjYWxlLnkpO1xyXG4gICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgaW1hZ2UsXHJcbiAgICAgIGxlZnQsXHJcbiAgICAgIHRvcCxcclxuICAgICAgd2lkdGgsXHJcbiAgICAgIGhlaWdodCxcclxuICAgICAgTWF0aC5mbG9vcigoeCAtIG9yaWdpbi54KSAqIHpvb20pLFxyXG4gICAgICBNYXRoLmZsb29yKCh5IC0gb3JpZ2luLnkpICogem9vbSksXHJcbiAgICAgIE1hdGguY2VpbCh3aWR0aCAqIHNjYWxlLnggKiB6b29tKSxcclxuICAgICAgTWF0aC5jZWlsKGhlaWdodCAqIHNjYWxlLnkgKiB6b29tKSxcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5cclxuLyoqXHJcbiAqIEEgdHdvLWRpbWVuc2lvbmFsIHZlY3RvciAoeCwgeSlcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlYzIge1xyXG4gIC8vIFN0b3JlIHggYW5kIHkgaW4gYW4gYXJyYXlcclxuICAvKiogVGhlIGFycmF5IHRoYXQgc3RvcmVzIHRoZSBhY3R1YWwgdmVjdG9yIHZhbHVlcyB4IGFuZCB5ICovXHJcbiAgcHJpdmF0ZSB2ZWM6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiB0aGlzIHZlY3RvciBjaGFuZ2VzIGl0cyB2YWx1ZSwgZG8gc29tZXRoaW5nXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBvbkNoYW5nZTogRnVuY3Rpb24gPSAoKSA9PiB7fTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBWZWMyXHJcbiAgICogQHBhcmFtIHggVGhlIHggdmFsdWUgb2YgdGhlIHZlY3RvclxyXG4gICAqIEBwYXJhbSB5IFRoZSB5IHZhbHVlIG9mIHRoZSB2ZWN0b3JcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih4OiBudW1iZXIgPSAwLCB5OiBudW1iZXIgPSAwKSB7XHJcbiAgICB0aGlzLnZlYyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICB0aGlzLnZlY1swXSA9IHg7XHJcbiAgICB0aGlzLnZlY1sxXSA9IHk7XHJcbiAgfVxyXG5cclxuICAvLyBFeHBvc2UgeCBhbmQgeSB3aXRoIGdldHRlcnMgYW5kIHNldHRlcnNcclxuICBnZXQgeCgpIHtcclxuICAgIHJldHVybiB0aGlzLnZlY1swXTtcclxuICB9XHJcblxyXG4gIHNldCB4KHg6IG51bWJlcikge1xyXG4gICAgdGhpcy52ZWNbMF0gPSB4O1xyXG5cclxuICAgIGlmICh0aGlzLm9uQ2hhbmdlKSB7XHJcbiAgICAgIHRoaXMub25DaGFuZ2UoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCB5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmVjWzFdO1xyXG4gIH1cclxuXHJcbiAgc2V0IHkoeTogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnZlY1sxXSA9IHk7XHJcblxyXG4gICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcclxuICAgICAgdGhpcy5vbkNoYW5nZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldCBaRVJPKCkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMyKDAsIDApO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHJlYWRvbmx5IFpFUk9fU1RBVElDID0gbmV3IFZlYzIoMCwgMCk7XHJcblxyXG4gIHN0YXRpYyBnZXQgSU5GKCkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMyKEluZmluaXR5LCBJbmZpbml0eSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0IFVQKCkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMyKDAsIC0xKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXQgRE9XTigpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMigwLCAxKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXQgTEVGVCgpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMigtMSwgMCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0IFJJR0hUKCkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMyKDEsIDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHNxdWFyZWQgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuIFRoaXMgdGVuZHMgdG8gYmUgZmFzdGVyLCBzbyB1c2UgaXQgaW4gc2l0dWF0aW9ucyB3aGVyZSB0YWtpbmcgdGhlXHJcbiAgICogc3F1YXJlIHJvb3QgZG9lc24ndCBtYXR0ZXIsIGxpa2UgZm9yIGNvbXBhcmluZyBkaXN0YW5jZXMuXHJcbiAgICogQHJldHVybnMgVGhlIHNxdWFyZWQgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3JcclxuICAgKi9cclxuICBtYWdTcSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci5cclxuICAgKiBAcmV0dXJucyBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuXHJcbiAgICovXHJcbiAgbWFnKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubWFnU3EoKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXZkZXMgeCBhbmQgeSBieSB0aGUgbWFnbml0dWRlIHRvIG9idGFpbiB0aGUgdW5pdCB2ZWN0b3IgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGlzIHZlY3Rvci5cclxuICAgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhcyBhIHVuaXQgdmVjdG9yLlxyXG4gICAqL1xyXG4gIG5vcm1hbGl6ZSgpOiBWZWMyIHtcclxuICAgIGlmICh0aGlzLnggPT09IDAgJiYgdGhpcy55ID09PSAwKSByZXR1cm4gdGhpcztcclxuICAgIGxldCBtYWcgPSB0aGlzLm1hZygpO1xyXG4gICAgdGhpcy54IC89IG1hZztcclxuICAgIHRoaXMueSAvPSBtYWc7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdvcmtzIGxpa2Ugbm9ybWFsaXplKCksIGJ1dCByZXR1cm5zIGEgbmV3IFZlYzJcclxuICAgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgdGhhdCBpcyB0aGUgdW5pdCB2ZWN0b3IgZm9yIHRoaXMgb25lXHJcbiAgICovXHJcbiAgbm9ybWFsaXplZCgpOiBWZWMyIHtcclxuICAgIGlmICh0aGlzLmlzWmVybygpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBtYWcgPSB0aGlzLm1hZygpO1xyXG4gICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMueCAvIG1hZywgdGhpcy55IC8gbWFnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHggYW5kIHkgZWxlbWVudHMgb2YgdGhpcyB2ZWN0b3IgdG8gemVyby5cclxuICAgKiBAcmV0dXJucyBUaGlzIHZlY3Rvciwgd2l0aCB4IGFuZCB5IHNldCB0byB6ZXJvLlxyXG4gICAqL1xyXG4gIHplcm8oKTogVmVjMiB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXQoMCwgMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB2ZWN0b3IncyB4IGFuZCB5IGJhc2VkIG9uIHRoZSBhbmdsZSBwcm92aWRlZC4gR29lcyBjb3VudGVyIGNsb2Nrd2lzZS5cclxuICAgKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuICAgKiBAcGFyYW0gcmFkaXVzIFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvciBhdCB0aGUgc3BlY2lmaWVkIGFuZ2xlXHJcbiAgICogQHJldHVybnMgVGhpcyB2ZWN0b3IuXHJcbiAgICovXHJcbiAgc2V0VG9BbmdsZShhbmdsZTogbnVtYmVyLCByYWRpdXM6IG51bWJlciA9IDEpOiBWZWMyIHtcclxuICAgIHRoaXMueCA9IE1hdGhVdGlscy5mbG9vclRvUGxhY2UoTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLCA1KTtcclxuICAgIHRoaXMueSA9IE1hdGhVdGlscy5mbG9vclRvUGxhY2UoLU1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cywgNSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSB2ZWN0b3IgdGhhdCBwb2ludCBmcm9tIHRoaXMgdmVjdG9yIHRvIGFub3RoZXIgb25lXHJcbiAgICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gcG9pbnQgdG9cclxuICAgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHRoYXQgcG9pbnRzIGZyb20gdGhpcyB2ZWN0b3IgdG8gdGhlIG9uZSBwcm92aWRlZFxyXG4gICAqL1xyXG4gIHZlY1RvKG90aGVyOiBWZWMyKTogVmVjMiB7XHJcbiAgICByZXR1cm4gbmV3IFZlYzIob3RoZXIueCAtIHRoaXMueCwgb3RoZXIueSAtIHRoaXMueSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIGRpcmVjdGlvbiBmcm9tIHRoaXMgdmVjdG9yIHRvIGFub3RoZXJcclxuICAgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBwb2ludCB0b1xyXG4gICAqIEByZXR1cm5zIEEgbmV3IFZlYzIgdGhhdCBwb2ludHMgZnJvbSB0aGlzIHZlY3RvciB0byB0aGUgb25lIHByb3ZpZGVkLiBUaGlzIG5ldyBWZWMyIHdpbGwgYmUgYSB1bml0IHZlY3Rvci5cclxuICAgKi9cclxuICBkaXJUbyhvdGhlcjogVmVjMik6IFZlYzIge1xyXG4gICAgcmV0dXJuIHRoaXMudmVjVG8ob3RoZXIpLm5vcm1hbGl6ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogS2VlcHMgdGhlIHZlY3RvcidzIGRpcmVjdGlvbiwgYnV0IHNldHMgaXRzIG1hZ25pdHVkZSB0byBiZSB0aGUgcHJvdmlkZWQgbWFnbml0dWRlXHJcbiAgICogQHBhcmFtIG1hZ25pdHVkZSBUaGUgbWFnbml0dWRlIHRoZSB2ZWN0b3Igc2hvdWxkIGJlXHJcbiAgICogQHJldHVybnMgVGhpcyB2ZWN0b3Igd2l0aCBpdHMgbWFnbml0dWRlIHNldCB0byB0aGUgbmV3IG1hZ25pdHVkZVxyXG4gICAqL1xyXG4gIHNjYWxlVG8obWFnbml0dWRlOiBudW1iZXIpOiBWZWMyIHtcclxuICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLnNjYWxlKG1hZ25pdHVkZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY2FsZXMgeCBhbmQgeSBieSB0aGUgbnVtYmVyIHByb3ZpZGVkLCBvciBpZiB0d28gbnVtYmVyIGFyZSBwcm92aWRlZCwgc2NhbGVzIHRoZW0gaW5kaXZpZHVhbGx5LlxyXG4gICAqIEBwYXJhbSBmYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgdmVjdG9yLCBvciBmb3Igb25seSB0aGUgeC1jb21wb25lbnQgaWYgeUZhY3RvciBpcyBwcm92aWRlZFxyXG4gICAqIEBwYXJhbSB5RmFjdG9yIFRoZSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIHktY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcclxuICAgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBzY2FsaW5nXHJcbiAgICovXHJcbiAgc2NhbGUoZmFjdG9yOiBudW1iZXIsIHlGYWN0b3I6IG51bWJlciA9IG51bGwpOiBWZWMyIHtcclxuICAgIGlmICh5RmFjdG9yICE9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMueCAqPSBmYWN0b3I7XHJcbiAgICAgIHRoaXMueSAqPSB5RmFjdG9yO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHRoaXMueCAqPSBmYWN0b3I7XHJcbiAgICB0aGlzLnkgKj0gZmFjdG9yO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgc2NhbGVkIHZlcnNpb24gb2YgdGhpcyB2ZWN0b3Igd2l0aG91dCBtb2RpZnlpbmcgaXQuXHJcbiAgICogQHBhcmFtIGZhY3RvciBUaGUgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSB2ZWN0b3IsIG9yIGZvciBvbmx5IHRoZSB4LWNvbXBvbmVudCBpZiB5RmFjdG9yIGlzIHByb3ZpZGVkXHJcbiAgICogQHBhcmFtIHlGYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgeS1jb21wb25lbnQgb2YgdGhlIHZlY3RvclxyXG4gICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB0aGF0IGhhcyB0aGUgdmFsdWVzIG9mIHRoaXMgdmVjdG9yIGFmdGVyIHNjYWxpbmdcclxuICAgKi9cclxuICBzY2FsZWQoZmFjdG9yOiBudW1iZXIsIHlGYWN0b3I6IG51bWJlciA9IG51bGwpOiBWZWMyIHtcclxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuc2NhbGUoZmFjdG9yLCB5RmFjdG9yKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJvdGF0ZXMgdGhlIHZlY3RvciBjb3VudGVyLWNsb2Nrd2lzZSBieSB0aGUgYW5nbGUgYW1vdW50IHNwZWNpZmllZFxyXG4gICAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5IGluIHJhZGlhbnNcclxuICAgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciByb3RhdGlvbi5cclxuICAgKi9cclxuICByb3RhdGVDQ1coYW5nbGU6IG51bWJlcik6IFZlYzIge1xyXG4gICAgbGV0IGNzID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgbGV0IHNuID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgbGV0IHRlbXBYID0gdGhpcy54ICogY3MgLSB0aGlzLnkgKiBzbjtcclxuICAgIGxldCB0ZW1wWSA9IHRoaXMueCAqIHNuICsgdGhpcy55ICogY3M7XHJcbiAgICB0aGlzLnggPSB0ZW1wWDtcclxuICAgIHRoaXMueSA9IHRlbXBZO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB2ZWN0b3JzIGNvb3JkaW5hdGVzIHRvIGJlIHRoZSBvbmVzIHByb3ZpZGVkXHJcbiAgICogQHBhcmFtIHggVGhlIG5ldyB4IHZhbHVlIGZvciB0aGlzIHZlY3RvclxyXG4gICAqIEBwYXJhbSB5IFRoZSBuZXcgeSB2YWx1ZSBmb3IgdGhpcyB2ZWN0b3JcclxuICAgKiBAcmV0dXJucyBUaGlzIHZlY3RvclxyXG4gICAqL1xyXG4gIHNldCh4OiBudW1iZXIsIHk6IG51bWJlcik6IFZlYzIge1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBvdGhlciBWZWMyIGludG8gdGhpcyBvbmUuXHJcbiAgICogQHBhcmFtIG90aGVyIFRoZSBWZWMyIHRvIGNvcHlcclxuICAgKiBAcmV0dXJucyBUaGlzIHZlY3RvciB3aXRoIGl0cyB2YWx1ZXMgc2V0IHRvIHRoZSB2ZWN0b3IgcHJvdmlkZWRcclxuICAgKi9cclxuICBjb3B5KG90aGVyOiBWZWMyKTogVmVjMiB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXQob3RoZXIueCwgb3RoZXIueSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHRoaXMgdmVjdG9yIHRoZSBhbm90aGVyIHZlY3RvclxyXG4gICAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBhZGQgdG8gdGhpcyBvbmVcclxuICAgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBhZGRpbmcgdGhlIG9uZSBwcm92aWRlZFxyXG4gICAqL1xyXG4gIGFkZChvdGhlcjogVmVjMik6IFZlYzIge1xyXG4gICAgdGhpcy54ICs9IG90aGVyLng7XHJcbiAgICB0aGlzLnkgKz0gb3RoZXIueTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5jcmVtZW50cyB0aGUgZmllbGRzIG9mIHRoaXMgdmVjdG9yLiBCb3RoIGFyZSBpbmNyZW1lbnRlZCB3aXRoIGEsIGlmIG9ubHkgYSBpcyBwcm92aWRlZC5cclxuICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgbnVtYmVyIHRvIGluY3JlbWVudCBieVxyXG4gICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIGluY3JlbWVudCBieVxyXG4gICAqIEByZXR1cm5zcyBUaGlzIHZlY3RvciBhZnRlciBpbmNyZW1lbnRpbmdcclxuICAgKi9cclxuICBpbmMoYTogbnVtYmVyLCBiPzogbnVtYmVyKTogVmVjMiB7XHJcbiAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMueCArPSBhO1xyXG4gICAgICB0aGlzLnkgKz0gYTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMueCArPSBhO1xyXG4gICAgICB0aGlzLnkgKz0gYjtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3VidHJhY3RzIGFub3RoZXIgdmVjdG9yIGZyb20gdGhpcyB2ZWN0b3JcclxuICAgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gc3VidHJhY3QgZnJvbSB0aGlzIG9uZVxyXG4gICAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIHN1YnRyYWN0aW5nIHRoZSBvbmUgcHJvdmlkZWRcclxuICAgKi9cclxuICBzdWIob3RoZXI6IFZlYzIpOiBWZWMyIHtcclxuICAgIHRoaXMueCAtPSBvdGhlci54O1xyXG4gICAgdGhpcy55IC09IG90aGVyLnk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE11bHRpcGxpZXMgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBlbGVtZW50LXdpc2UuIEluIG90aGVyIHdvcmRzLCB0aGlzLnggKj0gb3RoZXIueCBhbmQgdGhpcy55ICo9IG90aGVyLnlcclxuICAgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gbXVsdGlwbHkgdGhpcyBvbmUgYnlcclxuICAgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBtdWx0aXBseWluZyBpdHMgY29tcG9uZW50cyBieSB0aGlzIG9uZVxyXG4gICAqL1xyXG4gIG11bHQob3RoZXI6IFZlYzIpOiBWZWMyIHtcclxuICAgIHRoaXMueCAqPSBvdGhlci54O1xyXG4gICAgdGhpcy55ICo9IG90aGVyLnk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpdmlkZXMgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBlbGVtZW50LXdpc2UuIEluIG90aGVyIHdvcmRzLCB0aGlzLnggLz0gb3RoZXIueCBhbmQgdGhpcy55IC89IG90aGVyLnlcclxuICAgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBkaXZpZGUgdGhpcyBvbmUgYnlcclxuICAgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBkaXZpc2lvblxyXG4gICAqL1xyXG4gIGRpdihvdGhlcjogVmVjMik6IFZlYzIge1xyXG4gICAgaWYgKG90aGVyLnggPT09IDAgfHwgb3RoZXIueSA9PT0gMCkgdGhyb3cgXCJEaXZpZGUgYnkgemVybyBlcnJvclwiO1xyXG4gICAgdGhpcy54IC89IG90aGVyLng7XHJcbiAgICB0aGlzLnkgLz0gb3RoZXIueTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRG9lcyBhbiBlbGVtZW50IHdpc2UgcmVtYWluZGVyIG9wZXJhdGlvbiBvbiB0aGlzIHZlY3Rvci4gdGhpcy54ICU9IG90aGVyLnggYW5kIHRoaXMueSAlPSBvdGhlci55XHJcbiAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciB2ZWN0b3JcclxuICAgKiBAcmV0dXJucyB0aGlzIHZlY3RvclxyXG4gICAqL1xyXG4gIHJlbWFpbmRlcihvdGhlcjogVmVjMik6IFZlYzIge1xyXG4gICAgdGhpcy54ID0gdGhpcy54ICUgb3RoZXIueDtcclxuICAgIHRoaXMueSA9IHRoaXMueSAlIG90aGVyLnk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlciB2ZWN0b3JcclxuICAgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIGRpc3RhbmNlIHNxdWFyZWQgdG9cclxuICAgKiBAcmV0dXJucyBUaGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCB0aGUgb25lIHByb3ZpZGVkXHJcbiAgICovXHJcbiAgZGlzdGFuY2VTcVRvKG90aGVyOiBWZWMyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICh0aGlzLnggLSBvdGhlci54KSAqICh0aGlzLnggLSBvdGhlci54KSArXHJcbiAgICAgICh0aGlzLnkgLSBvdGhlci55KSAqICh0aGlzLnkgLSBvdGhlci55KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yXHJcbiAgICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSBkaXN0YW5jZSB0b1xyXG4gICAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCB0aGUgb25lIHByb3ZpZGVkXHJcbiAgICovXHJcbiAgZGlzdGFuY2VUbyhvdGhlcjogVmVjMik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvKG90aGVyKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlclxyXG4gICAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgdGhlIGRvdCBwcm9kdWN0IHdpdGhcclxuICAgKiBAcmV0dXJucyBUaGUgZG90IHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3IgYW5kIHRoZSBvbmUgcHJvdmlkZWQuXHJcbiAgICovXHJcbiAgZG90KG90aGVyOiBWZWMyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLnggKiBvdGhlci54ICsgdGhpcy55ICogb3RoZXIueTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGFuZ2xlIGNvdW50ZXItY2xvY2t3aXNlIGluIHJhZGlhbnMgZnJvbSB0aGlzIHZlY3RvciB0byBhbm90aGVyIHZlY3RvclxyXG4gICAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgdGhlIGFuZ2xlIHRvXHJcbiAgICogQHJldHVybnMgVGhlIGFuZ2xlLCByb3RhdGluZyBDQ1csIGZyb20gdGhpcyB2ZWN0b3IgdG8gdGhlIG90aGVyIHZlY3RvclxyXG4gICAqL1xyXG4gIGFuZ2xlVG9DQ1cob3RoZXI6IFZlYzIpOiBudW1iZXIge1xyXG4gICAgbGV0IGRvdCA9IHRoaXMuZG90KG90aGVyKTtcclxuICAgIGxldCBkZXQgPSB0aGlzLnggKiBvdGhlci55IC0gdGhpcy55ICogb3RoZXIueDtcclxuICAgIGxldCBhbmdsZSA9IC1NYXRoLmF0YW4yKGRldCwgZG90KTtcclxuXHJcbiAgICBpZiAoYW5nbGUgPCAwKSB7XHJcbiAgICAgIGFuZ2xlICs9IDIgKiBNYXRoLlBJO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhbmdsZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3Igcm91bmRlZCB0byAxIGRlY2ltYWwgcG9pbnRcclxuICAgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhcyBhIHN0cmluZ1xyXG4gICAqL1xyXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy50b0ZpeGVkKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHNcclxuICAgKiBAcGFyYW0gbnVtRGVjaW1hbFBvaW50cyBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIGNyZWF0ZSBhIHN0cmluZyB0b1xyXG4gICAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFzIGEgc3RyaW5nXHJcbiAgICovXHJcbiAgdG9GaXhlZChudW1EZWNpbWFsUG9pbnRzOiBudW1iZXIgPSAxKTogc3RyaW5nIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIFwiKFwiICtcclxuICAgICAgdGhpcy54LnRvRml4ZWQobnVtRGVjaW1hbFBvaW50cykgK1xyXG4gICAgICBcIiwgXCIgK1xyXG4gICAgICB0aGlzLnkudG9GaXhlZChudW1EZWNpbWFsUG9pbnRzKSArXHJcbiAgICAgIFwiKVwiXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG5ldyB2ZWN0b3Igd2l0aCB0aGUgc2FtZSBjb29yZGluYXRlcyBhcyB0aGlzIG9uZS5cclxuICAgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lXHJcbiAgICovXHJcbiAgY2xvbmUoKTogVmVjMiB7XHJcbiAgICByZXR1cm4gbmV3IFZlYzIodGhpcy54LCB0aGlzLnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmVjdG9yIGFuZCBvdGhlciBoYXZlIHRoZSBFWEFDVCBzYW1lIHggYW5kIHkgKG5vdCBhc3N1cmVkIHRvIGJlIHNhZmUgZm9yIGZsb2F0cylcclxuICAgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjaGVjayBhZ2FpbnN0XHJcbiAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgZXF1YWxpdHkgb2YgdGhlIHR3byB2ZWN0b3JzXHJcbiAgICovXHJcbiAgc3RyaWN0RXF1YWxzKG90aGVyOiBWZWMyKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmIHRoaXMueSA9PT0gb3RoZXIueTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHZlY3RvciBhbmQgb3RoZXIgaGF2ZSB0aGUgc2FtZSB4IGFuZCB5XHJcbiAgICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY2hlY2sgYWdhaW5zdFxyXG4gICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoZSB0d28gdmVjdG9yc1xyXG4gICAqL1xyXG4gIGVxdWFscyhvdGhlcjogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgbGV0IHhFcSA9IE1hdGguYWJzKHRoaXMueCAtIG90aGVyLngpIDwgMC4wMDAwMDAxO1xyXG4gICAgbGV0IHlFcSA9IE1hdGguYWJzKHRoaXMueSAtIG90aGVyLnkpIDwgMC4wMDAwMDAxO1xyXG5cclxuICAgIHJldHVybiB4RXEgJiYgeUVxO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmVjdG9yIGlzIHRoZSB6ZXJvIHZlY3RvciBleGFjdGx5IChub3QgYXNzdXJlZCB0byBiZSBzYWZlIGZvciBmbG9hdHMpLlxyXG4gICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoaXMgdmVjdG9yIGFuZCB0aGUgemVybyB2ZWN0b3JcclxuICAgKi9cclxuICBzdHJpY3RJc1plcm8oKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHggYW5kIHkgZm9yIHRoaXMgdmVjdG9yIGFyZSBib3RoIHplcm8uXHJcbiAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgZXF1YWxpdHkgb2YgdGhpcyB2ZWN0b3IgYW5kIHRoZSB6ZXJvIHZlY3RvclxyXG4gICAqL1xyXG4gIGlzWmVybygpOiBib29sZWFuIHtcclxuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLngpIDwgMC4wMDAwMDAxICYmIE1hdGguYWJzKHRoaXMueSkgPCAwLjAwMDAwMDE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciB0aGlzIHZlY3RvciBpcyBjaGFuZ2VkLlxyXG4gICAqIEBwYXJhbSBmIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICAgKi9cclxuICBzZXRPbkNoYW5nZShmOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgdGhpcy5vbkNoYW5nZSA9IGY7XHJcbiAgfVxyXG5cclxuICB0b0FycmF5KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICByZXR1cm4gdGhpcy52ZWM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQZXJmb3JtcyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWN0b3JzXHJcbiAgICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3RvclxyXG4gICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yXHJcbiAgICogQHBhcmFtIHQgVGhlIHRpbWUgb2YgdGhlIGxlcnAsIHdpdGggMCBiZWluZyB2ZWN0b3IgQSwgYW5kIDEgYmVpbmcgdmVjdG9yIEJcclxuICAgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHJlcHJlc2VudGluZyB0aGUgbGVycCBiZXR3ZWVuIHZlY3RvciBhIGFuZCBiLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBsZXJwKGE6IFZlYzIsIGI6IFZlYzIsIHQ6IG51bWJlcik6IFZlYzIge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMyKE1hdGhVdGlscy5sZXJwKGEueCwgYi54LCB0KSwgTWF0aFV0aWxzLmxlcnAoYS55LCBiLnksIHQpKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vKipcclxuICogQSB1dGlsIGNsYXNzIGZvciByZW5kZXJpbmcgRGVidWcuanNvbiBtZXNzYWdlcyB0byB0aGUgY2FudmFzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVidWcge1xyXG4gIC8qKiBBIG1hcCBvZiBsb2cgbWVzc2FnZXMgdG8gZGlzcGxheSBvbiB0aGUgc2NyZWVuICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgbG9nTWVzc2FnZXM6IE1hcDxzdHJpbmc+ID0gbmV3IE1hcCgpO1xyXG5cclxuICAvKiogQW4gYXJyYXkgb2YgZ2FtZSBub2RlcyB0byByZW5kZXIgZGVidWcgaW5mbyBmb3IgKi9cclxuICBwcml2YXRlIHN0YXRpYyBub2RlczogQXJyYXk8R2FtZU5vZGU+O1xyXG5cclxuICAvKiogVGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciBhbnkgZGVidWcgbWVzc2FnZXMgKi9cclxuICBwcml2YXRlIHN0YXRpYyBkZWJ1Z1JlbmRlcmluZ0NvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuXHJcbiAgLyoqXHRUaGUgc2l6ZSBvZiB0aGUgZGVidWcgY2FudmFzICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZGVidWdDYW52YXNTaXplOiBWZWMyO1xyXG5cclxuICAvKiogVGhlIHJlbmRlcmluZyBjb2xvciBmb3IgdGV4dCAqL1xyXG4gIHByaXZhdGUgc3RhdGljIGRlZmF1bHRUZXh0Q29sb3I6IENvbG9yID0gQ29sb3IuV0hJVEU7XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIG1lc3NhZ2UgdG8gZGlzcGxheSBvbiB0aGUgZGVidWcgc2NyZWVuXHJcbiAgICogQHBhcmFtIGlkIEEgdW5pcXVlIElEIGZvciB0aGlzIG1lc3NhZ2VcclxuICAgKiBAcGFyYW0gbWVzc2FnZXMgVGhlIG1lc3NhZ2VzIHRvIHByaW50IHRvIHRoZSBkZWJ1ZyBzY3JlZW5cclxuICAgKi9cclxuICBzdGF0aWMgbG9nKGlkOiBzdHJpbmcsIC4uLm1lc3NhZ2VzOiBhbnkpOiB2b2lkIHtcclxuICAgIC8vIGxldCBtZXNzYWdlID0gXCJcIjtcclxuICAgIC8vIGZvcihsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAvLyBcdG1lc3NhZ2UgKz0gbWVzc2FnZXNbaV0udG9TdHJpbmcoKTtcclxuICAgIC8vIH1cclxuICAgIC8vIEpvaW4gYWxsIG1lc3NhZ2VzIHdpdGggc3BhY2VzXHJcbiAgICBsZXQgbWVzc2FnZSA9IG1lc3NhZ2VzLm1hcCgobTogYW55KSA9PiBtLnRvU3RyaW5nKCkpLmpvaW4oXCIgXCIpO1xyXG4gICAgdGhpcy5sb2dNZXNzYWdlcy5hZGQoaWQsIG1lc3NhZ2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlcyBhIGEga2V5IGZyb20gdGhlIGxvZyBhbmQgc3RvcHMgaXQgZnJvbSBrZWVwaW5nIHVwIHNwYWNlIG9uIHRoZSBzY3JlZW5cclxuICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBsb2cgaXRlbSB0byBjbGVhclxyXG4gICAqL1xyXG4gIHN0YXRpYyBjbGVhckxvZ0l0ZW0oaWQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdGhpcy5sb2dNZXNzYWdlcy5kZWxldGUoaWQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgbGlzdCBvZiBub2RlcyB0byByZW5kZXIgd2l0aCB0aGUgZGVidWdnZXJcclxuICAgKiBAcGFyYW0gbm9kZXMgVGhlIG5ldyBsaXN0IG9mIG5vZGVzXHJcbiAgICovXHJcbiAgc3RhdGljIHNldE5vZGVzKG5vZGVzOiBBcnJheTxHYW1lTm9kZT4pOiB2b2lkIHtcclxuICAgIHRoaXMubm9kZXMgPSBub2RlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYXdzIGEgYm94IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cclxuICAgKiBAcGFyYW0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIGJveFxyXG4gICAqIEBwYXJhbSBoYWxmU2l6ZSBUaGUgZGltZW5zaW9ucyBvZiB0aGUgYm94XHJcbiAgICogQHBhcmFtIGZpbGxlZCBBIGJvb2xlYW4gZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBib3ggaXMgZmlsbGVkXHJcbiAgICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgYm94IHRvIGRyYXdcclxuICAgKi9cclxuICBzdGF0aWMgZHJhd0JveChcclxuICAgIGNlbnRlcjogVmVjMixcclxuICAgIGhhbGZTaXplOiBWZWMyLFxyXG4gICAgZmlsbGVkOiBib29sZWFuLFxyXG4gICAgY29sb3I6IENvbG9yLFxyXG4gICk6IHZvaWQge1xyXG4gICAgbGV0IGFscGhhID0gdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGE7XHJcbiAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGNvbG9yLmE7XHJcblxyXG4gICAgaWYgKGZpbGxlZCkge1xyXG4gICAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsUmVjdChcclxuICAgICAgICBjZW50ZXIueCAtIGhhbGZTaXplLngsXHJcbiAgICAgICAgY2VudGVyLnkgLSBoYWxmU2l6ZS55LFxyXG4gICAgICAgIGhhbGZTaXplLnggKiAyLFxyXG4gICAgICAgIGhhbGZTaXplLnkgKiAyLFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IGxpbmVXaWR0aCA9IDI7XHJcbiAgICAgIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcclxuICAgICAgdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VSZWN0KFxyXG4gICAgICAgIGNlbnRlci54IC0gaGFsZlNpemUueCxcclxuICAgICAgICBjZW50ZXIueSAtIGhhbGZTaXplLnksXHJcbiAgICAgICAgaGFsZlNpemUueCAqIDIsXHJcbiAgICAgICAgaGFsZlNpemUueSAqIDIsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYXdzIGEgY2lyY2xlIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cclxuICAgKiBAcGFyYW0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxyXG4gICAqIEBwYXJhbSByYWRpdXMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGJveFxyXG4gICAqIEBwYXJhbSBmaWxsZWQgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB0aGUgY2lyY2xlIGlzIGZpbGxlZFxyXG4gICAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIGNpcmNsZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBkcmF3Q2lyY2xlKFxyXG4gICAgY2VudGVyOiBWZWMyLFxyXG4gICAgcmFkaXVzOiBudW1iZXIsXHJcbiAgICBmaWxsZWQ6IGJvb2xlYW4sXHJcbiAgICBjb2xvcjogQ29sb3IsXHJcbiAgKTogdm9pZCB7XHJcbiAgICBsZXQgYWxwaGEgPSB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYTtcclxuICAgIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhID0gY29sb3IuYTtcclxuXHJcbiAgICBpZiAoZmlsbGVkKSB7XHJcbiAgICAgIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5hcmMoXHJcbiAgICAgICAgY2VudGVyLngsXHJcbiAgICAgICAgY2VudGVyLnksXHJcbiAgICAgICAgcmFkaXVzLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMiAqIE1hdGguUEksXHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgbGluZVdpZHRoID0gMjtcclxuICAgICAgdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xyXG4gICAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5hcmMoXHJcbiAgICAgICAgY2VudGVyLngsXHJcbiAgICAgICAgY2VudGVyLnksXHJcbiAgICAgICAgcmFkaXVzLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMiAqIE1hdGguUEksXHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2UoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhd3MgYSByYXkgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSBmcm9tIFRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiB0aGUgcmF5XHJcbiAgICogQHBhcmFtIHRvIFRoZSBlbmRpbmcgcG9zaXRpb24gb2YgdGhlIHJheVxyXG4gICAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIHJheVxyXG4gICAqL1xyXG4gIHN0YXRpYyBkcmF3UmF5KGZyb206IFZlYzIsIHRvOiBWZWMyLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuICAgIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmxpbmVXaWR0aCA9IDI7XHJcbiAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5tb3ZlVG8oZnJvbS54LCBmcm9tLnkpO1xyXG4gICAgdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVRvKHRvLngsIHRvLnkpO1xyXG4gICAgdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2UoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYXdzIGEgcG9pbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSBwb3MgVGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludFxyXG4gICAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIHBvaW50XHJcbiAgICovXHJcbiAgc3RhdGljIGRyYXdQb2ludChwb3M6IFZlYzIsIGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG4gICAgbGV0IHBvaW50U2l6ZSA9IDY7XHJcbiAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFJlY3QoXHJcbiAgICAgIHBvcy54IC0gcG9pbnRTaXplIC8gMixcclxuICAgICAgcG9zLnkgLSBwb2ludFNpemUgLyAyLFxyXG4gICAgICBwb2ludFNpemUsXHJcbiAgICAgIHBvaW50U2l6ZSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBkZWZhdWx0IHJlbmRlcmluZyBjb2xvciBmb3IgdGV4dCBmb3IgdGhlIGRlYnVnZ2VyXHJcbiAgICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciB0byByZW5kZXIgdGhlIHRleHRcclxuICAgKi9cclxuICBzdGF0aWMgc2V0RGVmYXVsdFRleHRDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuICAgIHRoaXMuZGVmYXVsdFRleHRDb2xvciA9IGNvbG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGVyZm9ybXMgYW55IG5lY2Vzc2FyeSBzZXR1cCBvcGVyYXRpb25zIG9uIHRoZSBEZWJ1Zy5qc29uIGNhbnZhc1xyXG4gICAqIEBwYXJhbSBjYW52YXMgVGhlIGRlYnVnIGNhbnZhc1xyXG4gICAqIEBwYXJhbSB3aWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgY2FudmFzXHJcbiAgICogQHBhcmFtIGhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIGNhbnZhc1xyXG4gICAqIEByZXR1cm5zIFRoZSByZW5kZXJpbmcgY29udGV4dCBleHRyYWN0ZWQgZnJvbSB0aGUgY2FudmFzXHJcbiAgICovXHJcbiAgc3RhdGljIGluaXRpYWxpemVEZWJ1Z0NhbnZhcyhcclxuICAgIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXHJcbiAgICB3aWR0aDogbnVtYmVyLFxyXG4gICAgaGVpZ2h0OiBudW1iZXIsXHJcbiAgKTogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHtcclxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICB0aGlzLmRlYnVnQ2FudmFzU2l6ZSA9IG5ldyBWZWMyKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQ7XHJcbiAgfVxyXG5cclxuICAvKiogQ2xlYXJzIHRoZSBkZWJ1ZyBjYW52YXMgKi9cclxuICBzdGF0aWMgY2xlYXJDYW52YXMoKTogdm9pZCB7XHJcbiAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbGVhclJlY3QoXHJcbiAgICAgIDAsXHJcbiAgICAgIDAsXHJcbiAgICAgIHRoaXMuZGVidWdDYW52YXNTaXplLngsXHJcbiAgICAgIHRoaXMuZGVidWdDYW52YXNTaXplLnksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqIFJlbmRlcnMgdGhlIHRleHQgYW5kIG5vZGVzIHNlbnQgdG8gdGhlIERlYnVnLmpzb24gc3lzdGVtICovXHJcbiAgc3RhdGljIHJlbmRlcigpOiB2b2lkIHtcclxuICAgIHRoaXMucmVuZGVyVGV4dCgpO1xyXG4gICAgdGhpcy5yZW5kZXJOb2RlcygpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFJlbmRlcnMgdGhlIHRleHQgc2VudCB0byB0aGUgRGVidWcuanNvbiBjYW52YXMgKi9cclxuICBzdGF0aWMgcmVuZGVyVGV4dCgpOiB2b2lkIHtcclxuICAgIGxldCB5ID0gMjA7XHJcbiAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5mb250ID0gXCIyMHB4IEFyaWFsXCI7XHJcbiAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmRlZmF1bHRUZXh0Q29sb3IudG9TdHJpbmcoKTtcclxuXHJcbiAgICAvLyBEcmF3IGFsbCBvZiB0aGUgdGV4dFxyXG4gICAgdGhpcy5sb2dNZXNzYWdlcy5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4ge1xyXG4gICAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsVGV4dCh0aGlzLmxvZ01lc3NhZ2VzLmdldChrZXkpLCAxMCwgeSk7XHJcbiAgICAgIHkgKz0gMzA7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBSZW5kZXJzIHRoZSBub2RlcyByZWdpc3RlcmVkIHdpdGggdGhlIGRlYnVnIGNhbnZhcyAqL1xyXG4gIHN0YXRpYyByZW5kZXJOb2RlcygpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLm5vZGVzKSB7XHJcbiAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICBub2RlLmRlYnVnUmVuZGVyKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vLyBAaWdub3JlUGFnZVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0cyBleHRlbmRzIE9iamVjdCB7XHJcbiAgLy8gVGhlIGZwcyBvZiB0aGUgZ2FtZS5cclxuICBwcml2YXRlIHN0YXRpYyBwcmV2ZnBzOiBBcnJheTxudW1iZXI+O1xyXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE5VTV9QT0lOVFM6IG51bWJlciA9IDYwO1xyXG4gIHByaXZhdGUgc3RhdGljIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG4gIHByaXZhdGUgc3RhdGljIENBTlZBU19XSURUSDogbnVtYmVyID0gMzAwO1xyXG4gIHByaXZhdGUgc3RhdGljIENBTlZBU19IRUlHSFQ6IG51bWJlciA9IDMwMDtcclxuICBwcml2YXRlIHN0YXRpYyBzdGF0c0RpdjogSFRNTERpdkVsZW1lbnQ7XHJcbiAgcHJpdmF0ZSBzdGF0aWMgZ3JhcGhDaG9pY2VzOiBIVE1MU2VsZWN0RWxlbWVudDtcclxuXHJcbiAgLy8gUXVhZHRyZWUgc3RhdHNcclxuICBwcml2YXRlIHN0YXRpYyBwcmV2Q2xlYXJUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICBwcml2YXRlIHN0YXRpYyBTR0NsZWFyVGltZXM6IEFycmF5PG51bWJlcj47XHJcbiAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dDbGVhclRpbWU6IG51bWJlcjtcclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgcHJldkZpbGxUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICBwcml2YXRlIHN0YXRpYyBTR0ZpbGxUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICBwcml2YXRlIHN0YXRpYyBhdmdTR0ZpbGxUaW1lOiBudW1iZXI7XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIHByZXZVcGRhdGVUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICBwcml2YXRlIHN0YXRpYyBTR1VwZGF0ZVRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gIHByaXZhdGUgc3RhdGljIGF2Z1NHVXBkYXRlVGltZTogbnVtYmVyO1xyXG5cclxuICBwcml2YXRlIHN0YXRpYyBwcmV2UXVlcnlUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICBwcml2YXRlIHN0YXRpYyBTR1F1ZXJ5VGltZXM6IEFycmF5PG51bWJlcj47XHJcbiAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dRdWVyeVRpbWU6IG51bWJlcjtcclxuXHJcbiAgc3RhdGljIGluaXRTdGF0cygpOiB2b2lkIHtcclxuICAgIGxldCBjYW52YXMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0cy1jYW52YXNcIik7XHJcbiAgICBjYW52YXMud2lkdGggPSB0aGlzLkNBTlZBU19XSURUSDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLkNBTlZBU19IRUlHSFQ7XHJcbiAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgdGhpcy5zdGF0c0RpdiA9IDxIVE1MRGl2RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRzLWRpc3BsYXlcIik7XHJcblxyXG4gICAgdGhpcy5wcmV2ZnBzID0gbmV3IEFycmF5KCk7XHJcblxyXG4gICAgdGhpcy5wcmV2Q2xlYXJUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgdGhpcy5TR0NsZWFyVGltZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgIHRoaXMuYXZnU0dDbGVhclRpbWUgPSAwO1xyXG5cclxuICAgIHRoaXMucHJldkZpbGxUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgdGhpcy5TR0ZpbGxUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgdGhpcy5hdmdTR0ZpbGxUaW1lID0gMDtcclxuXHJcbiAgICB0aGlzLnByZXZVcGRhdGVUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgdGhpcy5TR1VwZGF0ZVRpbWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICB0aGlzLmF2Z1NHVXBkYXRlVGltZSA9IDA7XHJcblxyXG4gICAgdGhpcy5wcmV2UXVlcnlUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgdGhpcy5TR1F1ZXJ5VGltZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgIHRoaXMuYXZnU0dRdWVyeVRpbWUgPSAwO1xyXG5cclxuICAgIGxldCBjbGVhclRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgIGNsZWFyVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNnY2xlYXJcIik7XHJcbiAgICBsZXQgZmlsbFRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgIGZpbGxUaW1lLnNldEF0dHJpYnV0ZShcImlkXCIsIFwic2dmaWxsXCIpO1xyXG4gICAgbGV0IHVwZGF0ZVRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgIHVwZGF0ZVRpbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJzZ3VwZGF0ZVwiKTtcclxuICAgIGxldCBxdWVyeVRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgIHF1ZXJ5VGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNncXVlcnlcIik7XHJcbiAgICBsZXQgYnIxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xyXG4gICAgbGV0IGJyMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcclxuICAgIGxldCBicjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XHJcblxyXG4gICAgdGhpcy5zdGF0c0Rpdi5hcHBlbmQoXHJcbiAgICAgIGNsZWFyVGltZSxcclxuICAgICAgYnIxLFxyXG4gICAgICBmaWxsVGltZSxcclxuICAgICAgYnIyLFxyXG4gICAgICB1cGRhdGVUaW1lLFxyXG4gICAgICBicjMsXHJcbiAgICAgIHF1ZXJ5VGltZSxcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5ncmFwaENob2ljZXMgPSA8SFRNTFNlbGVjdEVsZW1lbnQ+KFxyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXJ0LW9wdGlvblwiKVxyXG4gICAgKTtcclxuICAgIGxldCBvcHRpb24xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgIG9wdGlvbjEudmFsdWUgPSBcInByZXZmcHNcIjtcclxuICAgIG9wdGlvbjEubGFiZWwgPSBcIkZQU1wiO1xyXG4gICAgbGV0IG9wdGlvbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xyXG4gICAgb3B0aW9uMi52YWx1ZSA9IFwicHJldkNsZWFyVGltZXNcIjtcclxuICAgIG9wdGlvbjIubGFiZWwgPSBcIkNsZWFyIFRpbWVcIjtcclxuICAgIGxldCBvcHRpb24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgIG9wdGlvbjMudmFsdWUgPSBcInByZXZGaWxsVGltZXNcIjtcclxuICAgIG9wdGlvbjMubGFiZWwgPSBcIkZpbGwgdGltZVwiO1xyXG4gICAgbGV0IG9wdGlvbjQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xyXG4gICAgb3B0aW9uNC52YWx1ZSA9IFwicHJldlVwZGF0ZVRpbWVzXCI7XHJcbiAgICBvcHRpb240LmxhYmVsID0gXCJVcGRhdGUgdGltZVwiO1xyXG4gICAgbGV0IG9wdGlvbjUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xyXG4gICAgb3B0aW9uNS52YWx1ZSA9IFwicHJldlF1ZXJ5VGltZXNcIjtcclxuICAgIG9wdGlvbjUubGFiZWwgPSBcIlF1ZXJ5IFRpbWVcIjtcclxuICAgIGxldCBvcHRpb25BbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xyXG4gICAgb3B0aW9uQWxsLnZhbHVlID0gXCJhbGxcIjtcclxuICAgIG9wdGlvbkFsbC5sYWJlbCA9IFwiQWxsXCI7XHJcbiAgICB0aGlzLmdyYXBoQ2hvaWNlcy5hcHBlbmQoXHJcbiAgICAgIG9wdGlvbjEsXHJcbiAgICAgIG9wdGlvbjIsXHJcbiAgICAgIG9wdGlvbjMsXHJcbiAgICAgIG9wdGlvbjQsXHJcbiAgICAgIG9wdGlvbjUsXHJcbiAgICAgIG9wdGlvbkFsbCxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgdXBkYXRlRlBTKGZwczogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLnByZXZmcHMucHVzaChmcHMpO1xyXG4gICAgaWYgKHRoaXMucHJldmZwcy5sZW5ndGggPiBTdGF0cy5OVU1fUE9JTlRTKSB7XHJcbiAgICAgIHRoaXMucHJldmZwcy5zaGlmdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMucHJldkNsZWFyVGltZXMucHVzaCh0aGlzLmF2Z1NHQ2xlYXJUaW1lKTtcclxuICAgICAgaWYgKHRoaXMucHJldkNsZWFyVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKSB7XHJcbiAgICAgICAgdGhpcy5wcmV2Q2xlYXJUaW1lcy5zaGlmdCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMucHJldkZpbGxUaW1lcy5wdXNoKHRoaXMuYXZnU0dGaWxsVGltZSk7XHJcbiAgICAgIGlmICh0aGlzLnByZXZGaWxsVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKSB7XHJcbiAgICAgICAgdGhpcy5wcmV2RmlsbFRpbWVzLnNoaWZ0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLlNHVXBkYXRlVGltZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLnByZXZVcGRhdGVUaW1lcy5wdXNoKHRoaXMuYXZnU0dVcGRhdGVUaW1lKTtcclxuICAgICAgaWYgKHRoaXMucHJldlVwZGF0ZVRpbWVzLmxlbmd0aCA+IHRoaXMuTlVNX1BPSU5UUykge1xyXG4gICAgICAgIHRoaXMucHJldlVwZGF0ZVRpbWVzLnNoaWZ0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMucHJldlF1ZXJ5VGltZXMucHVzaCh0aGlzLmF2Z1NHUXVlcnlUaW1lKTtcclxuICAgICAgaWYgKHRoaXMucHJldlF1ZXJ5VGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKSB7XHJcbiAgICAgICAgdGhpcy5wcmV2UXVlcnlUaW1lcy5zaGlmdCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy51cGRhdGVTR1N0YXRzKCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgbG9nKGtleTogc3RyaW5nLCBkYXRhOiBhbnkpOiB2b2lkIHtcclxuICAgIGlmIChrZXkgPT09IFwic2djbGVhclwiKSB7XHJcbiAgICAgIHRoaXMuU0dDbGVhclRpbWVzLnB1c2goZGF0YSk7XHJcbiAgICAgIGlmICh0aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGggPiAxMDApIHtcclxuICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcy5zaGlmdCgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzZ2ZpbGxcIikge1xyXG4gICAgICB0aGlzLlNHRmlsbFRpbWVzLnB1c2goZGF0YSk7XHJcbiAgICAgIGlmICh0aGlzLlNHRmlsbFRpbWVzLmxlbmd0aCA+IDEwMCkge1xyXG4gICAgICAgIHRoaXMuU0dGaWxsVGltZXMuc2hpZnQoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2d1cGRhdGVcIikge1xyXG4gICAgICB0aGlzLlNHVXBkYXRlVGltZXMucHVzaChkYXRhKTtcclxuICAgICAgaWYgKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAxMDApIHtcclxuICAgICAgICB0aGlzLlNHVXBkYXRlVGltZXMuc2hpZnQoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2dxdWVyeVwiKSB7XHJcbiAgICAgIHRoaXMuU0dRdWVyeVRpbWVzLnB1c2goZGF0YSk7XHJcbiAgICAgIGlmICh0aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGggPiAxMDAwKSB7XHJcbiAgICAgICAgdGhpcy5TR1F1ZXJ5VGltZXMuc2hpZnQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIHJlbmRlcigpOiB2b2lkIHtcclxuICAgIC8vIERpc3BsYXkgc3RhdHNcclxuICAgIHRoaXMuZHJhd0NoYXJ0cygpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGRyYXdDaGFydHMoKSB7XHJcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5DQU5WQVNfV0lEVEgsIHRoaXMuQ0FOVkFTX0hFSUdIVCk7XHJcblxyXG4gICAgbGV0IHBhcmFtU3RyaW5nID0gdGhpcy5ncmFwaENob2ljZXMudmFsdWU7XHJcblxyXG4gICAgaWYgKHBhcmFtU3RyaW5nID09PSBcInByZXZmcHNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIikge1xyXG4gICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZmcHM7XHJcbiAgICAgIGxldCBjb2xvciA9IENvbG9yLkJMVUUudG9TdHJpbmcoKTtcclxuICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcclxuICAgIH1cclxuICAgIGlmIChwYXJhbVN0cmluZyA9PT0gXCJwcmV2Q2xlYXJUaW1lc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKSB7XHJcbiAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldkNsZWFyVGltZXM7XHJcbiAgICAgIGxldCBjb2xvciA9IENvbG9yLlJFRC50b1N0cmluZygpO1xyXG4gICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcmFtU3RyaW5nID09PSBcInByZXZGaWxsVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIikge1xyXG4gICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZGaWxsVGltZXM7XHJcbiAgICAgIGxldCBjb2xvciA9IENvbG9yLkdSRUVOLnRvU3RyaW5nKCk7XHJcbiAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XHJcbiAgICB9XHJcbiAgICBpZiAocGFyYW1TdHJpbmcgPT09IFwicHJldlVwZGF0ZVRpbWVzXCIgfHwgcGFyYW1TdHJpbmcgPT09IFwiYWxsXCIpIHtcclxuICAgICAgbGV0IHBhcmFtID0gdGhpcy5wcmV2VXBkYXRlVGltZXM7XHJcbiAgICAgIGxldCBjb2xvciA9IENvbG9yLkNZQU4udG9TdHJpbmcoKTtcclxuICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcclxuICAgIH1cclxuICAgIGlmIChwYXJhbVN0cmluZyA9PT0gXCJwcmV2UXVlcnlUaW1lc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKSB7XHJcbiAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldlF1ZXJ5VGltZXM7XHJcbiAgICAgIGxldCBjb2xvciA9IENvbG9yLk9SQU5HRS50b1N0cmluZygpO1xyXG4gICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIGRyYXdDaGFydChwYXJhbTogQXJyYXk8bnVtYmVyPiwgY29sb3I6IHN0cmluZykge1xyXG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBDb2xvci5CTEFDSy50b1N0cmluZygpO1xyXG4gICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICB0aGlzLmN0eC5tb3ZlVG8oMTAsIDEwKTtcclxuICAgIHRoaXMuY3R4LmxpbmVUbygxMCwgdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTApO1xyXG4gICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XHJcbiAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgdGhpcy5jdHgubW92ZVRvKDEwLCB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCk7XHJcbiAgICB0aGlzLmN0eC5saW5lVG8odGhpcy5DQU5WQVNfV0lEVEggLSAxMCwgdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTApO1xyXG4gICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XHJcbiAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuXHJcbiAgICBsZXQgbWF4ID0gTWF0aC5tYXgoLi4ucGFyYW0pO1xyXG4gICAgbGV0IHByZXZYID0gMTA7XHJcbiAgICBsZXQgcHJldlkgPVxyXG4gICAgICB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCAtIChwYXJhbVswXSAvIG1heCkgKiAodGhpcy5DQU5WQVNfSEVJR0hUIC0gMjApO1xyXG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcmFtLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGxldCBmcHMgPSBwYXJhbVtpXTtcclxuICAgICAgbGV0IHggPSAxMCArIChpICogKHRoaXMuQ0FOVkFTX1dJRFRIIC0gMjApKSAvIHRoaXMuTlVNX1BPSU5UUztcclxuICAgICAgbGV0IHkgPSB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCAtIChmcHMgLyBtYXgpICogKHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDIwKTtcclxuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbyhwcmV2WCwgcHJldlkpO1xyXG4gICAgICB0aGlzLmN0eC5saW5lVG8oeCwgeSk7XHJcbiAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuXHJcbiAgICAgIHByZXZYID0geDtcclxuICAgICAgcHJldlkgPSB5O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIHVwZGF0ZVNHU3RhdHMoKSB7XHJcbiAgICBpZiAodGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLmF2Z1NHQ2xlYXJUaW1lID1cclxuICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpIC9cclxuICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuU0dGaWxsVGltZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLmF2Z1NHRmlsbFRpbWUgPVxyXG4gICAgICAgIHRoaXMuU0dGaWxsVGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKSAvXHJcbiAgICAgICAgdGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuYXZnU0dVcGRhdGVUaW1lID1cclxuICAgICAgICB0aGlzLlNHVXBkYXRlVGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKSAvXHJcbiAgICAgICAgdGhpcy5TR1VwZGF0ZVRpbWVzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5TR1F1ZXJ5VGltZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLmF2Z1NHUXVlcnlUaW1lID1cclxuICAgICAgICB0aGlzLlNHUXVlcnlUaW1lcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpIC9cclxuICAgICAgICB0aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZ2NsZWFyXCIpLmlubmVySFRNTCA9XHJcbiAgICAgIFwiQXZnIFNHIGNsZWFyIHRpbWU6IFwiICsgdGhpcy5hdmdTR0NsZWFyVGltZTtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2dmaWxsXCIpLmlubmVySFRNTCA9XHJcbiAgICAgIFwiQXZnIFNHIGZpbGwgdGltZTogXCIgKyB0aGlzLmF2Z1NHRmlsbFRpbWU7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNndXBkYXRlXCIpLmlubmVySFRNTCA9XHJcbiAgICAgIFwiQXZnIFNHIHVwZGF0ZSB0aW1lOiBcIiArIHRoaXMuYXZnU0dVcGRhdGVUaW1lO1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZ3F1ZXJ5XCIpLmlubmVySFRNTCA9XHJcbiAgICAgIFwiQXZnIFNHIHF1ZXJ5IHRpbWU6IFwiICsgdGhpcy5hdmdTR1F1ZXJ5VGltZTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi9FdmVudFF1ZXVlXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vR2FtZUV2ZW50XCI7XHJcblxyXG4vKipcclxuICogQW4gZXZlbnQgZW1pdHRlciBvYmplY3Qgb3RoZXIgc3lzdGVtcyBjYW4gdXNlIHRvIGhvb2sgaW50byB0aGUgRXZlbnRRdWV1ZS5cclxuICogUHJvdmlkZXMgYW4gZWFzeSBpbnRlcmZhY2UgZm9yIGZpcmluZyBvZmYgZXZlbnRzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW1pdHRlciB7XHJcbiAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBFdmVudFF1ZXVlICovXHJcbiAgcHJpdmF0ZSBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xyXG5cclxuICAvKiogQ3JlYXRlcyBhIG5ldyBFbWl0dGVyICovXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbWl0IGFuZCBldmVudCBvZiB0eXBlIGV2ZW50VHlwZSB3aXRoIHRoZSBkYXRhIHBhY2tldCBkYXRhXHJcbiAgICogQHBhcmFtIGV2ZW50VHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBvZmZcclxuICAgKiBAcGFyYW0gZGF0YSBBIEByZWZlcmVuY2VbTWFwXSBvciByZWNvcmQgY29udGFpbmluZyBhbnkgZGF0YSBhYm91dCB0aGUgZXZlbnRcclxuICAgKi9cclxuICBmaXJlRXZlbnQoXHJcbiAgICBldmVudFR5cGU6IHN0cmluZyxcclxuICAgIGRhdGE6IE1hcDxhbnk+IHwgUmVjb3JkPHN0cmluZywgYW55PiA9IG51bGwsXHJcbiAgKTogdm9pZCB7XHJcbiAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQobmV3IEdhbWVFdmVudChldmVudFR5cGUsIGRhdGEpKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4vUmVjZWl2ZXJcIjtcclxuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuL0dhbWVFdmVudFR5cGVcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFpbiBldmVudCBzeXN0ZW0gb2YgdGhlIGdhbWUgZW5naW5lLlxyXG4gKiBFdmVudHMgYXJlIHNlbnQgdG8gdGhlIEV2ZW50UXVldWUsIHdoaWNoIGhhbmRsZXMgZGlzdHJpYnV0aW9uIHRvIGFueSBzeXN0ZW1zIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgdGhvc2UgZXZlbnRzLlxyXG4gKiBUaGlzIGFsbG93cyBmb3IgaGFuZGxpbmcgb2YgaW5wdXQgd2l0aG91dCBoYXZpbmcgY2xhc3NlcyBkaXJlY3RseSBob29rIGludG8gamF2YXNjcmlwdCBldmVudCBoYW5kbGVzLFxyXG4gKiBhbmQgYWxsb3dzIG90aGVyd2lzZSBzZXBhcmF0ZSBjbGFzc2VzIHRvIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlciBjbGVhbmx5LCBzdWNoIGFzIGEgUGxheWVyIG9iamVjdFxyXG4gKiByZXF1ZXN0aW5nIGEgc291bmQgYmUgcGxheWVkIGJ5IHRoZSBhdWRpbyBzeXN0ZW0uXHJcbiAqXHJcbiAqIFRoZSBkaXN0cmlidXRpb24gb2YgQHJlZmVyZW5jZVtHYW1lRXZlbnRdcyBoYXBwZW5zIGFzIGZvbGxvd3M6XHJcbiAqXHJcbiAqIEV2ZW50cyBhcmUgcmVjaWV2ZWQgdGhyb3VnaG91dCBhIGZyYW1lIGFuZCBhcmUgcXVldWVkIHVwIGJ5IHRoZSBFdmVudFF1ZXVlLlxyXG4gKiBBdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGZyYW1lLCBldmVudHMgYXJlIHNlbnQgb3V0IHRvIGFueSByZWNlaXZlcnMgdGhhdCBhcmUgaG9va2VkIGludG8gdGhlIGV2ZW50IHR5cGUuXHJcbiAqIEByZWZlcmVuY2VbUmVjZWl2ZXJdcyBhcmUgdGhlbiBmcmVlIHRvIHByb2Nlc3MgZXZlbnRzIGFzIHRoZXkgc2VlIGZpdC5cclxuICpcclxuICogT3ZlcmFsbCwgdGhlIEV2ZW50UXVldWUgY2FuIGJlIGNvbnNpZGVyZWQgYXMgc29tZXRoaW5nIHNpbWlsYXIgdG8gYW4gZW1haWwgc2VydmVyLFxyXG4gKiBhbmQgdGhlIEByZWZlcmVuY2VbUmVjZWl2ZXJdcyBjYW4gYmUgY29uc2lkZXJlZCBhcyB0aGUgY2xpZW50IGluYm94ZXMuXHJcbiAqXHJcbiAqIFNlZSBAbGluayhHYW1lIFByb2dyYW1taW5nIFBhdHRlcm5zKShodHRwczovL2dhbWVwcm9ncmFtbWluZ3BhdHRlcm5zLmNvbS9ldmVudC1xdWV1ZS5odG1sKSBmb3IgbW9yZSBkaXNjdXNzaW9uIG9uIEV2ZW50UXVldWVzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFF1ZXVlIHtcclxuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogRXZlbnRRdWV1ZSA9IG51bGw7XHJcblxyXG4gIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHZpc2libGUgKi9cclxuICBwcml2YXRlIHJlYWRvbmx5IE1BWF9TSVpFOiBudW1iZXI7XHJcblxyXG4gIC8qKiBUaGUgYWN0dWFsIHF1ZXVlIG9mIGV2ZW50cyAqL1xyXG4gIHByaXZhdGUgcTogUXVldWU8R2FtZUV2ZW50PjtcclxuXHJcbiAgLyoqIFRoZSBtYXAgb2YgcmVjZWl2ZXJzIHJlZ2lzdGVyZWQgZm9yIGFuIGV2ZW50IG5hbWUgKi9cclxuICBwcml2YXRlIHJlY2VpdmVyczogTWFwPEFycmF5PFJlY2VpdmVyPj47XHJcblxyXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLk1BWF9TSVpFID0gMTAwO1xyXG4gICAgdGhpcy5xID0gbmV3IFF1ZXVlPEdhbWVFdmVudD4odGhpcy5NQVhfU0laRSk7XHJcbiAgICB0aGlzLnJlY2VpdmVycyA9IG5ldyBNYXA8QXJyYXk8UmVjZWl2ZXI+PigpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFJldHJpZXZlcyB0aGUgaW5zdGFuY2Ugb2YgdGhlIFNpbmdsZXRvbiBFdmVudFF1ZXVlICovXHJcbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IEV2ZW50UXVldWUge1xyXG4gICAgaWYgKHRoaXMuaW5zdGFuY2UgPT09IG51bGwpIHtcclxuICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBFdmVudFF1ZXVlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XHJcbiAgfVxyXG5cclxuICAvKiogQWRkcyBhbiBldmVudCB0byB0aGUgRXZlbnRRdWV1ZS5cclxuICAgKiBUaGlzIGlzIGV4cG9zZWQgdG8gdGhlIHJlc3Qgb2YgdGhlIGdhbWUgZW5naW5lIHRocm91Z2ggdGhlIEByZWZlcmVuY2VbRW1pdHRlcl0gY2xhc3MgKi9cclxuICBhZGRFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XHJcbiAgICB0aGlzLnEuZW5xdWV1ZShldmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBc3NvY2lhdGVzIGEgcmVjZWl2ZXIgd2l0aCBhIHR5cGUgb2YgZXZlbnQuIEV2ZXJ5IHRpbWUgdGhpcyBldmVudCBhcHBlYXJzIGluIHRoZSBmdXR1cmUsXHJcbiAgICogaXQgd2lsbCBiZSBnaXZlbiB0byB0aGUgcmVjZWl2ZXIgKGFuZCBhbnkgb3RoZXJzIHdhdGNoaW5nIHRoYXQgdHlwZSkuXHJcbiAgICogVGhpcyBpcyBleHBvc2VkIHRvIHRoZSByZXN0IG9mIHRoZSBnYW1lIGVuZ2luZSB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW1JlY2VpdmVyXSBjbGFzc1xyXG4gICAqIEBwYXJhbSByZWNlaXZlciBUaGUgZXZlbnQgcmVjZWl2ZXJcclxuICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvciB0eXBlcyBvZiBldmVudHMgdG8gc3Vic2NyaWJlIHRvXHJcbiAgICovXHJcbiAgc3Vic2NyaWJlKHJlY2VpdmVyOiBSZWNlaXZlciwgdHlwZTogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPik6IHZvaWQge1xyXG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAvLyBJZiBpdCBpcyBhbiBhcnJheSwgc3Vic2NyaWJlIHRvIGFsbCBldmVudCB0eXBlc1xyXG4gICAgICBmb3IgKGxldCB0IG9mIHR5cGUpIHtcclxuICAgICAgICB0aGlzLmFkZExpc3RlbmVyKHJlY2VpdmVyLCB0KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5hZGRMaXN0ZW5lcihyZWNlaXZlciwgdHlwZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVbnN1YnNjcmliZXMgdGhlIHNwZWNpZmllZCByZWNlaXZlciBmcm9tIGFsbCBldmVudHMsIG9yIGZyb20gd2hhdGV2ZXIgZXZlbnRzIGFyZSBwcm92aWRlZFxyXG4gICAqIEBwYXJhbSByZWNlaXZlciBUaGUgcmVjZWl2ZXIgdG8gdW5zdWJzY3JpYmVcclxuICAgKiBAcGFyYW0ga2V5cyBUaGUgZXZlbnRzIHRvIHVuc3Vic2NyaWJlIGZyb20uIElmIG5vbmUgYXJlIHByb3ZpZGVkLCB1bnN1YnNjcmliZSBmcm9tIGFsbFxyXG4gICAqL1xyXG4gIHVuc3Vic2NyaWJlKHJlY2VpdmVyOiBSZWNlaXZlciwgLi4uZXZlbnRzOiBBcnJheTxzdHJpbmc+KTogdm9pZCB7XHJcbiAgICB0aGlzLnJlY2VpdmVycy5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XHJcbiAgICAgIC8vIElmIGtleXMgd2VyZSBwcm92aWRlZCwgb25seSBjb250aW51ZSBpZiB0aGlzIGtleSBpcyBvbmUgb2YgdGhlbVxyXG4gICAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDAgJiYgZXZlbnRzLmluZGV4T2YoZXZlbnROYW1lKSA9PT0gLTEpIHJldHVybjtcclxuXHJcbiAgICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIG91ciByZWNlaXZlciBmb3IgdGhpcyBrZXlcclxuICAgICAgbGV0IGluZGV4ID0gdGhpcy5yZWNlaXZlcnMuZ2V0KGV2ZW50TmFtZSkuaW5kZXhPZihyZWNlaXZlcik7XHJcblxyXG4gICAgICAvLyBJZiBhbiBpbmRleCB3YXMgZm91bmQsIHJlbW92ZSB0aGUgcmVjZWl2ZXJcclxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXJzLmdldChldmVudE5hbWUpLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQXNzb2NpYXRlIHRoZSByZWNlaXZlciBhbmQgdGhlIHR5cGVcclxuICBwcml2YXRlIGFkZExpc3RlbmVyKHJlY2VpdmVyOiBSZWNlaXZlciwgdHlwZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5yZWNlaXZlcnMuaGFzKHR5cGUpKSB7XHJcbiAgICAgIHRoaXMucmVjZWl2ZXJzLmdldCh0eXBlKS5wdXNoKHJlY2VpdmVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucmVjZWl2ZXJzLmFkZCh0eXBlLCBbcmVjZWl2ZXJdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgd2hpbGUgKHRoaXMucS5oYXNJdGVtcygpKSB7XHJcbiAgICAgIC8vIFJldHJpZXZlIGVhY2ggZXZlbnRcclxuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5xLmRlcXVldWUoKTtcclxuXHJcbiAgICAgIC8vIElmIGEgcmVjZWl2ZXIgaGFzIHRoaXMgZXZlbnQgdHlwZSwgc2VuZCBpdCB0aGUgZXZlbnRcclxuICAgICAgaWYgKHRoaXMucmVjZWl2ZXJzLmhhcyhldmVudC50eXBlKSkge1xyXG4gICAgICAgIGZvciAobGV0IHJlY2VpdmVyIG9mIHRoaXMucmVjZWl2ZXJzLmdldChldmVudC50eXBlKSkge1xyXG4gICAgICAgICAgcmVjZWl2ZXIucmVjZWl2ZShldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiBhIHJlY2VpdmVyIGlzIHN1YnNjcmliZWQgdG8gYWxsIGV2ZW50cywgc2VuZCBpdCB0aGUgZXZlbnRcclxuICAgICAgaWYgKHRoaXMucmVjZWl2ZXJzLmhhcyhHYW1lRXZlbnRUeXBlLkFMTCkpIHtcclxuICAgICAgICBmb3IgKGxldCByZWNlaXZlciBvZiB0aGlzLnJlY2VpdmVycy5nZXQoR2FtZUV2ZW50VHlwZS5BTEwpKSB7XHJcbiAgICAgICAgICByZWNlaXZlci5yZWNlaXZlKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYW4gaW4tZ2FtZSBldmVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW0V2ZW50UXVldWVdXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lRXZlbnQge1xyXG4gIC8qKiBUaGUgdHlwZSBvZiB0aGUgZXZlbnQgKi9cclxuICBwdWJsaWMgdHlwZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgZGF0YSBjb250YWluZWQgYnkgdGhlIGV2ZW50ICovXHJcbiAgcHVibGljIGRhdGE6IE1hcDxhbnk+O1xyXG4gIC8qKiBUaGUgdGltZSBvZiB0aGUgZXZlbnQgaW4gbXMgKi9cclxuICBwdWJsaWMgdGltZTogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IEdhbWVFdmVudC5cclxuICAgKiBUaGlzIGlzIGhhbmRsZWQgaW1wbGljaXRseSB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW0VtaXR0ZXJdIGNsYXNzXHJcbiAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIEdhbWVFdmVudFxyXG4gICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgR2FtZUV2ZW50XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IodHlwZTogc3RyaW5nLCBkYXRhOiBNYXA8YW55PiB8IFJlY29yZDxzdHJpbmcsIGFueT4gPSBudWxsKSB7XHJcbiAgICAvLyBQYXJzZSB0aGUgZ2FtZSBldmVudCBkYXRhXHJcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgTWFwPGFueT4oKTtcclxuICAgIH0gZWxzZSBpZiAoIShkYXRhIGluc3RhbmNlb2YgTWFwKSkge1xyXG4gICAgICAvLyBkYXRhIGlzIGEgcmF3IG9iamVjdCwgdW5wYWNrXHJcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBNYXA8YW55PigpO1xyXG4gICAgICBmb3IgKGxldCBrZXkgaW4gZGF0YSkge1xyXG4gICAgICAgIHRoaXMuZGF0YS5hZGQoa2V5LCBkYXRhW2tleV0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIHRoZSB0eXBlIG9mIHRoZSBHYW1lRXZlbnRcclxuICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSB0byBjaGVja1xyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIEdhbWVFdmVudCBpcyB0aGUgc3BlY2lmaWVkIHR5cGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgKi9cclxuICBpc1R5cGUodHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGlzIEdhbWVFdmVudCBhcyBhIHN0cmluZ1xyXG4gICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEdhbWVFdmVudFxyXG4gICAqL1xyXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy50eXBlICsgXCI6IEBcIiArIHRoaXMudGltZTtcclxuICB9XHJcbn1cclxuIiwiLy8gQGlnbm9yZVBhZ2VcclxuXHJcbmV4cG9ydCBlbnVtIEdhbWVFdmVudFR5cGUge1xyXG4gIC8qKlxyXG4gICAqIE1vdXNlIERvd24gZXZlbnQuIEhhcyBkYXRhOiB7cG9zaXRpb246IFZlYzIgLSBNb3VzZSBQb3NpdGlvbn1cclxuICAgKi9cclxuICBNT1VTRV9ET1dOID0gXCJtb3VzZV9kb3duXCIsXHJcbiAgLyoqXHJcbiAgICogTW91c2UgVXAgZXZlbnQuIEhhcyBkYXRhOiB7cG9zaXRpb246IFZlYzIgLSBNb3VzZSBQb3NpdGlvbn1cclxuICAgKi9cclxuICBNT1VTRV9VUCA9IFwibW91c2VfdXBcIixcclxuICAvKipcclxuICAgKiBNb3VzZSBNb3ZlIGV2ZW50LiBIYXMgZGF0YToge3Bvc2l0aW9uOiBWZWMyIC0gTW91c2UgUG9zaXRpb259XHJcbiAgICovXHJcbiAgTU9VU0VfTU9WRSA9IFwibW91c2VfbW92ZVwiLFxyXG5cclxuICAvKipcclxuICAgKiBLZXkgRG93biBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZyAtIFRoZSBrZXkgdGhhdCBpcyBkb3dufVxyXG4gICAqL1xyXG4gIEtFWV9ET1dOID0gXCJrZXlfZG93blwiLFxyXG5cclxuICAvKipcclxuICAgKiBLZXkgVXAgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcgLSBUaGUga2V5IHRoYXQgaXMgdXB9XHJcbiAgICovXHJcbiAgS0VZX1VQID0gXCJrZXlfdXBcIixcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FudmFzIEJsdXIgZXZlbnQuIEhhcyBkYXRhOiB7fVxyXG4gICAqL1xyXG4gIENBTlZBU19CTFVSID0gXCJjYW52YXNfYmx1clwiLFxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSB3aGVlbCB1cCBldmVudC4gSGFzIGRhdGE6IHt9XHJcbiAgICovXHJcbiAgV0hFRUxfVVAgPSBcIndoZWVsX3VwXCIsXHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIHdoZWVsIGRvd24gZXZlbnQuIEhhcyBkYXRhOiB7fVxyXG4gICAqL1xyXG4gIFdIRUVMX0RPV04gPSBcIndoZWVsX2Rvd25cIixcclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgUmVjb3JkaW5nIGV2ZW50LiBIYXMgZGF0YToge31cclxuICAgKi9cclxuICBTVEFSVF9SRUNPUkRJTkcgPSBcInN0YXJ0X3JlY29yZGluZ1wiLFxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIFJlY29yZGluZyBldmVudC4gSGFzIGRhdGE6IHt9XHJcbiAgICovXHJcbiAgU1RPUF9SRUNPUkRJTkcgPSBcInN0b3BfcmVjb3JkaW5nXCIsXHJcblxyXG4gIC8qKlxyXG4gICAqIFBsYXkgUmVjb3JkaW5nIGV2ZW50LiBIYXMgZGF0YToge31cclxuICAgKi9cclxuICBQTEFZX1JFQ09SRElORyA9IFwicGxheV9yZWNvcmRpbmdcIixcclxuXHJcbiAgLyoqXHJcbiAgICogUGxheSBTb3VuZCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZywgbG9vcDogYm9vbGVhbiwgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiB9XHJcbiAgICovXHJcbiAgUExBWV9TT1VORCA9IFwicGxheV9zb3VuZFwiLFxyXG5cclxuICAvKipcclxuICAgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nfVxyXG4gICAqL1xyXG4gIFNUT1BfU09VTkQgPSBcInN0b3Bfc291bmRcIixcclxuXHJcbiAgLyoqXHJcbiAgICogUGxheSBTb3VuZCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZywgbG9vcDogYm9vbGVhbiwgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiwgY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSB9XHJcbiAgICovXHJcbiAgUExBWV9TRlggPSBcInBsYXlfc2Z4XCIsXHJcblxyXG4gIC8qKlxyXG4gICAqIFBsYXkgU291bmQgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4sIGhvbGRSZWZlcmVuY2U6IGJvb2xlYW4gfVxyXG4gICAqL1xyXG4gIFBMQVlfTVVTSUMgPSBcInBsYXlfbXVzaWNcIixcclxuXHJcbiAgLyoqXHJcbiAgICogTXV0ZSBhdWRpbyBjaGFubmVsIGV2ZW50LiBIYXMgZGF0YToge2NoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGV9XHJcbiAgICovXHJcbiAgTVVURV9DSEFOTkVMID0gXCJtdXRlX2NoYW5uZWxcIixcclxuXHJcbiAgLyoqXHJcbiAgICogVW5tdXRlIGF1ZGlvIGNoYW5uZWwgZXZlbnQuIEhhcyBkYXRhOiB7Y2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZX1cclxuICAgKi9cclxuICBVTk1VVEVfQ0hBTk5FTCA9IFwidW5tdXRlX2NoYW5uZWxcIixcclxuXHJcbiAgLyoqXHJcbiAgICogRW5jb21wYXNzZXMgYWxsIGV2ZW50IHR5cGVzLiBVc2VkIGZvciByZWNlaXZlcnMgb25seS5cclxuICAgKi9cclxuICBBTEwgPSBcImFsbFwiLFxyXG59XHJcbiIsImltcG9ydCBRdWV1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1F1ZXVlXCI7XHJcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuL0V2ZW50UXVldWVcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi9HYW1lRXZlbnRcIjtcclxuXHJcbi8qKlxyXG4gKiBSZWNlaXZlcyBzdWJzY3JpYmVkIGV2ZW50cyBmcm9tIHRoZSBFdmVudFF1ZXVlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjZWl2ZXIge1xyXG4gIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHRoaXMgUmVjZWl2ZXIgY2FuIGhvbGQgYXQgb25lIHRpbWUgKi9cclxuICByZWFkb25seSBNQVhfU0laRTogbnVtYmVyO1xyXG5cclxuICAvKiogVGhlIGluYm94IG9mIHRoZSBSZWNlaXZlciAqL1xyXG4gIHByaXZhdGUgcTogUXVldWU8R2FtZUV2ZW50PjtcclxuXHJcbiAgLyoqIENyZWF0ZXMgYSBuZXcgUmVjZWl2ZXIgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuTUFYX1NJWkUgPSAxMDA7XHJcbiAgICB0aGlzLnEgPSBuZXcgUXVldWUodGhpcy5NQVhfU0laRSk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpLnVuc3Vic2NyaWJlKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyB0aGVzZSB0eXBlcyBvZiBldmVudHMgdG8gdGhpcyByZWNlaXZlcidzIHF1ZXVlIGV2ZXJ5IHVwZGF0ZS5cclxuICAgKiBAcGFyYW0gZXZlbnRUeXBlcyBUaGUgdHlwZXMgb2YgZXZlbnRzIHRoaXMgcmVjZWl2ZXIgd2lsbCBiZSBzdWJzY3JpYmVkIHRvXHJcbiAgICovXHJcbiAgc3Vic2NyaWJlKGV2ZW50VHlwZXM6IHN0cmluZyB8IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcclxuICAgIEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKS5zdWJzY3JpYmUodGhpcywgZXZlbnRUeXBlcyk7XHJcbiAgICB0aGlzLnEuY2xlYXIoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYW4gZXZlbnQgdG8gdGhlIHF1ZXVlIG9mIHRoaXMgcmVjaWV2ZXIuIFRoaXMgaXMgdXNlZCBieSB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXSB0byBkaXN0cmlidXRlIGV2ZW50c1xyXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gcmVjZWl2ZVxyXG4gICAqL1xyXG4gIHJlY2VpdmUoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy5xLmVucXVldWUoZXZlbnQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJSZWNlaXZlciBvdmVyZmxvdyBmb3IgZXZlbnQgXCIgKyBldmVudC50b1N0cmluZygpKTtcclxuICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlcyB0aGUgbmV4dCBldmVudCBmcm9tIHRoZSByZWNlaXZlcidzIHF1ZXVlXHJcbiAgICogQHJldHVybnMgVGhlIG5leHQgR2FtZUV2ZW50XHJcbiAgICovXHJcbiAgZ2V0TmV4dEV2ZW50KCk6IEdhbWVFdmVudCB7XHJcbiAgICByZXR1cm4gdGhpcy5xLmRlcXVldWUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvb2tzIGF0IHRoZSBuZXh0IGV2ZW50IGluIHRoZSByZWNlaXZlcidzIHF1ZXVlLCBidXQgZG9lc24ndCByZW1vdmUgaXQgZnJvbSB0aGUgcXVldWVcclxuICAgKiBAcmV0dXJucyBUaGUgbmV4dCBHYW1lRXZlbnRcclxuICAgKi9cclxuICBwZWVrTmV4dEV2ZW50KCk6IEdhbWVFdmVudCB7XHJcbiAgICByZXR1cm4gdGhpcy5xLnBlZWtOZXh0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlY2VpdmVyIGhhcyBhbnkgZXZlbnRzIGluIGl0cyBxdWV1ZVxyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHJlY2VpdmVyIGhhcyBhbm90aGVyIGV2ZW50LCBmYWxzZSBvdGhlcndpc2VcclxuICAgKi9cclxuICBoYXNOZXh0RXZlbnQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5xLmhhc0l0ZW1zKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJZ25vcmUgYWxsIGV2ZW50cyB0aGlzIGZyYW1lXHJcbiAgICovXHJcbiAgaWdub3JlRXZlbnRzKCk6IHZvaWQge1xyXG4gICAgdGhpcy5xLmNsZWFyKCk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XHJcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuLi9FdmVudHMvRXZlbnRRdWV1ZVwiO1xyXG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRUeXBlXCI7XHJcblxyXG50eXBlIEtleU1hcCA9IHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAga2V5czogc3RyaW5nW107XHJcbn07XHJcblxyXG4vKipcclxuICogUmVjZWl2ZXMgaW5wdXQgZXZlbnRzIGZyb20gdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV0gYW5kIGFsbG93cyBmb3IgZWFzeSBhY2Nlc3Mgb2YgaW5mb3JtYXRpb24gYWJvdXQgaW5wdXQgYnkgb3RoZXIgc3lzdGVtc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQge1xyXG4gIHByaXZhdGUgc3RhdGljIG1vdXNlUHJlc3NlZDogYm9vbGVhbjtcclxuICBwcml2YXRlIHN0YXRpYyBtb3VzZUp1c3RQcmVzc2VkOiBib29sZWFuO1xyXG4gIHByaXZhdGUgc3RhdGljIG1vdXNlQnV0dG9uUHJlc3NlZDogbnVtYmVyO1xyXG5cclxuICBwcml2YXRlIHN0YXRpYyBrZXlKdXN0UHJlc3NlZDogTWFwPGJvb2xlYW4+O1xyXG4gIHByaXZhdGUgc3RhdGljIGtleVByZXNzZWQ6IE1hcDxib29sZWFuPjtcclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgbW91c2VQb3NpdGlvbjogVmVjMjtcclxuICBwcml2YXRlIHN0YXRpYyBtb3VzZVByZXNzUG9zaXRpb246IFZlYzI7XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIHNjcm9sbERpcmVjdGlvbjogbnVtYmVyO1xyXG4gIHByaXZhdGUgc3RhdGljIGp1c3RTY3JvbGxlZDogYm9vbGVhbjtcclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcclxuICBwcml2YXRlIHN0YXRpYyByZWNlaXZlcjogUmVjZWl2ZXI7XHJcbiAgcHJpdmF0ZSBzdGF0aWMgdmlld3BvcnQ6IFZpZXdwb3J0O1xyXG5cclxuICBwcml2YXRlIHN0YXRpYyBrZXlNYXA6IE1hcDxBcnJheTxzdHJpbmc+PjtcclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMga2V5c0Rpc2FibGVkOiBib29sZWFuO1xyXG4gIHByaXZhdGUgc3RhdGljIG1vdXNlRGlzYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIHRoZSBJbnB1dCBvYmplY3RcclxuICAgKiBAcGFyYW0gdmlld3BvcnQgQSByZWZlcmVuY2UgdG8gdGhlIHZpZXdwb3J0IG9mIHRoZSBnYW1lXHJcbiAgICogQHBhcmFtIGtleU1hcCBMaXN0IG9mIGtleXNcclxuICAgKi9cclxuICBzdGF0aWMgaW5pdGlhbGl6ZSh2aWV3cG9ydDogVmlld3BvcnQsIGtleU1hcDogQXJyYXk8S2V5TWFwPikge1xyXG4gICAgSW5wdXQudmlld3BvcnQgPSB2aWV3cG9ydDtcclxuICAgIElucHV0Lm1vdXNlUHJlc3NlZCA9IGZhbHNlO1xyXG4gICAgSW5wdXQubW91c2VKdXN0UHJlc3NlZCA9IGZhbHNlO1xyXG4gICAgSW5wdXQucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcclxuICAgIElucHV0LmtleUp1c3RQcmVzc2VkID0gbmV3IE1hcDxib29sZWFuPigpO1xyXG4gICAgSW5wdXQua2V5UHJlc3NlZCA9IG5ldyBNYXA8Ym9vbGVhbj4oKTtcclxuICAgIElucHV0Lm1vdXNlUG9zaXRpb24gPSBuZXcgVmVjMigwLCAwKTtcclxuICAgIElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbiA9IG5ldyBWZWMyKDAsIDApO1xyXG4gICAgSW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gMDtcclxuICAgIElucHV0Lmp1c3RTY3JvbGxlZCA9IGZhbHNlO1xyXG4gICAgSW5wdXQua2V5c0Rpc2FibGVkID0gZmFsc2U7XHJcbiAgICBJbnB1dC5tb3VzZURpc2FibGVkID0gZmFsc2U7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUga2V5bWFwXHJcbiAgICBJbnB1dC5rZXlNYXAgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgLy8gQWRkIGFsbCBrZXlzIHRvIHRoZSBrZXltYXBcclxuICAgIGZvciAobGV0IGVudHJ5IGluIGtleU1hcCkge1xyXG4gICAgICBsZXQgbmFtZSA9IGtleU1hcFtlbnRyeV0ubmFtZTtcclxuICAgICAgbGV0IGtleXMgPSBrZXlNYXBbZW50cnldLmtleXM7XHJcbiAgICAgIElucHV0LmtleU1hcC5hZGQobmFtZSwga2V5cyk7XHJcbiAgICB9XHJcblxyXG4gICAgSW5wdXQuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcclxuICAgIC8vIFN1YnNjcmliZSB0byBhbGwgaW5wdXQgZXZlbnRzXHJcbiAgICBJbnB1dC5ldmVudFF1ZXVlLnN1YnNjcmliZShJbnB1dC5yZWNlaXZlciwgW1xyXG4gICAgICBHYW1lRXZlbnRUeXBlLk1PVVNFX0RPV04sXHJcbiAgICAgIEdhbWVFdmVudFR5cGUuTU9VU0VfVVAsXHJcbiAgICAgIEdhbWVFdmVudFR5cGUuTU9VU0VfTU9WRSxcclxuICAgICAgR2FtZUV2ZW50VHlwZS5LRVlfRE9XTixcclxuICAgICAgR2FtZUV2ZW50VHlwZS5LRVlfVVAsXHJcbiAgICAgIEdhbWVFdmVudFR5cGUuQ0FOVkFTX0JMVVIsXHJcbiAgICAgIEdhbWVFdmVudFR5cGUuV0hFRUxfVVAsXHJcbiAgICAgIEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTixcclxuICAgIF0pO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNoYW5nZUtleU1hcChrZXlNYXA6IEFycmF5PEtleU1hcD4pIHtcclxuICAgIElucHV0LmtleU1hcCA9IG5ldyBNYXAoKTtcclxuICAgIGZvciAoY29uc3QgZW50cnkgaW4ga2V5TWFwKSB7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBrZXlNYXBbZW50cnldLm5hbWU7XHJcbiAgICAgIGNvbnN0IGtleXMgPSBrZXlNYXBbZW50cnldLmtleXM7XHJcbiAgICAgIElucHV0LmtleU1hcC5hZGQobmFtZSwga2V5cyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAvLyBSZXNldCB0aGUganVzdFByZXNzZWQgdmFsdWVzIHRvIGZhbHNlXHJcbiAgICBJbnB1dC5tb3VzZUp1c3RQcmVzc2VkID0gZmFsc2U7XHJcbiAgICBJbnB1dC5rZXlKdXN0UHJlc3NlZC5mb3JFYWNoKChrZXk6IHN0cmluZykgPT5cclxuICAgICAgSW5wdXQua2V5SnVzdFByZXNzZWQuc2V0KGtleSwgZmFsc2UpLFxyXG4gICAgKTtcclxuICAgIElucHV0Lmp1c3RTY3JvbGxlZCA9IGZhbHNlO1xyXG4gICAgSW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gMDtcclxuXHJcbiAgICB3aGlsZSAoSW5wdXQucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpIHtcclxuICAgICAgbGV0IGV2ZW50ID0gSW5wdXQucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XHJcblxyXG4gICAgICAvLyBIYW5kbGUgZWFjaCBldmVudCB0eXBlXHJcbiAgICAgIGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1PVVNFX0RPV04pIHtcclxuICAgICAgICBJbnB1dC5tb3VzZUp1c3RQcmVzc2VkID0gdHJ1ZTtcclxuICAgICAgICBJbnB1dC5tb3VzZVByZXNzZWQgPSB0cnVlO1xyXG4gICAgICAgIElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbiA9IGV2ZW50LmRhdGEuZ2V0KFwicG9zaXRpb25cIik7XHJcbiAgICAgICAgSW5wdXQubW91c2VCdXR0b25QcmVzc2VkID0gZXZlbnQuZGF0YS5nZXQoXCJidXR0b25cIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1PVVNFX1VQKSB7XHJcbiAgICAgICAgSW5wdXQubW91c2VQcmVzc2VkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1PVVNFX01PVkUpIHtcclxuICAgICAgICBJbnB1dC5tb3VzZVBvc2l0aW9uID0gZXZlbnQuZGF0YS5nZXQoXCJwb3NpdGlvblwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuS0VZX0RPV04pIHtcclxuICAgICAgICBsZXQga2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XHJcbiAgICAgICAgLy8gSGFuZGxlIHNwYWNlIGJhclxyXG4gICAgICAgIGlmIChrZXkgPT09IFwiIFwiKSB7XHJcbiAgICAgICAgICBrZXkgPSBcInNwYWNlXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghSW5wdXQua2V5UHJlc3NlZC5nZXQoa2V5KSkge1xyXG4gICAgICAgICAgSW5wdXQua2V5SnVzdFByZXNzZWQuc2V0KGtleSwgdHJ1ZSk7XHJcbiAgICAgICAgICBJbnB1dC5rZXlQcmVzc2VkLnNldChrZXksIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuS0VZX1VQKSB7XHJcbiAgICAgICAgbGV0IGtleSA9IGV2ZW50LmRhdGEuZ2V0KFwia2V5XCIpO1xyXG4gICAgICAgIC8vIEhhbmRsZSBzcGFjZSBiYXJcclxuICAgICAgICBpZiAoa2V5ID09PSBcIiBcIikge1xyXG4gICAgICAgICAga2V5ID0gXCJzcGFjZVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBJbnB1dC5rZXlQcmVzc2VkLnNldChrZXksIGZhbHNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuQ0FOVkFTX0JMVVIpIHtcclxuICAgICAgICBJbnB1dC5jbGVhcktleVByZXNzZXMoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuV0hFRUxfVVApIHtcclxuICAgICAgICBJbnB1dC5zY3JvbGxEaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICBJbnB1dC5qdXN0U2Nyb2xsZWQgPSB0cnVlO1xyXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTikge1xyXG4gICAgICAgIElucHV0LnNjcm9sbERpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgSW5wdXQuanVzdFNjcm9sbGVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgY2xlYXJLZXlQcmVzc2VzKCk6IHZvaWQge1xyXG4gICAgSW5wdXQua2V5SnVzdFByZXNzZWQuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+XHJcbiAgICAgIElucHV0LmtleUp1c3RQcmVzc2VkLnNldChrZXksIGZhbHNlKSxcclxuICAgICk7XHJcbiAgICBJbnB1dC5rZXlQcmVzc2VkLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiBJbnB1dC5rZXlQcmVzc2VkLnNldChrZXksIGZhbHNlKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEga2V5IHdhcyBuZXdseSBwcmVzc2VkIElucHV0IGZyYW1lLlxyXG4gICAqIElmIHRoZSBrZXkgaXMgc3RpbGwgcHJlc3NlZCBmcm9tIGxhc3QgZnJhbWUgYW5kIHdhc24ndCByZS1wcmVzc2VkLCBJbnB1dCB3aWxsIHJldHVybiBmYWxzZS5cclxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXlcclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBrZXkgd2FzIGp1c3QgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgc3RhdGljIGlzS2V5SnVzdFByZXNzZWQoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGlmIChJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBpZiAoSW5wdXQua2V5SnVzdFByZXNzZWQuaGFzKGtleSkpIHtcclxuICAgICAgcmV0dXJuIElucHV0LmtleUp1c3RQcmVzc2VkLmdldChrZXkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgb2YgdGhlIGtleXMgdGhhdCBhcmUgbmV3bHkgcHJlc3NlZCBJbnB1dCBmcmFtZS5cclxuICAgKiBJZiBhIGtleSBpcyBzdGlsbCBwcmVzc2VkIGZyb20gbGFzdCBmcmFtZSBhbmQgd2Fzbid0IHJlLXByZXNzZWQsIGl0IHdpbGwgbm90IGJlIGluIElucHV0IGxpc3QuXHJcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBuZXdseSBwcmVzc2VkIGtleXMuXHJcbiAgICovXHJcbiAgc3RhdGljIGdldEtleXNKdXN0UHJlc3NlZCgpOiBBcnJheTxzdHJpbmc+IHtcclxuICAgIGlmIChJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBbXTtcclxuXHJcbiAgICBsZXQga2V5cyA9IEFycmF5PHN0cmluZz4oKTtcclxuICAgIElucHV0LmtleUp1c3RQcmVzc2VkLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgaWYgKElucHV0LmtleUp1c3RQcmVzc2VkLmdldChrZXkpKSB7XHJcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGtleXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEga2V5IGlzIGJlaW5nIHByZXNzZWQuXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5XHJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUga2V5IGlzIGN1cnJlbnRseSBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2VcclxuICAgKi9cclxuICBzdGF0aWMgaXNLZXlQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgaWYgKElucHV0LmtleVByZXNzZWQuaGFzKGtleSkpIHtcclxuICAgICAgcmV0dXJuIElucHV0LmtleVByZXNzZWQuZ2V0KGtleSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGFuZ2VzIHRoZSBiaW5kaW5nIG9mIGFuIGlucHV0IG5hbWUgdG8ga2V5c1xyXG4gICAqIEBwYXJhbSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0XHJcbiAgICogQHBhcmFtIGtleXMgVGhlIGNvcnJlc3BvbmRpbmcga2V5c1xyXG4gICAqL1xyXG4gIHN0YXRpYyBjaGFuZ2VLZXlCaW5kaW5nKGlucHV0TmFtZTogc3RyaW5nLCBrZXlzOiBBcnJheTxzdHJpbmc+KTogdm9pZCB7XHJcbiAgICBJbnB1dC5rZXlNYXAuc2V0KGlucHV0TmFtZSwga2V5cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhcnMgYWxsIGtleSBiaW5kaW5nc1xyXG4gICAqL1xyXG4gIHN0YXRpYyBjbGVhckFsbEtleUJpbmRpbmdzKCk6IHZvaWQge1xyXG4gICAgSW5wdXQua2V5TWFwLmNsZWFyKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGlucHV0IHdhcyBqdXN0IHByZXNzZWQgdGhpcyBmcmFtZVxyXG4gICAqIEBwYXJhbSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0XHJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgaW5wdXQgd2FzIGp1c3QgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgc3RhdGljIGlzSnVzdFByZXNzZWQoaW5wdXROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGlmIChJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBpZiAoSW5wdXQua2V5TWFwLmhhcyhpbnB1dE5hbWUpKSB7XHJcbiAgICAgIGNvbnN0IGtleXMgPSBJbnB1dC5rZXlNYXAuZ2V0KGlucHV0TmFtZSk7XHJcbiAgICAgIGxldCBqdXN0UHJlc3NlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcclxuICAgICAgICBqdXN0UHJlc3NlZCA9IGp1c3RQcmVzc2VkIHx8IElucHV0LmlzS2V5SnVzdFByZXNzZWQoa2V5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGp1c3RQcmVzc2VkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBpbnB1dCBpcyBjdXJyZW50bHkgcHJlc3NlZFxyXG4gICAqIEBwYXJhbSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0XHJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgaW5wdXQgaXMgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgc3RhdGljIGlzUHJlc3NlZChpbnB1dE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIGlmIChJbnB1dC5rZXlNYXAuaGFzKGlucHV0TmFtZSkpIHtcclxuICAgICAgY29uc3Qga2V5cyA9IElucHV0LmtleU1hcC5nZXQoaW5wdXROYW1lKTtcclxuICAgICAgbGV0IHByZXNzZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgICAgcHJlc3NlZCA9IHByZXNzZWQgfHwgSW5wdXQuaXNLZXlQcmVzc2VkKGtleSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBwcmVzc2VkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKlxyXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1vdXNlIHdhcyBuZXdseSBwcmVzc2VkIElucHV0IGZyYW1lLlxyXG4gICAqIEBwYXJhbSBtb3VzZUJ1dHRvbiBPcHRpb25hbGx5IHNwZWNpZnkgd2hpY2ggbW91c2UgY2xpY2sgeW91IHdhbnQgdG8ga25vdyB3YXMgcHJlc3NlZC5cclxuICAgKiAwIGZvciBsZWZ0IGNsaWNrLCAxIGZvciBtaWRkbGUgY2xpY2ssIDIgZm9yIHJpZ2h0IGNsaWNrLlxyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG1vdXNlIHdhcyBqdXN0IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBpc01vdXNlSnVzdFByZXNzZWQobW91c2VCdXR0b24/OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgIGlmIChtb3VzZUJ1dHRvbikge1xyXG4gICAgICByZXR1cm4gKFxyXG4gICAgICAgIElucHV0Lm1vdXNlSnVzdFByZXNzZWQgJiZcclxuICAgICAgICAhSW5wdXQubW91c2VEaXNhYmxlZCAmJlxyXG4gICAgICAgIG1vdXNlQnV0dG9uID09IHRoaXMubW91c2VCdXR0b25QcmVzc2VkXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSW5wdXQubW91c2VKdXN0UHJlc3NlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSBwcmVzc2VkXHJcbiAgICogQHBhcmFtIG1vdXNlQnV0dG9uIE9wdGlvbmFsbHkgc3BlY2lmeSB3aGljaCBtb3VzZSBjbGljayB5b3Ugd2FudCB0byBrbm93IHdhcyBwcmVzc2VkLlxyXG4gICAqIDAgZm9yIGxlZnQgY2xpY2ssIDEgZm9yIG1pZGRsZSBjbGljaywgMiBmb3IgcmlnaHQgY2xpY2suXHJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbW91c2UgaXMgY3VycmVudGx5IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBpc01vdXNlUHJlc3NlZChtb3VzZUJ1dHRvbj86IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgaWYgKG1vdXNlQnV0dG9uKSB7XHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgSW5wdXQubW91c2VQcmVzc2VkICYmXHJcbiAgICAgICAgIUlucHV0Lm1vdXNlRGlzYWJsZWQgJiZcclxuICAgICAgICBtb3VzZUJ1dHRvbiA9PSB0aGlzLm1vdXNlQnV0dG9uUHJlc3NlZFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIElucHV0Lm1vdXNlUHJlc3NlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgdXNlciBzY3JvbGxlZCBvciBub3RcclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB1c2VyIGp1c3Qgc2Nyb2xsZWQgSW5wdXQgZnJhbWUsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBkaWRKdXN0U2Nyb2xsKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIElucHV0Lmp1c3RTY3JvbGxlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2Nyb2xsXHJcbiAgICogQHJldHVybnMgLTEgaWYgdGhlIHVzZXIgc2Nyb2xsZWQgdXAsIDEgaWYgdGhleSBzY3JvbGxlZCBkb3duXHJcbiAgICovXHJcbiAgc3RhdGljIGdldFNjcm9sbERpcmVjdGlvbigpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIElucHV0LnNjcm9sbERpcmVjdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwbGF5ZXIncyBtb3VzZVxyXG4gICAqIEByZXR1cm5zIFRoZSBtb3VzZSBwb3NpdGlvbiBzdG9yZWQgYXMgYSBWZWMyXHJcbiAgICovXHJcbiAgc3RhdGljIGdldE1vdXNlUG9zaXRpb24oKTogVmVjMiB7XHJcbiAgICByZXR1cm4gSW5wdXQubW91c2VQb3NpdGlvbi5zY2FsZWQoMSAvIHRoaXMudmlld3BvcnQuZ2V0Wm9vbUxldmVsKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHBsYXllcidzIG1vdXNlIGluIHRoZSBnYW1lIHdvcmxkLFxyXG4gICAqIHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIHNjcm9sbGluZyBvZiB0aGUgdmlld3BvcnRcclxuICAgKiBAcmV0dXJucyBUaGUgbW91c2UgcG9zaXRpb24gc3RvcmVkIGFzIGEgVmVjMlxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXRHbG9iYWxNb3VzZVBvc2l0aW9uKCk6IFZlYzIge1xyXG4gICAgcmV0dXJuIElucHV0Lm1vdXNlUG9zaXRpb25cclxuICAgICAgLmNsb25lKClcclxuICAgICAgLnNjYWxlKDEgLyB0aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpKVxyXG4gICAgICAuYWRkKElucHV0LnZpZXdwb3J0LmdldE9yaWdpbigpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG1vdXNlIHByZXNzXHJcbiAgICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk6IFZlYzIge1xyXG4gICAgcmV0dXJuIElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG1vdXNlIHByZXNzIGluIHRoZSBnYW1lIHdvcmxkLFxyXG4gICAqIHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIHNjcm9sbGluZyBvZiB0aGUgdmlld3BvcnRcclxuICAgKiBAcmV0dXJucyBUaGUgbW91c2UgcG9zaXRpb24gc3RvcmVkIGFzIGEgVmVjMlxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXRHbG9iYWxNb3VzZVByZXNzUG9zaXRpb24oKTogVmVjMiB7XHJcbiAgICByZXR1cm4gSW5wdXQubW91c2VQcmVzc1Bvc2l0aW9uLmNsb25lKCkuYWRkKElucHV0LnZpZXdwb3J0LmdldE9yaWdpbigpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc2FibGVzIGFsbCBrZXlwcmVzcyBhbmQgbW91c2UgY2xpY2sgaW5wdXRzXHJcbiAgICovXHJcbiAgc3RhdGljIGRpc2FibGVJbnB1dCgpOiB2b2lkIHtcclxuICAgIC8vIGNoYW5nZWQgdG8gb25seSBkaXNhYmxlIGtleWJvYXJkIGlucHV0XHJcbiAgICBJbnB1dC5rZXlzRGlzYWJsZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW5hYmxlcyBhbGwga2V5cHJlc3MgYW5kIG1vdXNlIGNsaWNrIGlucHV0c1xyXG4gICAqL1xyXG4gIHN0YXRpYyBlbmFibGVJbnB1dCgpOiB2b2lkIHtcclxuICAgIC8vIGNoYW5nZWQgdG8gb25seSBlbmFibGUga2V5Ym9hcmQgaW5wdXRcclxuICAgIElucHV0LmtleXNEaXNhYmxlZCA9IGZhbHNlO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi4vRXZlbnRzL0V2ZW50UXVldWVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xyXG5cclxuLyoqXHJcbiAqIEhhbmRsZXMgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSB3ZWIgYnJvd3NlciB0byByZWNlaXZlIGFzeW5jaHJvbm91cyBldmVudHMgYW5kIHNlbmQgdGhlbSB0byB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXRIYW5kbGVyIHtcclxuICBwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgSW5wdXRIYW5kbGVyXHJcbiAgICogQHBhcmFtIGNhbnZhcyBUaGUgZ2FtZSBjYW52YXNcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICB0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XHJcblxyXG4gICAgY2FudmFzLm9ubW91c2Vkb3duID0gZXZlbnQgPT4gdGhpcy5oYW5kbGVNb3VzZURvd24oZXZlbnQsIGNhbnZhcyk7XHJcbiAgICBjYW52YXMub25tb3VzZXVwID0gZXZlbnQgPT4gdGhpcy5oYW5kbGVNb3VzZVVwKGV2ZW50LCBjYW52YXMpO1xyXG4gICAgY2FudmFzLm9uY29udGV4dG1lbnUgPSB0aGlzLmhhbmRsZUNvbnRleHRNZW51O1xyXG4gICAgY2FudmFzLm9ubW91c2Vtb3ZlID0gZXZlbnQgPT4gdGhpcy5oYW5kbGVNb3VzZU1vdmUoZXZlbnQsIGNhbnZhcyk7XHJcbiAgICBkb2N1bWVudC5vbmtleWRvd24gPSB0aGlzLmhhbmRsZUtleURvd247XHJcbiAgICBkb2N1bWVudC5vbmtleXVwID0gdGhpcy5oYW5kbGVLZXlVcDtcclxuICAgIGRvY3VtZW50Lm9uYmx1ciA9IHRoaXMuaGFuZGxlQmx1cjtcclxuICAgIGRvY3VtZW50Lm9uY29udGV4dG1lbnUgPSB0aGlzLmhhbmRsZUJsdXI7XHJcbiAgICBkb2N1bWVudC5vbndoZWVsID0gdGhpcy5oYW5kbGVXaGVlbDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaGFuZGxlTW91c2VEb3duID0gKFxyXG4gICAgZXZlbnQ6IE1vdXNlRXZlbnQsXHJcbiAgICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxyXG4gICk6IHZvaWQgPT4ge1xyXG4gICAgbGV0IHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY2FudmFzKTtcclxuICAgIGxldCBidXR0b24gPSBldmVudC5idXR0b247XHJcbiAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLk1PVVNFX0RPV04sIHtcclxuICAgICAgcG9zaXRpb246IHBvcyxcclxuICAgICAgYnV0dG9uOiBidXR0b24sXHJcbiAgICB9KTtcclxuICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xyXG4gIH07XHJcblxyXG4gIHByaXZhdGUgaGFuZGxlTW91c2VVcCA9IChcclxuICAgIGV2ZW50OiBNb3VzZUV2ZW50LFxyXG4gICAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcclxuICApOiB2b2lkID0+IHtcclxuICAgIGxldCBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XHJcbiAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLk1PVVNFX1VQLCB7IHBvc2l0aW9uOiBwb3MgfSk7XHJcbiAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICB9O1xyXG5cclxuICBwcml2YXRlIGhhbmRsZU1vdXNlTW92ZSA9IChcclxuICAgIGV2ZW50OiBNb3VzZUV2ZW50LFxyXG4gICAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcclxuICApOiB2b2lkID0+IHtcclxuICAgIGxldCBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XHJcbiAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLk1PVVNFX01PVkUsIHsgcG9zaXRpb246IHBvcyB9KTtcclxuICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xyXG4gIH07XHJcblxyXG4gIHByaXZhdGUgaGFuZGxlS2V5RG93biA9IChldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgbGV0IGtleSA9IHRoaXMuZ2V0S2V5KGV2ZW50KTtcclxuICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuS0VZX0RPV04sIHsga2V5OiBrZXkgfSk7XHJcbiAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICB9O1xyXG5cclxuICBwcml2YXRlIGhhbmRsZUtleVVwID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICBsZXQga2V5ID0gdGhpcy5nZXRLZXkoZXZlbnQpO1xyXG4gICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5LRVlfVVAsIHsga2V5OiBrZXkgfSk7XHJcbiAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICB9O1xyXG5cclxuICBwcml2YXRlIGhhbmRsZUJsdXIgPSAoZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLkNBTlZBU19CTFVSLCB7fSk7XHJcbiAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICB9O1xyXG5cclxuICBwcml2YXRlIGhhbmRsZUNvbnRleHRNZW51ID0gKGV2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gIH07XHJcblxyXG4gIHByaXZhdGUgaGFuZGxlV2hlZWwgPSAoZXZlbnQ6IFdoZWVsRXZlbnQpOiB2b2lkID0+IHtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICBsZXQgZ2FtZUV2ZW50OiBHYW1lRXZlbnQ7XHJcbiAgICBpZiAoZXZlbnQuZGVsdGFZIDwgMCkge1xyXG4gICAgICBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuV0hFRUxfVVAsIHt9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5XSEVFTF9ET1dOLCB7fSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICB9O1xyXG5cclxuICBwcml2YXRlIGdldEtleShrZXlFdmVudDogS2V5Ym9hcmRFdmVudCkge1xyXG4gICAgcmV0dXJuIGtleUV2ZW50LmtleS50b0xvd2VyQ2FzZSgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRNb3VzZVBvc2l0aW9uKFxyXG4gICAgbW91c2VFdmVudDogTW91c2VFdmVudCxcclxuICAgIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXHJcbiAgKTogVmVjMiB7XHJcbiAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGxldCB4ID0gbW91c2VFdmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xyXG4gICAgbGV0IHkgPSBtb3VzZUV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcclxuICAgIHJldHVybiBuZXcgVmVjMih4LCB5KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHt9IGZyb20gXCIuLi8uLi9pbmRleFwiOyAvLyBUaGlzIGltcG9ydCBhbGxvd3MgdXMgdG8gbW9kaWZ5IHRoZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgdG8gYWRkIGV4dHJhIGZ1bmN0aW9uYWxpdHlcclxuLy8gQGlnbm9yZVBhZ2VcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHVwIHRoZSBlbnZpcm9ubWVudCBvZiB0aGUgZ2FtZSBlbmdpbmVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudmlyb25tZW50SW5pdGlhbGl6ZXIge1xyXG4gIHN0YXRpYyBzZXR1cCgpIHtcclxuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUucm91bmRlZFJlY3QgPSBmdW5jdGlvbiAoXHJcbiAgICAgIHg6IG51bWJlcixcclxuICAgICAgeTogbnVtYmVyLFxyXG4gICAgICB3OiBudW1iZXIsXHJcbiAgICAgIGg6IG51bWJlcixcclxuICAgICAgcjogbnVtYmVyLFxyXG4gICAgKTogdm9pZCB7XHJcbiAgICAgIC8vIENsYW1wIHRoZSByYWRpdXMgYmV0d2VlbiAwIGFuZCB0aGUgbWluIG9mIHRoZSB3aWR0aCBvciBoZWlnaHRcclxuICAgICAgaWYgKHIgPCAwKSByID0gMDtcclxuICAgICAgaWYgKHIgPiBNYXRoLm1pbih3LCBoKSkgciA9IE1hdGgubWluKHcsIGgpO1xyXG5cclxuICAgICAgLy8gRHJhdyB0aGUgcm91bmRlZCByZWN0XHJcbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XHJcblxyXG4gICAgICAvLyBUb3BcclxuICAgICAgdGhpcy5tb3ZlVG8oeCArIHIsIHkpO1xyXG4gICAgICB0aGlzLmxpbmVUbyh4ICsgdyAtIHIsIHkpO1xyXG4gICAgICB0aGlzLmFyY1RvKHggKyB3LCB5LCB4ICsgdywgeSArIHIsIHIpO1xyXG5cclxuICAgICAgLy8gUmlnaHRcclxuICAgICAgdGhpcy5saW5lVG8oeCArIHcsIHkgKyBoIC0gcik7XHJcbiAgICAgIHRoaXMuYXJjVG8oeCArIHcsIHkgKyBoLCB4ICsgdyAtIHIsIHkgKyBoLCByKTtcclxuXHJcbiAgICAgIC8vIEJvdHRvbVxyXG4gICAgICB0aGlzLmxpbmVUbyh4ICsgciwgeSArIGgpO1xyXG4gICAgICB0aGlzLmFyY1RvKHgsIHkgKyBoLCB4LCB5ICsgaCAtIHIsIHIpO1xyXG5cclxuICAgICAgLy8gTGVmdFxyXG4gICAgICB0aGlzLmxpbmVUbyh4LCB5ICsgcik7XHJcbiAgICAgIHRoaXMuYXJjVG8oeCwgeSwgeCArIHIsIHksIHIpO1xyXG5cclxuICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcclxuICAgIH07XHJcblxyXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5zdHJva2VSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uIChcclxuICAgICAgeCxcclxuICAgICAgeSxcclxuICAgICAgdyxcclxuICAgICAgaCxcclxuICAgICAgcixcclxuICAgICkge1xyXG4gICAgICB0aGlzLnJvdW5kZWRSZWN0KHgsIHksIHcsIGgsIHIpO1xyXG4gICAgICB0aGlzLnN0cm9rZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmZpbGxSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uIChcclxuICAgICAgeCxcclxuICAgICAgeSxcclxuICAgICAgdyxcclxuICAgICAgaCxcclxuICAgICAgcixcclxuICAgICkge1xyXG4gICAgICB0aGlzLnJvdW5kZWRSZWN0KHgsIHksIHcsIGgsIHIpO1xyXG4gICAgICB0aGlzLmZpbGwoKTtcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBHYW1lTG9vcCBmcm9tIFwiLi9HYW1lTG9vcFwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBTdGF0cyBmcm9tIFwiLi4vRGVidWcvU3RhdHNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIGdhbWUgbG9vcCB3aXRoIGEgZml4ZWQgdXBkYXRlIHRpbWUgYW5kIGEgdmFyaWFibGUgcmVuZGVyIHRpbWUuXHJcbiAqIEV2ZXJ5IGZyYW1lLCB0aGUgZ2FtZSB1cGRhdGVzIHVudGlsIGFsbCB0aW1lIHNpbmNlIHRoZSBsYXN0IGZyYW1lIGhhcyBiZWVuIHByb2Nlc3NlZC5cclxuICogSWYgdG9vIG11Y2ggdGltZSBoYXMgcGFzc2VkLCBzdWNoIGFzIGlmIHRoZSBsYXN0IHVwZGF0ZSB3YXMgdG9vIHNsb3csXHJcbiAqIG9yIGlmIHRoZSBicm93c2VyIHdhcyBwdXQgaW50byB0aGUgYmFja2dyb3VuZCwgdGhlIGxvb3Agd2lsbCBwYW5pYyBhbmQgZGlzY2FyZCB0aW1lLlxyXG4gKiBBIHJlbmRlciBoYXBwZW5zIGF0IHRoZSBlbmQgb2YgZXZlcnkgZnJhbWUuIFRoaXMgaGFwcGVucyBhcyBmYXN0IGFzIHBvc3NpYmxlIHVubGVzcyBzcGVjaWZpZWQuXHJcbiAqIEEgbG9vcCBvZiB0aGlzIHR5cGUgYWxsb3dzIGZvciBkZXRlcm1pbmlzdGljIGJlaGF2aW9yIC0gTm8gbWF0dGVyIHdoYXQgdGhlIGZyYW1lIHJhdGUgaXMsIHRoZSB1cGRhdGUgc2hvdWxkIGJlaGF2ZSB0aGUgc2FtZSxcclxuICogYXMgaXQgaXMgb2NjdXJpbmcgaW4gYSBmaXhlZCBpbnRlcnZhbC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeGVkVXBkYXRlR2FtZUxvb3AgZXh0ZW5kcyBHYW1lTG9vcCB7XHJcbiAgLyoqIFRoZSBtYXggYWxsb3dlZCB1cGRhdGUgZnBzLiovXHJcbiAgcHJpdmF0ZSBtYXhVcGRhdGVGUFM6IG51bWJlcjtcclxuXHJcbiAgLyoqIFRoZSB0aW1lc3RlcCBmb3IgZWFjaCB1cGRhdGUuIFRoaXMgaXMgdGhlIGRlbHRhVCBwYXNzZWQgdG8gdXBkYXRlIGNhbGxzLiAqL1xyXG4gIHByaXZhdGUgdXBkYXRlVGltZXN0ZXA6IG51bWJlcjtcclxuXHJcbiAgLyoqIFRoZSBhbW91bnQgb2YgdGltZSB3ZSBhcmUgeWV0IHRvIHNpbXVsYXRlLiAqL1xyXG4gIHByaXZhdGUgZnJhbWVEZWx0YTogbnVtYmVyO1xyXG5cclxuICAvKiogVGhlIHRpbWUgd2hlbiB0aGUgbGFzdCBmcmFtZSB3YXMgZHJhd24uICovXHJcbiAgcHJpdmF0ZSBsYXN0RnJhbWVUaW1lOiBudW1iZXI7XHJcblxyXG4gIC8qKiBUaGUgbWluaW11bSB0aW1lIHdlIHdhbnQgdG8gd2FpdCBiZXR3ZWVuIGdhbWUgZnJhbWVzLiAqL1xyXG4gIHByaXZhdGUgbWluRnJhbWVEZWxheTogbnVtYmVyO1xyXG5cclxuICAvKiogVGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhlIGdhbWUuICovXHJcbiAgcHJpdmF0ZSBmcmFtZTogbnVtYmVyO1xyXG5cclxuICAvKiogVGhlIGFjdHVhbCBmcHMgb2YgdGhlIGdhbWUuICovXHJcbiAgcHJpdmF0ZSBmcHM6IG51bWJlcjtcclxuXHJcbiAgLyoqIFRoZSB0aW1lIGJldHdlZW4gZnBzIG1lYXN1cmVtZW50IHVwZGF0ZXMuICovXHJcbiAgcHJpdmF0ZSBmcHNVcGRhdGVJbnRlcnZhbDogbnVtYmVyO1xyXG5cclxuICAvKiogVGhlIHRpbWUgb2YgdGhlIGxhc3QgZnBzIHVwZGF0ZS4gKi9cclxuICBwcml2YXRlIGxhc3RGcHNVcGRhdGU6IG51bWJlcjtcclxuXHJcbiAgLyoqIFRoZSBudW1iZXIgb2YgZnJhbWVzIHNpbmNlIHRoZSBsYXN0IGZwcyB1cGRhdGUgd2FzIGRvbmUuICovXHJcbiAgcHJpdmF0ZSBmcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGU6IG51bWJlcjtcclxuXHJcbiAgLyoqIFRoZSBzdGF0dXMgb2Ygd2hldGhlciBvciBub3QgdGhlIGdhbWUgbG9vcCBoYXMgc3RhcnRlZC4gKi9cclxuICBwcml2YXRlIHN0YXJ0ZWQ6IGJvb2xlYW47XHJcblxyXG4gIC8qKiBUaGUgc3RhdHVzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBnYW1lIGxvb3AgaXMgcGF1c2VkICovXHJcbiAgcHJpdmF0ZSBwYXVzZWQ6IGJvb2xlYW47XHJcblxyXG4gIC8qKiBUaGUgc3RhdHVzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBnYW1lIGxvb3AgaXMgY3VycmVudGx5IHJ1bm5pbmcuICovXHJcbiAgcHJpdmF0ZSBydW5uaW5nOiBib29sZWFuO1xyXG5cclxuICAvKiogVGhlIG51bWJlciBvZiB1cGRhdGUgc3RlcHMgdGhpcyBpdGVyYXRpb24gb2YgdGhlIGdhbWUgbG9vcC4gKi9cclxuICBwcml2YXRlIG51bVVwZGF0ZVN0ZXBzOiBudW1iZXI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMubWF4VXBkYXRlRlBTID0gNjA7XHJcbiAgICB0aGlzLnVwZGF0ZVRpbWVzdGVwID0gTWF0aC5mbG9vcigxMDAwIC8gdGhpcy5tYXhVcGRhdGVGUFMpO1xyXG4gICAgdGhpcy5mcmFtZURlbHRhID0gMDtcclxuICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IDA7XHJcbiAgICB0aGlzLm1pbkZyYW1lRGVsYXkgPSAwO1xyXG4gICAgdGhpcy5mcmFtZSA9IDA7XHJcbiAgICB0aGlzLmZwcyA9IHRoaXMubWF4VXBkYXRlRlBTOyAvLyBJbml0aWFsaXplIHRoZSBmcHMgdG8gdGhlIG1heCBhbGxvd2VkIGZwc1xyXG4gICAgdGhpcy5mcHNVcGRhdGVJbnRlcnZhbCA9IDEwMDA7XHJcbiAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSAwO1xyXG4gICAgdGhpcy5mcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGUgPSAwO1xyXG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzID0gMDtcclxuICB9XHJcblxyXG4gIGdldEZQUygpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSBmcmFtZSBjb3VudCBhbmQgc3VtIG9mIHRpbWUgZm9yIHRoZSBmcmFtZXJhdGUgb2YgdGhlIGdhbWVcclxuICAgKiBAcGFyYW0gdGltZXN0ZXAgVGhlIGN1cnJlbnQgdGltZSBpbiBtc1xyXG4gICAqL1xyXG4gIHByb3RlY3RlZCB1cGRhdGVGUFModGltZXN0YW1wOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMuZnBzID1cclxuICAgICAgKDAuOSAqIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlICogMTAwMCkgL1xyXG4gICAgICAgICh0aW1lc3RhbXAgLSB0aGlzLmxhc3RGcHNVcGRhdGUpICtcclxuICAgICAgKDEgLSAwLjkpICogdGhpcy5mcHM7XHJcbiAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSB0aW1lc3RhbXA7XHJcbiAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSA9IDA7XHJcblxyXG4gICAgRGVidWcubG9nKFwiZnBzXCIsIFwiRlBTOiBcIiArIHRoaXMuZnBzLnRvRml4ZWQoMSkpO1xyXG4gICAgU3RhdHMudXBkYXRlRlBTKHRoaXMuZnBzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoYW5nZXMgdGhlIG1heGltdW0gYWxsb3dlZCBwaHlzaWNzIGZyYW1lcmF0ZSBvZiB0aGUgZ2FtZVxyXG4gICAqIEBwYXJhbSBpbml0TWF4IFRoZSBtYXggZnJhbWVyYXRlXHJcbiAgICovXHJcbiAgc2V0TWF4VXBkYXRlRlBTKGluaXRNYXg6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5tYXhVcGRhdGVGUFMgPSBpbml0TWF4O1xyXG4gICAgdGhpcy51cGRhdGVUaW1lc3RlcCA9IE1hdGguZmxvb3IoMTAwMCAvIHRoaXMubWF4VXBkYXRlRlBTKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIG1heGltdW0gcmVuZGVyaW5nIGZyYW1lcmF0ZVxyXG4gICAqIEBwYXJhbSBtYXhGUFMgVGhlIG1heCBmcmFtZXJhdGVcclxuICAgKi9cclxuICBzZXRNYXhGUFMobWF4RlBTOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMubWluRnJhbWVEZWxheSA9IDEwMDAgLyBtYXhGUFM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHRoZSBnYW1lIGxvb3AgcGFuaWNzLCBpLmUuIGl0IHRyaWVzIHRvIHByb2Nlc3MgdG9vIG11Y2ggdGltZSBpbiBhbiBlbnRpcmUgZnJhbWUuXHJcbiAgICogVGhpcyB3aWxsIHJlc2V0IHRoZSBhbW91bnQgb2YgdGltZSBiYWNrIHRvIHplcm8uXHJcbiAgICogQHJldHVybnMgVGhlIGFtb3VudCBvZiB0aW1lIHdlIGFyZSBkaXNjYXJkaW5nIGZyb20gcHJvY2Vzc2luZy5cclxuICAgKi9cclxuICByZXNldEZyYW1lRGVsdGEoKTogbnVtYmVyIHtcclxuICAgIGxldCBvbGRGcmFtZURlbHRhID0gdGhpcy5mcmFtZURlbHRhO1xyXG4gICAgdGhpcy5mcmFtZURlbHRhID0gMDtcclxuICAgIHJldHVybiBvbGRGcmFtZURlbHRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnRzIHVwIHRoZSBnYW1lIGxvb3AgYW5kIGNhbGxzIHRoZSBmaXJzdCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgKi9cclxuICBzdGFydCgpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5zdGFydGVkKSB7XHJcbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XHJcblxyXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpbWVzdGFtcCA9PiB0aGlzLmRvRmlyc3RGcmFtZSh0aW1lc3RhbXApKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHBhdXNlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmVzdW1lKCk6IHZvaWQge1xyXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBmaXJzdCBnYW1lIGZyYW1lIC0gaW5pdGlhbGl6ZXMgdGhlIGZpcnN0IGZyYW1lIHRpbWUgYW5kIGJlZ2lucyB0aGUgcmVuZGVyXHJcbiAgICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgY3VycmVudCB0aW1lIGluIG1zXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGRvRmlyc3RGcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLl9kb1JlbmRlcigpO1xyXG5cclxuICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IHRpbWVzdGFtcDtcclxuICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IHRpbWVzdGFtcDtcclxuICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcclxuXHJcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHQgPT4gdGhpcy5kb0ZyYW1lKHQpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgYW55IHByb2Nlc3NpbmcgdGhhdCBuZWVkcyB0byBiZSBkb25lIGF0IHRoZSBzdGFydCBvZiB0aGUgZnJhbWVcclxuICAgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lIG9mIHRoZSBmcmFtZSBpbiBtc1xyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBzdGFydEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAvLyBVcGRhdGUgdGhlIGFtb3VudCBvZiB0aW1lIHdlIG5lZWQgb3VyIHVwZGF0ZSB0byBwcm9jZXNzXHJcbiAgICB0aGlzLmZyYW1lRGVsdGEgKz0gdGltZXN0YW1wIC0gdGhpcy5sYXN0RnJhbWVUaW1lO1xyXG5cclxuICAgIC8vIFNldCB0aGUgbmV3IHRpbWUgb2YgdGhlIGxhc3QgZnJhbWVcclxuICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IHRpbWVzdGFtcDtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIGVzdGltYXRlIG9mIHRoZSBmcmFtZXJhdGVcclxuICAgIGlmICh0aW1lc3RhbXAgPiB0aGlzLmxhc3RGcHNVcGRhdGUgKyB0aGlzLmZwc1VwZGF0ZUludGVydmFsKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlRlBTKHRpbWVzdGFtcCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5jcmVtZW50IHRoZSBudW1iZXIgb2YgZnJhbWVzXHJcbiAgICB0aGlzLmZyYW1lKys7XHJcbiAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSsrO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIG1haW4gbG9vcCBvZiB0aGUgZ2FtZS4gVXBkYXRlcyB1bnRpbCB0aGUgY3VycmVudCB0aW1lIGlzIHJlYWNoZWQuIFJlbmRlcnMgb25jZVxyXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIGN1cnJlbnQgdGltZSBpbiBtc1xyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBkb0ZyYW1lID0gKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCA9PiB7XHJcbiAgICAvLyBJZiBhIHBhdXNlIHdhcyBleGVjdXRlZCwgc3RvcCBkb2luZyB0aGUgbG9vcC5cclxuICAgIGlmICh0aGlzLnBhdXNlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVxdWVzdCBhbmltYXRpb24gZnJhbWUgdG8gcHJlcGFyZSBmb3IgYW5vdGhlciB1cGRhdGUgb3IgcmVuZGVyXHJcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHQgPT4gdGhpcy5kb0ZyYW1lKHQpKTtcclxuXHJcbiAgICAvLyBJZiB3ZSBhcmUgdHJ5aW5nIHRvIHJlbmRlciB0b28gc29vbiwgZG8gbm90aGluZy5cclxuICAgIGlmICh0aW1lc3RhbXAgPCB0aGlzLmxhc3RGcmFtZVRpbWUgKyB0aGlzLm1pbkZyYW1lRGVsYXkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEEgZnJhbWUgaXMgYWN0dWFsbHkgaGFwcGVuaW5nXHJcbiAgICB0aGlzLnN0YXJ0RnJhbWUodGltZXN0YW1wKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgd2hpbGUgdGhlcmUgaXMgc3RpbGwgdGltZSB0byBtYWtlIHVwLiBJZiB3ZSBkbyB0b28gbWFueSB1cGRhdGUgc3RlcHMsIHBhbmljIGFuZCBleGl0IHRoZSBsb29wLlxyXG4gICAgdGhpcy5udW1VcGRhdGVTdGVwcyA9IDA7XHJcbiAgICBsZXQgcGFuaWMgPSBmYWxzZTtcclxuXHJcbiAgICB3aGlsZSAodGhpcy5mcmFtZURlbHRhID49IHRoaXMudXBkYXRlVGltZXN0ZXApIHtcclxuICAgICAgLy8gRG8gYW4gdXBkYXRlXHJcbiAgICAgIHRoaXMuX2RvVXBkYXRlKHRoaXMudXBkYXRlVGltZXN0ZXAgLyAxMDAwKTtcclxuXHJcbiAgICAgIC8vIFJlbW92ZSB0aGUgdXBkYXRlIHN0ZXAgdGltZSBmcm9tIHRoZSB0aW1lIHdlIGhhdmUgdG8gcHJvY2Vzc1xyXG4gICAgICB0aGlzLmZyYW1lRGVsdGEgLT0gdGhpcy51cGRhdGVUaW1lc3RlcDtcclxuXHJcbiAgICAgIC8vIEluY3JlbWVudCBzdGVwcyBhbmQgY2hlY2sgaWYgd2UndmUgZG9uZSB0b28gbWFueVxyXG4gICAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzKys7XHJcbiAgICAgIGlmICh0aGlzLm51bVVwZGF0ZVN0ZXBzID4gMTAwKSB7XHJcbiAgICAgICAgcGFuaWMgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlcyBhcmUgZG9uZSwgcmVuZGVyXHJcbiAgICB0aGlzLl9kb1JlbmRlcigpO1xyXG5cclxuICAgIC8vIFdyYXAgdXAgdGhlIGZyYW1lXHJcbiAgICB0aGlzLmZpbmlzaEZyYW1lKHBhbmljKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBXcmFwcyB1cCB0aGUgZnJhbWUgYW5kIGhhbmRsZXMgdGhlIHBhbmljIHN0YXRlIGlmIHRoZXJlIGlzIG9uZVxyXG4gICAqIEBwYXJhbSBwYW5pYyBXaGV0aGVyIG9yIG5vdCB0aGUgbG9vcCBwYW5pY2tlZFxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBmaW5pc2hGcmFtZShwYW5pYzogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgaWYgKHBhbmljKSB7XHJcbiAgICAgIHZhciBkaXNjYXJkZWRUaW1lID0gTWF0aC5yb3VuZCh0aGlzLnJlc2V0RnJhbWVEZWx0YSgpKTtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIFwiTWFpbiBsb29wIHBhbmlja2VkLCBwcm9iYWJseSBiZWNhdXNlIHRoZSBicm93c2VyIHRhYiB3YXMgcHV0IGluIHRoZSBiYWNrZ3JvdW5kLiBEaXNjYXJkaW5nIFwiICtcclxuICAgICAgICAgIGRpc2NhcmRlZFRpbWUgK1xyXG4gICAgICAgICAgXCJtc1wiLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi4vRXZlbnRzL0V2ZW50UXVldWVcIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi9JbnB1dC9JbnB1dFwiO1xyXG5pbXBvcnQgSW5wdXRIYW5kbGVyIGZyb20gXCIuLi9JbnB1dC9JbnB1dEhhbmRsZXJcIjtcclxuaW1wb3J0IFJlY29yZGVyIGZyb20gXCIuLi9QbGF5YmFjay9SZWNvcmRlclwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XHJcbmltcG9ydCBTY2VuZU1hbmFnZXIgZnJvbSBcIi4uL1NjZW5lL1NjZW5lTWFuYWdlclwiO1xyXG5pbXBvcnQgQXVkaW9NYW5hZ2VyIGZyb20gXCIuLi9Tb3VuZC9BdWRpb01hbmFnZXJcIjtcclxuaW1wb3J0IFN0YXRzIGZyb20gXCIuLi9EZWJ1Zy9TdGF0c1wiO1xyXG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXJcIjtcclxuaW1wb3J0IENhbnZhc1JlbmRlcmVyIGZyb20gXCIuLi9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyZXJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgR2FtZU9wdGlvbnMgZnJvbSBcIi4vR2FtZU9wdGlvbnNcIjtcclxuaW1wb3J0IEdhbWVMb29wIGZyb20gXCIuL0dhbWVMb29wXCI7XHJcbmltcG9ydCBGaXhlZFVwZGF0ZUdhbWVMb29wIGZyb20gXCIuL0ZpeGVkVXBkYXRlR2FtZUxvb3BcIjtcclxuaW1wb3J0IEVudmlyb25tZW50SW5pdGlhbGl6ZXIgZnJvbSBcIi4vRW52aXJvbm1lbnRJbml0aWFsaXplclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFJlZ2lzdHJ5TWFuYWdlciBmcm9tIFwiLi4vUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyXCI7XHJcbmltcG9ydCBXZWJHTFJlbmRlcmVyIGZyb20gXCIuLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJlclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcblxyXG4vKipcclxuICogVGhlIG1haW4gbG9vcCBvZiB0aGUgZ2FtZSBlbmdpbmUuXHJcbiAqIEhhbmRsZXMgdGhlIHVwZGF0ZSBvcmRlciwgYW5kIGluaXRpYWxpemVzIGFsbCBzdWJzeXN0ZW1zLlxyXG4gKiBUaGUgR2FtZSBtYW5hZ2VzIHRoZSB1cGRhdGUgY3ljbGUsIGFuZCByZXF1ZXN0cyBhbmltYXRpb24gZnJhbWVzIHRvIHJlbmRlciB0byB0aGUgYnJvd3Nlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWUge1xyXG4gIGdhbWVPcHRpb25zOiBHYW1lT3B0aW9ucztcclxuICBwcml2YXRlIHNob3dEZWJ1ZzogYm9vbGVhbjtcclxuICBwcml2YXRlIHNob3dTdGF0czogYm9vbGVhbjtcclxuXHJcbiAgLy8gVGhlIGdhbWUgbG9vcFxyXG4gIHByaXZhdGUgbG9vcDogR2FtZUxvb3A7XHJcblxyXG4gIC8vIEdhbWUgY2FudmFzIGFuZCBpdHMgd2lkdGggYW5kIGhlaWdodFxyXG4gIHJlYWRvbmx5IEdBTUVfQ0FOVkFTOiBIVE1MQ2FudmFzRWxlbWVudDtcclxuICByZWFkb25seSBERUJVR19DQU5WQVM6IEhUTUxDYW52YXNFbGVtZW50O1xyXG4gIHJlYWRvbmx5IFdJRFRIOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgSEVJR0hUOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSB2aWV3cG9ydDogVmlld3BvcnQ7XHJcbiAgcHJpdmF0ZSBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcclxuICBwcml2YXRlIGNsZWFyQ29sb3I6IENvbG9yO1xyXG5cclxuICAvLyBBbGwgb2YgdGhlIG5lY2Vzc2FyeSBzdWJzeXN0ZW1zIHRoYXQgbmVlZCB0byBydW4gaGVyZVxyXG4gIHByaXZhdGUgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcclxuICBwcml2YXRlIGlucHV0SGFuZGxlcjogSW5wdXRIYW5kbGVyO1xyXG4gIHByaXZhdGUgcmVjb3JkZXI6IFJlY29yZGVyO1xyXG4gIHByaXZhdGUgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XHJcbiAgcHJpdmF0ZSBzY2VuZU1hbmFnZXI6IFNjZW5lTWFuYWdlcjtcclxuICBwcml2YXRlIGF1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyO1xyXG4gIHByaXZhdGUgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBHYW1lXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIEdhbWUgaW5pdGlhbGl6YXRpb25cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pikge1xyXG4gICAgLy8gQmVmb3JlIGFueXRoaW5nIGVsc2UsIGJ1aWxkIHRoZSBlbnZpcm9ubWVudFxyXG4gICAgRW52aXJvbm1lbnRJbml0aWFsaXplci5zZXR1cCgpO1xyXG5cclxuICAgIC8vIFR5cGVjYXN0IHRoZSBjb25maWcgb2JqZWN0IHRvIGEgR2FtZUNvbmZpZyBvYmplY3RcclxuICAgIHRoaXMuZ2FtZU9wdGlvbnMgPSBHYW1lT3B0aW9ucy5wYXJzZShvcHRpb25zKTtcclxuXHJcbiAgICB0aGlzLnNob3dEZWJ1ZyA9IHRoaXMuZ2FtZU9wdGlvbnMuc2hvd0RlYnVnO1xyXG4gICAgdGhpcy5zaG93U3RhdHMgPSB0aGlzLmdhbWVPcHRpb25zLnNob3dTdGF0cztcclxuXHJcbiAgICAvLyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYSBnYW1lIGxvb3BcclxuICAgIHRoaXMubG9vcCA9IG5ldyBGaXhlZFVwZGF0ZUdhbWVMb29wKCk7XHJcblxyXG4gICAgLy8gR2V0IHRoZSBnYW1lIGNhbnZhcyBhbmQgZ2l2ZSBpdCBhIGJhY2tncm91bmQgY29sb3JcclxuICAgIHRoaXMuR0FNRV9DQU5WQVMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+KFxyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdhbWUtY2FudmFzXCIpXHJcbiAgICApO1xyXG4gICAgdGhpcy5ERUJVR19DQU5WQVMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+KFxyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlYnVnLWNhbnZhc1wiKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBHaXZlIHRoZSBjYW52YXMgYSBzaXplIGFuZCBnZXQgdGhlIHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICB0aGlzLldJRFRIID0gdGhpcy5nYW1lT3B0aW9ucy5jYW52YXNTaXplLng7XHJcbiAgICB0aGlzLkhFSUdIVCA9IHRoaXMuZ2FtZU9wdGlvbnMuY2FudmFzU2l6ZS55O1xyXG5cclxuICAgIC8vIFRoaXMgc3RlcCBNVVNUIGhhcHBlbiBiZWZvcmUgdGhlIHJlc291cmNlIG1hbmFnZXIgZG9lcyBhbnl0aGluZ1xyXG4gICAgaWYgKHRoaXMuZ2FtZU9wdGlvbnMudXNlV2ViR0wpIHtcclxuICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyID0gbmV3IFdlYkdMUmVuZGVyZXIoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IG5ldyBDYW52YXNSZW5kZXJlcigpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5pbml0aWFsaXplR2FtZVdpbmRvdygpO1xyXG4gICAgdGhpcy5jdHggPSB0aGlzLnJlbmRlcmluZ01hbmFnZXIuaW5pdGlhbGl6ZUNhbnZhcyhcclxuICAgICAgdGhpcy5HQU1FX0NBTlZBUyxcclxuICAgICAgdGhpcy5XSURUSCxcclxuICAgICAgdGhpcy5IRUlHSFQsXHJcbiAgICApO1xyXG4gICAgdGhpcy5jbGVhckNvbG9yID0gbmV3IENvbG9yKFxyXG4gICAgICB0aGlzLmdhbWVPcHRpb25zLmNsZWFyQ29sb3IucixcclxuICAgICAgdGhpcy5nYW1lT3B0aW9ucy5jbGVhckNvbG9yLmcsXHJcbiAgICAgIHRoaXMuZ2FtZU9wdGlvbnMuY2xlYXJDb2xvci5iLFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGRlYnVnZ2luZyBhbmQgc3RhdHNcclxuICAgIERlYnVnLmluaXRpYWxpemVEZWJ1Z0NhbnZhcyh0aGlzLkRFQlVHX0NBTlZBUywgdGhpcy5XSURUSCwgdGhpcy5IRUlHSFQpO1xyXG4gICAgU3RhdHMuaW5pdFN0YXRzKCk7XHJcblxyXG4gICAgaWYgKHRoaXMuZ2FtZU9wdGlvbnMuc2hvd1N0YXRzKSB7XHJcbiAgICAgIC8vIEZpbmQgdGhlIHN0YXRzIG91dHB1dCBhbmQgbWFrZSBpdCBubyBsb25nZXIgaGlkZGVuXHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdHNcIikuaGlkZGVuID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2l6ZSB0aGUgdmlld3BvcnQgdG8gdGhlIGdhbWUgY2FudmFzXHJcbiAgICBjb25zdCBjYW52YXNTaXplID0gbmV3IFZlYzIodGhpcy5XSURUSCwgdGhpcy5IRUlHSFQpO1xyXG4gICAgdGhpcy52aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChjYW52YXNTaXplLCB0aGlzLmdhbWVPcHRpb25zLnpvb21MZXZlbCk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBhbGwgbmVjZXNzYXJ5IGdhbWUgc3Vic3lzdGVtc1xyXG4gICAgdGhpcy5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgdGhpcy5pbnB1dEhhbmRsZXIgPSBuZXcgSW5wdXRIYW5kbGVyKHRoaXMuR0FNRV9DQU5WQVMpO1xyXG4gICAgSW5wdXQuaW5pdGlhbGl6ZSh0aGlzLnZpZXdwb3J0LCB0aGlzLmdhbWVPcHRpb25zLmlucHV0cyk7XHJcbiAgICB0aGlzLnJlY29yZGVyID0gbmV3IFJlY29yZGVyKCk7XHJcbiAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgdGhpcy5zY2VuZU1hbmFnZXIgPSBuZXcgU2NlbmVNYW5hZ2VyKHRoaXMudmlld3BvcnQsIHRoaXMucmVuZGVyaW5nTWFuYWdlcik7XHJcbiAgICB0aGlzLmF1ZGlvTWFuYWdlciA9IEF1ZGlvTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHVwIHRoZSBnYW1lIHdpbmRvdyB0aGF0IGhvbGRzIHRoZSBjYW52YXNlc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUdhbWVXaW5kb3coKTogdm9pZCB7XHJcbiAgICBjb25zdCBnYW1lV2luZG93ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnYW1lLXdpbmRvd1wiKTtcclxuXHJcbiAgICAvLyBTZXQgdGhlIGhlaWdodCBvZiB0aGUgZ2FtZSB3aW5kb3dcclxuICAgIGdhbWVXaW5kb3cuc3R5bGUud2lkdGggPSB0aGlzLldJRFRIICsgXCJweFwiO1xyXG4gICAgZ2FtZVdpbmRvdy5zdHlsZS5oZWlnaHQgPSB0aGlzLkhFSUdIVCArIFwicHhcIjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJlaXZlcyB0aGUgU2NlbmVNYW5hZ2VyIGZyb20gdGhlIEdhbWVcclxuICAgKiBAcmV0dXJucyBUaGUgU2NlbmVNYW5hZ2VyXHJcbiAgICovXHJcbiAgZ2V0U2NlbmVNYW5hZ2VyKCk6IFNjZW5lTWFuYWdlciB7XHJcbiAgICByZXR1cm4gdGhpcy5zY2VuZU1hbmFnZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgdGhlIGdhbWVcclxuICAgKi9cclxuICBzdGFydChcclxuICAgIEluaXRpYWxTY2VuZTogbmV3ICguLi5hcmdzOiBhbnkpID0+IFNjZW5lLFxyXG4gICAgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PixcclxuICApOiB2b2lkIHtcclxuICAgIC8vIFNldCB0aGUgdXBkYXRlIGZ1bmN0aW9uIG9mIHRoZSBsb29wXHJcbiAgICB0aGlzLmxvb3AuZG9VcGRhdGUgPSAoZGVsdGFUOiBudW1iZXIpID0+IHRoaXMudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgLy8gU2V0IHRoZSByZW5kZXIgZnVuY3Rpb24gb2YgdGhlIGxvb3BcclxuICAgIHRoaXMubG9vcC5kb1JlbmRlciA9ICgpID0+IHRoaXMucmVuZGVyKCk7XHJcblxyXG4gICAgLy8gUHJlbG9hZCByZWdpc3RyeSBpdGVtc1xyXG4gICAgUmVnaXN0cnlNYW5hZ2VyLnByZWxvYWQoKTtcclxuXHJcbiAgICAvLyBMb2FkIHRoZSBpdGVtcyB3aXRoIHRoZSByZXNvdXJjZSBtYW5hZ2VyXHJcbiAgICB0aGlzLnJlc291cmNlTWFuYWdlci5sb2FkUmVzb3VyY2VzRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgLy8gV2hlbiB3ZSdyZSBkb25lIGxvYWRpbmcsIHN0YXJ0IHRoZSBsb29wXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiRmluaXNoZWQgUHJlbG9hZCAtIGxvYWRpbmcgZmlyc3Qgc2NlbmVcIik7XHJcbiAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoSW5pdGlhbFNjZW5lLCB7fSwgb3B0aW9ucyk7XHJcbiAgICAgIHRoaXMubG9vcC5zdGFydCgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIGFsbCBuZWNlc3Nhcnkgc3Vic3lzdGVtcyBvZiB0aGUgZ2FtZS4gRGVmZXJzIHNjZW5lIHVwZGF0ZXMgdG8gdGhlIHNjZW5lTWFuYWdlclxyXG4gICAqIEBwYXJhbSBkZWx0YVQgVGhlIHRpbWUgc2luZSB0aGUgbGFzdCB1cGRhdGVcclxuICAgKi9cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEhhbmRsZSBhbGwgZXZlbnRzIHRoYXQgaGFwcGVuZWQgc2luY2UgdGhlIHN0YXJ0IG9mIHRoZSBsYXN0IGxvb3BcclxuICAgICAgdGhpcy5ldmVudFF1ZXVlLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBkYXRhIHN0cnVjdHVyZXMgc28gZ2FtZSBvYmplY3RzIGNhbiBzZWUgdGhlIGlucHV0XHJcbiAgICAgIElucHV0LnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSByZWNvcmRpbmcgb2YgdGhlIGdhbWVcclxuICAgICAgdGhpcy5yZWNvcmRlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBhbGwgc2NlbmVzXHJcbiAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIGFsbCBzb3VuZHNcclxuICAgICAgdGhpcy5hdWRpb01hbmFnZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAvLyBMb2FkIG9yIHVubG9hZCBhbnkgcmVzb3VyY2VzIGlmIG5lZWRlZFxyXG4gICAgICB0aGlzLnJlc291cmNlTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgdGhpcy5sb29wLnBhdXNlKCk7XHJcbiAgICAgIGNvbnNvbGUud2FybihcIlVuY2F1Z2h0IEVycm9yIGluIFVwZGF0ZSAtIENyYXNoaW5nIGdyYWNlZnVsbHlcIik7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhcnMgdGhlIGNhbnZhcyBhbmQgZGVmZXJzIHNjZW5lIHJlbmRlcmluZyB0byB0aGUgc2NlbmVNYW5hZ2VyLiBSZW5kZXJzIHRoZSBkZWJ1ZyBjYW52YXNcclxuICAgKi9cclxuICByZW5kZXIoKTogdm9pZCB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDbGVhciB0aGUgY2FudmFzZXNcclxuICAgICAgRGVidWcuY2xlYXJDYW52YXMoKTtcclxuXHJcbiAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlci5jbGVhcih0aGlzLmNsZWFyQ29sb3IpO1xyXG5cclxuICAgICAgdGhpcy5zY2VuZU1hbmFnZXIucmVuZGVyKCk7XHJcblxyXG4gICAgICAvLyBIYWNreSBkZWJ1ZyBtb2RlXHJcbiAgICAgIGlmIChJbnB1dC5pc0tleUp1c3RQcmVzc2VkKFwiZ1wiKSkge1xyXG4gICAgICAgIHRoaXMuc2hvd0RlYnVnID0gIXRoaXMuc2hvd0RlYnVnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZWJ1Zy5qc29uIHJlbmRlclxyXG4gICAgICBpZiAodGhpcy5zaG93RGVidWcpIHtcclxuICAgICAgICBEZWJ1Zy5yZW5kZXIoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuc2hvd1N0YXRzKSB7XHJcbiAgICAgICAgU3RhdHMucmVuZGVyKCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgdGhpcy5sb29wLnBhdXNlKCk7XHJcbiAgICAgIGNvbnNvbGUud2FybihcIlVuY2F1Z2h0IEVycm9yIGluIFJlbmRlciAtIENyYXNoaW5nIGdyYWNlZnVsbHlcIik7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBOdWxsRnVuYyBmcm9tIFwiLi4vRGF0YVR5cGVzL0Z1bmN0aW9ucy9OdWxsRnVuY1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBtYWluIGdhbWUgbG9vcCBvZiB0aGUgZ2FtZS4gS2VlcHMgdHJhY2sgb2YgZnBzIGFuZCBoYW5kbGVzIHNjaGVkdWxpbmcgb2YgdXBkYXRlcyBhbmQgcmVuZGVyaW5nLlxyXG4gKiBUaGlzIGNsYXNzIGlzIGxlZnQgYWJzdHJhY3QsIHNvIHRoYXQgYSBzdWJjbGFzcyBjYW4gaGFuZGxlIGV4YWN0bHkgaG93IHRoZSBsb29wIGlzIHNjaGVkdWxlZC5cclxuICogRm9yIGFuIGV4YW1wbGUgb2YgZGlmZmVyZW50IHR5cGVzIG9mIGdhbWUgbG9vcCBzY2hlZHVsaW5nLCBjaGVjayBvdXQgQGxpbmsoR2FtZSBQcm9ncmFtbWluZyBQYXR0ZXJucykoaHR0cHM6Ly9nYW1lcHJvZ3JhbW1pbmdwYXR0ZXJucy5jb20vZ2FtZS1sb29wLmh0bWwpXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBHYW1lTG9vcCB7XHJcbiAgLyoqIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYW4gdXBkYXRlIG9jY3VycyAqL1xyXG4gIHByb3RlY3RlZCBfZG9VcGRhdGU6IEZ1bmN0aW9uID0gTnVsbEZ1bmM7XHJcblxyXG4gIHNldCBkb1VwZGF0ZSh1cGRhdGU6IEZ1bmN0aW9uKSB7XHJcbiAgICB0aGlzLl9kb1VwZGF0ZSA9IHVwZGF0ZTtcclxuICB9XHJcblxyXG4gIC8qKiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgcmVuZGVyIG9jY3VycyAqL1xyXG4gIHByb3RlY3RlZCBfZG9SZW5kZXI6IEZ1bmN0aW9uID0gTnVsbEZ1bmM7XHJcblxyXG4gIHNldCBkb1JlbmRlcihyZW5kZXI6IEZ1bmN0aW9uKSB7XHJcbiAgICB0aGlzLl9kb1JlbmRlciA9IHJlbmRlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBGUFMgb2YgdGhlIGdhbWVcclxuICAgKi9cclxuICBhYnN0cmFjdCBnZXRGUFMoKTogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgdXAgdGhlIGdhbWUgbG9vcFxyXG4gICAqL1xyXG4gIGFic3RyYWN0IHN0YXJ0KCk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlcyB0aGUgZ2FtZSBsb29wLCB1c3VhbGx5IGZvciBhbiBlcnJvciBjb25kaXRpb24uXHJcbiAgICovXHJcbiAgYWJzdHJhY3QgcGF1c2UoKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzdW1lcyB0aGUgZ2FtZSBsb29wLlxyXG4gICAqL1xyXG4gIGFic3RyYWN0IHJlc3VtZSgpOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBSdW5zIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgZ2FtZS4gTm8gdXBkYXRlIG9jY3VycyBoZXJlLCBvbmx5IGEgcmVuZGVyLlxyXG4gICAqIFRoaXMgaXMgbmVlZGVkIHRvIGluaXRpYWxpemUgZGVsdGEgdGltZSB2YWx1ZXNcclxuICAgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lLiBUaGlzIGlzIHJlY2VpdmVkIGZyb20gdGhlIGJyb3dzZXJcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZG9GaXJzdEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogUnVuIGJlZm9yZSBhbnkgdXBkYXRlcyBvciB0aGUgcmVuZGVyIG9mIGEgZnJhbWUuXHJcbiAgICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIG9mIHRoZSBmcmFtZS4gVGhpcyBpcyByZWNlaXZlZCBmcm9tIHRoZSBicm93c2VyXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHN0YXJ0RnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgY29yZSBvZiB0aGUgZnJhbWUsIHdoZXJlIGFueSBuZWNlc3NhcnkgdXBkYXRlcyBvY2N1ciwgYW5kIHdoZXJlIGEgcmVuZGVyIGhhcHBlbnNcclxuICAgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lLiBUaGlzIGlzIHJlY2VpdmVkIGZyb20gdGhlIGJyb3dzZXJcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZG9GcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdyYXBzIHVwIHRoZSBmcmFtZVxyXG4gICAqIEBwYXJhbSBwYW5pYyBXaGV0aGVyIG9yIG5vdCB0aGUgdXBkYXRlIGN5Y2xlIHBhbmlja2VkLiBUaGlzIGhhcHBlbnMgd2hlbiB0b28gbWFueSB1cGRhdGVzIHRyeSB0byBoYXBwZW4gaW4gYSBzaW5nbGUgZnJhbWVcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZmluaXNoRnJhbWUocGFuaWM6IGJvb2xlYW4pOiB2b2lkO1xyXG59XHJcbiIsIi8vIEBpZ25vcmVQYWdlXHJcblxyXG4vKiogVGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyB0aGUgQHJlZmVyZW5jZVtHYW1lTG9vcF0gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZU9wdGlvbnMge1xyXG4gIC8qKiBUaGUgc2l6ZSBvZiB0aGUgdmlld3BvcnQgKi9cclxuICBjYW52YXNTaXplOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XHJcblxyXG4gIC8qIFRoZSBkZWZhdWx0IGxldmVsIG9mIHpvb20gKi9cclxuICB6b29tTGV2ZWw6IG51bWJlcjtcclxuXHJcbiAgLyoqIFRoZSBjb2xvciB0byBjbGVhciB0aGUgY2FudmFzIHRvIGVhY2ggZnJhbWUgKi9cclxuICBjbGVhckNvbG9yOiB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXIgfTtcclxuXHJcbiAgLyogQSBsaXN0IG9mIGlucHV0IGJpbmRpbmdzICovXHJcbiAgaW5wdXRzOiBBcnJheTx7IG5hbWU6IHN0cmluZzsga2V5czogQXJyYXk8c3RyaW5nPiB9PjtcclxuXHJcbiAgLyogV2hldGhlciBvciBub3QgdGhlIGRlYnVnIHJlbmRlcmluZyBzaG91bGQgb2NjdXIgKi9cclxuICBzaG93RGVidWc6IGJvb2xlYW47XHJcblxyXG4gIC8qIFdoZXRoZXIgb3Igbm90IHRoZSBzdGF0cyByZW5kZXJpbmcgc2hvdWxkIG9jY3VyICovXHJcbiAgc2hvd1N0YXRzOiBib29sZWFuO1xyXG5cclxuICAvKiBXaGV0aGVyIG9yIG5vdCB0byB1c2Ugd2ViR0wgKi9cclxuICB1c2VXZWJHTDogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2VzIHRoZSBkYXRhIGluIHRoZSByYXcgb3B0aW9ucyBvYmplY3RcclxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZ2FtZSBvcHRpb25zIGFzIGEgUmVjb3JkXHJcbiAgICogQHJldHVybnMgQSB2ZXJzaW9uIG9mIHRoZSBvcHRpb25zIGNvbnZlcnRlZCB0byBhIEdhbWVPcHRpb25zIG9iamVjdFxyXG4gICAqL1xyXG4gIHN0YXRpYyBwYXJzZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogR2FtZU9wdGlvbnMge1xyXG4gICAgbGV0IGdPcHQgPSBuZXcgR2FtZU9wdGlvbnMoKTtcclxuXHJcbiAgICBnT3B0LmNhbnZhc1NpemUgPSBvcHRpb25zLmNhbnZhc1NpemVcclxuICAgICAgPyBvcHRpb25zLmNhbnZhc1NpemVcclxuICAgICAgOiB7IHg6IDgwMCwgeTogNjAwIH07XHJcbiAgICBnT3B0Lnpvb21MZXZlbCA9IG9wdGlvbnMuem9vbUxldmVsID8gb3B0aW9ucy56b29tTGV2ZWwgOiAxO1xyXG4gICAgZ09wdC5jbGVhckNvbG9yID0gb3B0aW9ucy5jbGVhckNvbG9yXHJcbiAgICAgID8gb3B0aW9ucy5jbGVhckNvbG9yXHJcbiAgICAgIDogeyByOiAyNTUsIGc6IDI1NSwgYjogMjU1IH07XHJcbiAgICBnT3B0LmlucHV0cyA9IG9wdGlvbnMuaW5wdXRzID8gb3B0aW9ucy5pbnB1dHMgOiBbXTtcclxuICAgIGdPcHQuc2hvd0RlYnVnID0gISFvcHRpb25zLnNob3dEZWJ1ZztcclxuICAgIGdPcHQuc2hvd1N0YXRzID0gISFvcHRpb25zLnNob3dTdGF0cztcclxuICAgIGdPcHQudXNlV2ViR0wgPSAhIW9wdGlvbnMudXNlV2ViR0w7XHJcblxyXG4gICAgcmV0dXJuIGdPcHQ7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFJlZ2lvbiBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUmVnaW9uXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbiB0aGUgZ2FtZSB3b3JsZCB0aGF0IGNhbiBiZSBkcmF3biB0byB0aGUgc2NyZWVuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBDYW52YXNOb2RlIGV4dGVuZHMgR2FtZU5vZGUgaW1wbGVtZW50cyBSZWdpb24ge1xyXG4gIHByaXZhdGUgX3NpemU6IFZlYzI7XHJcbiAgcHJpdmF0ZSBfc2NhbGU6IFZlYzI7XHJcbiAgcHJpdmF0ZSBfYm91bmRhcnk6IEFBQkI7XHJcbiAgcHJpdmF0ZSBfaGFzQ3VzdG9tU2hhZGVyOiBib29sZWFuO1xyXG4gIHByaXZhdGUgX2N1c3RvbVNoYWRlcktleTogc3RyaW5nO1xyXG4gIHByaXZhdGUgX2FscGhhOiBudW1iZXI7XHJcblxyXG4gIC8qKiBBIGZsYWcgZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBDYW52YXNOb2RlIGlzIHZpc2libGUgKi9cclxuICB2aXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5fc2l6ZSA9IG5ldyBWZWMyKDAsIDApO1xyXG4gICAgdGhpcy5fc2l6ZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNpemVDaGFuZ2VkKCkpO1xyXG4gICAgdGhpcy5fc2NhbGUgPSBuZXcgVmVjMigxLCAxKTtcclxuICAgIHRoaXMuX3NjYWxlLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2NhbGVDaGFuZ2VkKCkpO1xyXG4gICAgdGhpcy5fYm91bmRhcnkgPSBuZXcgQUFCQigpO1xyXG4gICAgdGhpcy51cGRhdGVCb3VuZGFyeSgpO1xyXG5cclxuICAgIHRoaXMuX2hhc0N1c3RvbVNoYWRlciA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGFscGhhKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fYWxwaGE7XHJcbiAgfVxyXG5cclxuICBzZXQgYWxwaGEoYTogbnVtYmVyKSB7XHJcbiAgICB0aGlzLl9hbHBoYSA9IGE7XHJcbiAgfVxyXG5cclxuICBnZXQgc2l6ZSgpOiBWZWMyIHtcclxuICAgIHJldHVybiB0aGlzLl9zaXplO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNpemUoc2l6ZTogVmVjMikge1xyXG4gICAgdGhpcy5fc2l6ZSA9IHNpemU7XHJcbiAgICAvLyBFbnRlciBhcyBhIGxhbWJkYSB0byBiaW5kIFwidGhpc1wiXHJcbiAgICB0aGlzLl9zaXplLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2l6ZUNoYW5nZWQoKSk7XHJcbiAgICB0aGlzLnNpemVDaGFuZ2VkKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgc2NhbGUoKTogVmVjMiB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2NhbGU7XHJcbiAgfVxyXG5cclxuICBzZXQgc2NhbGUoc2NhbGU6IFZlYzIpIHtcclxuICAgIHRoaXMuX3NjYWxlID0gc2NhbGU7XHJcbiAgICAvLyBFbnRlciBhcyBhIGxhbWJkYSB0byBiaW5kIFwidGhpc1wiXHJcbiAgICB0aGlzLl9zY2FsZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNjYWxlQ2hhbmdlZCgpKTtcclxuICAgIHRoaXMuc2NhbGVDaGFuZ2VkKCk7XHJcbiAgfVxyXG5cclxuICBzZXQgc2NhbGVYKHZhbHVlOiBudW1iZXIpIHtcclxuICAgIHRoaXMuc2NhbGUueCA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNjYWxlWSh2YWx1ZTogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIGdldCBoYXNDdXN0b21TaGFkZXIoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5faGFzQ3VzdG9tU2hhZGVyO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1c3RvbVNoYWRlcktleSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuX2N1c3RvbVNoYWRlcktleTtcclxuICB9XHJcblxyXG4gIC8vIEBvdmVycmlkZVxyXG4gIHByb3RlY3RlZCBwb3NpdGlvbkNoYW5nZWQoKTogdm9pZCB7XHJcbiAgICBzdXBlci5wb3NpdGlvbkNoYW5nZWQoKTtcclxuICAgIHRoaXMudXBkYXRlQm91bmRhcnkoKTtcclxuICB9XHJcblxyXG4gIC8qKiBDYWxsZWQgaWYgdGhlIHNpemUgdmVjdG9yIGlzIGNoYW5nZWQgb3IgcmVwbGFjZWQuICovXHJcbiAgcHJvdGVjdGVkIHNpemVDaGFuZ2VkKCk6IHZvaWQge1xyXG4gICAgdGhpcy51cGRhdGVCb3VuZGFyeSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqIENhbGxlZCBpZiB0aGUgc2NhbGUgdmVjdG9yIGlzIGNoYW5nZWQgb3IgcmVwbGFjZWQgKi9cclxuICBwcm90ZWN0ZWQgc2NhbGVDaGFuZ2VkKCk6IHZvaWQge1xyXG4gICAgdGhpcy51cGRhdGVCb3VuZGFyeSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGRvY0lnbm9yZVxyXG4gIC8qKiBDYWxsZWQgaWYgdGhlIHBvc2l0aW9uLCBzaXplLCBvciBzY2FsZSBvZiB0aGUgQ2FudmFzTm9kZSBpcyBjaGFuZ2VkLiBVcGRhdGVzIHRoZSBib3VuZGFyeS4gKi9cclxuICBwcml2YXRlIHVwZGF0ZUJvdW5kYXJ5KCk6IHZvaWQge1xyXG4gICAgdGhpcy5fYm91bmRhcnkuY2VudGVyLnNldCh0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSk7XHJcbiAgICB0aGlzLl9ib3VuZGFyeS5oYWxmU2l6ZS5zZXQoXHJcbiAgICAgICh0aGlzLnNpemUueCAqIHRoaXMuc2NhbGUueCkgLyAyLFxyXG4gICAgICAodGhpcy5zaXplLnkgKiB0aGlzLnNjYWxlLnkpIC8gMixcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBnZXQgYm91bmRhcnkoKTogQUFCQiB7XHJcbiAgICByZXR1cm4gdGhpcy5fYm91bmRhcnk7XHJcbiAgfVxyXG5cclxuICBnZXQgc2l6ZVdpdGhab29tKCk6IFZlYzIge1xyXG4gICAgbGV0IHpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmJvdW5kYXJ5LmhhbGZTaXplLmNsb25lKCkuc2NhbGVkKHpvb20sIHpvb20pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIGN1c3RvbSBzaGFkZXIgdG8gdGhpcyBDYW52YXNOb2RlXHJcbiAgICogQHBhcmFtIGtleSBUaGUgcmVnaXN0cnkga2V5IG9mIHRoZSBTaGFkZXJUeXBlXHJcbiAgICovXHJcbiAgdXNlQ3VzdG9tU2hhZGVyKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLl9oYXNDdXN0b21TaGFkZXIgPSB0cnVlO1xyXG4gICAgdGhpcy5fY3VzdG9tU2hhZGVyS2V5ID0ga2V5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCAoeCwgeSkgaXMgaW5zaWRlIG9mIHRoaXMgY2FudmFzIG9iamVjdFxyXG4gICAqIEBwYXJhbSB4IFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxyXG4gICAqIEBwYXJhbSB5IFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxyXG4gICAqIEByZXR1cm5zIEEgZmxhZyByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhpcyBub2RlIGNvbnRhaW5zIHRoZSBwb2ludC5cclxuICAgKi9cclxuICBjb250YWlucyh4OiBudW1iZXIsIHk6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2JvdW5kYXJ5LmNvbnRhaW5zUG9pbnQobmV3IFZlYzIoeCwgeSkpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGltcGxlbWVudGVkXHJcbiAgZGVidWdSZW5kZXIoKTogdm9pZCB7XHJcbiAgICBEZWJ1Zy5kcmF3Qm94KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgdGhpcy5zaXplV2l0aFpvb20sIGZhbHNlLCBDb2xvci5CTFVFKTtcclxuICAgIHN1cGVyLmRlYnVnUmVuZGVyKCk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVyXCI7XHJcbmltcG9ydCBBSSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQUlcIjtcclxuaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9QaHlzaWNhbFwiO1xyXG5pbXBvcnQgUG9zaXRpb25lZCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUG9zaXRpb25lZFwiO1xyXG5pbXBvcnQgeyBpc1JlZ2lvbiB9IGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9SZWdpb25cIjtcclxuaW1wb3J0IFVuaXF1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVW5pcXVlXCI7XHJcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XHJcbmltcG9ydCBEZWJ1Z1JlbmRlcmFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0RlYnVnUmVuZGVyYWJsZVwiO1xyXG5pbXBvcnQgQWN0b3IgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FjdG9yXCI7XHJcbmltcG9ydCBTaGFwZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9TaGFwZVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi4vUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGhcIjtcclxuaW1wb3J0IFR3ZWVuQ29udHJvbGxlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5Db250cm9sbGVyXCI7XHJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgQ2lyY2xlIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0NpcmNsZVwiO1xyXG5pbXBvcnQgR29hcEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Hb2FwQUlcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGluIHRoZSBnYW1lIHdvcmxkLlxyXG4gKiBUbyBjb25zdHJ1Y3QgR2FtZU5vZGVzLCBzZWUgdGhlIEByZWZlcmVuY2VbU2NlbmVdIGRvY3VtZW50YXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBHYW1lTm9kZVxyXG4gIGltcGxlbWVudHMgUG9zaXRpb25lZCwgVW5pcXVlLCBVcGRhdGVhYmxlLCBQaHlzaWNhbCwgQWN0b3IsIERlYnVnUmVuZGVyYWJsZVxyXG57XHJcbiAgLyotLS0tLS0tLS0tIFBPU0lUSU9ORUQgLS0tLS0tLS0tLSovXHJcbiAgcHJpdmF0ZSBfcG9zaXRpb246IFZlYzI7XHJcblxyXG4gIC8qLS0tLS0tLS0tLSBVTklRVUUgLS0tLS0tLS0tLSovXHJcbiAgcHJpdmF0ZSBfaWQ6IG51bWJlcjtcclxuXHJcbiAgLyotLS0tLS0tLS0tIFBIWVNJQ0FMIC0tLS0tLS0tLS0qL1xyXG4gIGhhc1BoeXNpY3M6IGJvb2xlYW4gPSBmYWxzZTtcclxuICBtb3Zpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICBmcm96ZW46IGJvb2xlYW4gPSBmYWxzZTtcclxuICBvbkdyb3VuZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gIG9uV2FsbDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gIG9uQ2VpbGluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gIGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gIGNvbGxpc2lvblNoYXBlOiBTaGFwZTtcclxuICBjb2xsaWRlck9mZnNldDogVmVjMjtcclxuICBpc1N0YXRpYzogYm9vbGVhbjtcclxuICBpc0NvbGxpZGFibGU6IGJvb2xlYW47XHJcbiAgaXNUcmlnZ2VyOiBib29sZWFuO1xyXG4gIHRyaWdnZXJNYXNrOiBudW1iZXI7XHJcbiAgdHJpZ2dlckVudGVyczogQXJyYXk8c3RyaW5nPjtcclxuICB0cmlnZ2VyRXhpdHM6IEFycmF5PHN0cmluZz47XHJcbiAgX3ZlbG9jaXR5OiBWZWMyO1xyXG4gIHN3ZXB0UmVjdDogQUFCQjtcclxuICBjb2xsaWRlZFdpdGhUaWxlbWFwOiBib29sZWFuO1xyXG4gIGdyb3VwOiBudW1iZXI7XHJcbiAgaXNQbGF5ZXI6IGJvb2xlYW47XHJcbiAgaXNDb2xsaWRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgLyotLS0tLS0tLS0tIEFDVE9SIC0tLS0tLS0tLS0qL1xyXG4gIF9haTogQUkgfCBHb2FwQUk7XHJcbiAgYWlBY3RpdmU6IGJvb2xlYW47XHJcbiAgcGF0aDogTmF2aWdhdGlvblBhdGg7XHJcbiAgcGF0aGZpbmRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgLyotLS0tLS0tLS0tIEdFTkVSQUwgLS0tLS0tLS0tLSovXHJcbiAgLyoqIEFuIGV2ZW50IHJlY2VpdmVyLiAqL1xyXG4gIHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XHJcbiAgLyoqIEFuIGV2ZW50IGVtaXR0ZXIuICovXHJcbiAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcbiAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBzY2VuZSB0aGlzIEdhbWVOb2RlIGlzIGEgcGFydCBvZi4gKi9cclxuICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xyXG4gIC8qKiBUaGUgdmlzdWFsIGxheWVyIHRoaXMgR2FtZU5vZGUgcmVzaWRlcyBpbi4gKi9cclxuICBwcm90ZWN0ZWQgbGF5ZXI6IExheWVyO1xyXG4gIC8qKiBBIHV0aWxpdHkgdGhhdCBhbGxvd3MgdGhlIHVzZSBvZiB0d2VlbnMgb24gdGhpcyBHYW1lTm9kZSAqL1xyXG4gIHR3ZWVuczogVHdlZW5Db250cm9sbGVyO1xyXG4gIC8qKiBBIHR3ZWVuYWJsZSBwcm9wZXJ0eSBmb3Igcm90YXRpb24uIERvZXMgbm90IGFmZmVjdCB0aGUgYm91bmRpbmcgYm94IG9mIHRoaXMgR2FtZU5vZGUgLSBPbmx5IHJlbmRlcmluZy4gKi9cclxuICByb3RhdGlvbjogbnVtYmVyO1xyXG4gIC8qKiBUaGUgb3BhY2l0eSB2YWx1ZSBvZiB0aGlzIEdhbWVOb2RlICovXHJcbiAgYWJzdHJhY3Qgc2V0IGFscGhhKGE6IG51bWJlcik7XHJcblxyXG4gIGFic3RyYWN0IGdldCBhbHBoYSgpOiBudW1iZXI7XHJcblxyXG4gIC8vIENvbnN0cnVjdG9yIGRvY3MgYXJlIGlnbm9yZWQsIGFzIHRoZSB1c2VyIHNob3VsZCBOT1QgY3JlYXRlIG5ldyBHYW1lTm9kZXMgd2l0aCBhIHJhdyBjb25zdHJ1Y3RvclxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5fcG9zaXRpb24gPSBuZXcgVmVjMigwLCAwKTtcclxuICAgIHRoaXMuX3Bvc2l0aW9uLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMucG9zaXRpb25DaGFuZ2VkKCkpO1xyXG4gICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xyXG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuICAgIHRoaXMudHdlZW5zID0gbmV3IFR3ZWVuQ29udHJvbGxlcih0aGlzKTtcclxuICAgIHRoaXMucm90YXRpb24gPSAwO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMudHdlZW5zLmRlc3Ryb3koKTtcclxuICAgIHRoaXMucmVjZWl2ZXIuZGVzdHJveSgpO1xyXG5cclxuICAgIGlmICh0aGlzLmhhc1BoeXNpY3MpIHtcclxuICAgICAgdGhpcy5yZW1vdmVQaHlzaWNzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2FpKSB7XHJcbiAgICAgIHRoaXMuX2FpLmRlc3Ryb3koKTtcclxuICAgICAgZGVsZXRlIHRoaXMuX2FpO1xyXG4gICAgICB0aGlzLnNjZW5lLmdldEFJTWFuYWdlcigpLnJlbW92ZUFjdG9yKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubGF5ZXIucmVtb3ZlTm9kZSh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qLS0tLS0tLS0tLSBQT1NJVElPTkVEIC0tLS0tLS0tLS0qL1xyXG4gIGdldCBwb3NpdGlvbigpOiBWZWMyIHtcclxuICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIHNldCBwb3NpdGlvbihwb3M6IFZlYzIpIHtcclxuICAgIHRoaXMuX3Bvc2l0aW9uID0gcG9zO1xyXG4gICAgdGhpcy5fcG9zaXRpb24uc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5wb3NpdGlvbkNoYW5nZWQoKSk7XHJcbiAgICB0aGlzLnBvc2l0aW9uQ2hhbmdlZCgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHJlbGF0aXZlUG9zaXRpb24oKTogVmVjMiB7XHJcbiAgICByZXR1cm4gdGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5wb3NpdGlvbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0cyBhIHBvaW50IHRvIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSB6b29tIGFuZCBvcmlnaW4gb2YgdGhpcyBub2RlXHJcbiAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjb252ZXJcclxuICAgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHJlcHJlc2VudGluZyB0aGUgcG9pbnQgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcclxuICAgKi9cclxuICBpblJlbGF0aXZlQ29vcmRpbmF0ZXMocG9pbnQ6IFZlYzIpOiBWZWMyIHtcclxuICAgIGxldCBvcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbih0aGlzKTtcclxuICAgIGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcclxuICAgIHJldHVybiBwb2ludC5jbG9uZSgpLnN1YihvcmlnaW4pLnNjYWxlKHpvb20pO1xyXG4gIH1cclxuXHJcbiAgLyotLS0tLS0tLS0tIFVOSVFVRSAtLS0tLS0tLS0tKi9cclxuICBnZXQgaWQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLl9pZDtcclxuICB9XHJcblxyXG4gIHNldCBpZChpZDogbnVtYmVyKSB7XHJcbiAgICAvLyBpZCBjYW4gb25seSBiZSBzZXQgb25jZVxyXG4gICAgaWYgKHRoaXMuX2lkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5faWQgPSBpZDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IFwiQXR0ZW1wdGVkIHRvIGFzc2lnbiBpZCB0byBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBpZC5cIjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qLS0tLS0tLS0tLSBQSFlTSUNBTCAtLS0tLS0tLS0tKi9cclxuICAvLyBAaW1wbGVtZW50ZWRcclxuICAvKipcclxuICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIHZlbG9jaXR5IHdpdGggd2hpY2ggdG8gbW92ZSB0aGUgb2JqZWN0LlxyXG4gICAqL1xyXG4gIG1vdmUodmVsb2NpdHk6IFZlYzIpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmZyb3plbikgcmV0dXJuO1xyXG4gICAgdGhpcy5tb3ZpbmcgPSB0cnVlO1xyXG4gICAgdGhpcy5fdmVsb2NpdHkgPSB2ZWxvY2l0eTtcclxuICB9XHJcblxyXG4gIG1vdmVPblBhdGgoc3BlZWQ6IG51bWJlciwgcGF0aDogTmF2aWdhdGlvblBhdGgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmZyb3plbikgcmV0dXJuO1xyXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgIGxldCBkaXIgPSBwYXRoLmdldE1vdmVEaXJlY3Rpb24odGhpcyk7XHJcbiAgICB0aGlzLm1vdmluZyA9IHRydWU7XHJcbiAgICB0aGlzLnBhdGhmaW5kaW5nID0gdHJ1ZTtcclxuICAgIHRoaXMuX3ZlbG9jaXR5ID0gZGlyLnNjYWxlKHNwZWVkKTtcclxuICB9XHJcblxyXG4gIC8vIEBpbXBsZW1lbnRlZFxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB2ZWxvY2l0eSBUaGUgdmVsb2NpdHkgd2l0aCB3aGljaCB0aGUgb2JqZWN0IHdpbGwgbW92ZS5cclxuICAgKi9cclxuICBmaW5pc2hNb3ZlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5tb3ZpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMucG9zaXRpb24uYWRkKHRoaXMuX3ZlbG9jaXR5KTtcclxuICAgIGlmICh0aGlzLnBhdGhmaW5kaW5nKSB7XHJcbiAgICAgIHRoaXMucGF0aC5oYW5kbGVQYXRoUHJvZ3Jlc3ModGhpcyk7XHJcbiAgICAgIHRoaXMucGF0aCA9IG51bGw7XHJcbiAgICAgIHRoaXMucGF0aGZpbmRpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEBpbXBsZW1lbnRlZFxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBjb2xsaXNpb25TaGFwZSBUaGUgY29sbGlkZXIgZm9yIHRoaXMgb2JqZWN0LiBJZiB0aGlzIGhhcyBhIHJlZ2lvbiAoaW1wbGVtZW50cyBSZWdpb24pLFxyXG4gICAqIGl0IHdpbGwgYmUgdXNlZCB3aGVuIG5vIGNvbGxpc2lvbiBzaGFwZSBpcyBzcGVjaWZpZWQgKG9yIGlmIGNvbGxpc2lvbiBzaGFwZSBpcyBudWxsKS5cclxuICAgKiBAcGFyYW0gaXNDb2xsaWRhYmxlIFdoZXRoZXIgdGhpcyBpcyBjb2xsaWRhYmxlIG9yIG5vdC4gVHJ1ZSBieSBkZWZhdWx0LlxyXG4gICAqIEBwYXJhbSBpc1N0YXRpYyBXaGV0aGVyIHRoaXMgaXMgc3RhdGljIG9yIG5vdC4gRmFsc2UgYnkgZGVmYXVsdFxyXG4gICAqL1xyXG4gIGFkZFBoeXNpY3MoXHJcbiAgICBjb2xsaXNpb25TaGFwZT86IFNoYXBlLFxyXG4gICAgY29sbGlkZXJPZmZzZXQ/OiBWZWMyLFxyXG4gICAgaXNDb2xsaWRhYmxlOiBib29sZWFuID0gdHJ1ZSxcclxuICAgIGlzU3RhdGljOiBib29sZWFuID0gZmFsc2UsXHJcbiAgKTogdm9pZCB7XHJcbiAgICAvLyBJbml0aWFsaXplIHRoZSBwaHlzaWNzIHZhcmlhYmxlc1xyXG4gICAgdGhpcy5oYXNQaHlzaWNzID0gdHJ1ZTtcclxuICAgIHRoaXMubW92aW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLm9uR3JvdW5kID0gZmFsc2U7XHJcbiAgICB0aGlzLm9uV2FsbCA9IGZhbHNlO1xyXG4gICAgdGhpcy5vbkNlaWxpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICAgIHRoaXMuaXNDb2xsaWRhYmxlID0gaXNDb2xsaWRhYmxlO1xyXG4gICAgdGhpcy5pc1N0YXRpYyA9IGlzU3RhdGljO1xyXG4gICAgdGhpcy5pc1RyaWdnZXIgPSBmYWxzZTtcclxuICAgIHRoaXMudHJpZ2dlck1hc2sgPSAwO1xyXG4gICAgdGhpcy50cmlnZ2VyRW50ZXJzID0gbmV3IEFycmF5KDMyKTtcclxuICAgIHRoaXMudHJpZ2dlckV4aXRzID0gbmV3IEFycmF5KDMyKTtcclxuICAgIHRoaXMuX3ZlbG9jaXR5ID0gVmVjMi5aRVJPO1xyXG4gICAgdGhpcy5zd2VwdFJlY3QgPSBuZXcgQUFCQigpO1xyXG4gICAgdGhpcy5jb2xsaWRlZFdpdGhUaWxlbWFwID0gZmFsc2U7XHJcbiAgICB0aGlzLmdyb3VwID0gLTE7IC8vIFRoZSBkZWZhdWx0IGdyb3VwLCBjb2xsaWRlcyB3aXRoIGV2ZXJ5dGhpbmdcclxuXHJcbiAgICAvLyBTZXQgdGhlIGNvbGxpc2lvbiBzaGFwZSBpZiBwcm92aWRlZCwgb3Igc2ltcGx5IHVzZSB0aGUgdGhlIHJlZ2lvbiBpZiB0aGVyZSBpcyBvbmUuXHJcbiAgICBpZiAoY29sbGlzaW9uU2hhcGUpIHtcclxuICAgICAgdGhpcy5jb2xsaXNpb25TaGFwZSA9IGNvbGxpc2lvblNoYXBlO1xyXG4gICAgICB0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb247XHJcbiAgICB9IGVsc2UgaWYgKGlzUmVnaW9uKHRoaXMpKSB7XHJcbiAgICAgIC8vIElmIHRoZSBnYW1lbm9kZSBoYXMgYSByZWdpb24gYW5kIG5vIG90aGVyIGlzIHNwZWNpZmllZCwgdXNlIHRoYXRcclxuICAgICAgdGhpcy5jb2xsaXNpb25TaGFwZSA9ICg8YW55PnRoaXMpLmJvdW5kYXJ5LmNsb25lKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBcIk5vIGNvbGxpc2lvbiBzaGFwZSBzcGVjaWZpZWQgZm9yIHBoeXNpY3Mgb2JqZWN0LlwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHdlIHdlcmUgcHJvdmlkZWQgd2l0aCBhIGNvbGxpZGVyIG9mZnNldCwgc2V0IGl0LiBPdGhlcndpc2UgdGhlcmUgaXMgbm8gb2Zmc2V0LCBzbyB1c2UgdGhlIHplcm8gdmVjdG9yXHJcbiAgICBpZiAoY29sbGlkZXJPZmZzZXQpIHtcclxuICAgICAgdGhpcy5jb2xsaWRlck9mZnNldCA9IGNvbGxpZGVyT2Zmc2V0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5jb2xsaWRlck9mZnNldCA9IFZlYzIuWkVSTztcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHRoZSBzd2VwdCByZWN0XHJcbiAgICB0aGlzLnN3ZXB0UmVjdCA9IHRoaXMuY29sbGlzaW9uU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcblxyXG4gICAgLy8gUmVnaXN0ZXIgdGhlIG9iamVjdCB3aXRoIHBoeXNpY3NcclxuICAgIHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5yZWdpc3Rlck9iamVjdCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKiBSZW1vdmVzIHRoaXMgb2JqZWN0IGZyb20gdGhlIHBoeXNpY3Mgc3lzdGVtICovXHJcbiAgcmVtb3ZlUGh5c2ljcygpOiB2b2lkIHtcclxuICAgIC8vIFJlbW92ZSB0aGlzIGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlclxyXG4gICAgdGhpcy5zY2VuZS5nZXRQaHlzaWNzTWFuYWdlcigpLmRlcmVnaXN0ZXJPYmplY3QodGhpcyk7XHJcblxyXG4gICAgLy8gTnVsbGlmeSBhbGwgcGh5c2ljcyBmaWVsZHNcclxuICAgIHRoaXMuaGFzUGh5c2ljcyA9IGZhbHNlO1xyXG4gICAgdGhpcy5tb3ZpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMub25Hcm91bmQgPSBmYWxzZTtcclxuICAgIHRoaXMub25XYWxsID0gZmFsc2U7XHJcbiAgICB0aGlzLm9uQ2VpbGluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgIHRoaXMuaXNDb2xsaWRhYmxlID0gZmFsc2U7XHJcbiAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XHJcbiAgICB0aGlzLmlzVHJpZ2dlciA9IGZhbHNlO1xyXG4gICAgdGhpcy50cmlnZ2VyTWFzayA9IDA7XHJcbiAgICB0aGlzLnRyaWdnZXJFbnRlcnMgPSBudWxsO1xyXG4gICAgdGhpcy50cmlnZ2VyRXhpdHMgPSBudWxsO1xyXG4gICAgdGhpcy5fdmVsb2NpdHkgPSBWZWMyLlpFUk87XHJcbiAgICB0aGlzLnN3ZXB0UmVjdCA9IG51bGw7XHJcbiAgICB0aGlzLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSBmYWxzZTtcclxuICAgIHRoaXMuZ3JvdXAgPSAtMTtcclxuICAgIHRoaXMuY29sbGlzaW9uU2hhcGUgPSBudWxsO1xyXG4gICAgdGhpcy5jb2xsaWRlck9mZnNldCA9IFZlYzIuWkVSTztcclxuICAgIHRoaXMuc3dlcHRSZWN0ID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKiBEaXNhYmxlcyBwaHlzaWNzIG1vdmVtZW50IGZvciB0aGlzIG5vZGUgKi9cclxuICBmcmVlemUoKTogdm9pZCB7XHJcbiAgICB0aGlzLmZyb3plbiA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKiogUmVlbmFibGVzIHBoeXNpY3MgbW92ZW1lbnQgZm9yIHRoaXMgbm9kZSAqL1xyXG4gIHVuZnJlZXplKCk6IHZvaWQge1xyXG4gICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKiBQcmV2ZW50cyB0aGlzIG9iamVjdCBmcm9tIHBhcnRpY2lwYXRpbmcgaW4gYWxsIGNvbGxpc2lvbnMgYW5kIHRyaWdnZXJzLiBJdCBjYW4gc3RpbGwgbW92ZS4gKi9cclxuICBkaXNhYmxlUGh5c2ljcygpOiB2b2lkIHtcclxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKiogRW5hYmxlcyB0aGlzIG9iamVjdCB0byBwYXJ0aWNpcGF0ZSBpbiBjb2xsaXNpb25zIGFuZCB0cmlnZ2Vycy4gVGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBkaXNhYmxlUGh5c2ljcyB3YXMgY2FsbGVkICovXHJcbiAgZW5hYmxlUGh5c2ljcygpOiB2b2lkIHtcclxuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGNvbGxpZGVyIGZvciB0aGlzIEdhbWVOb2RlXHJcbiAgICogQHBhcmFtIGNvbGxpZGVyIFRoZSBuZXcgY29sbGlkZXIgdG8gdXNlXHJcbiAgICovXHJcbiAgc2V0Q29sbGlzaW9uU2hhcGUoY29sbGlkZXI6IFNoYXBlKTogdm9pZCB7XHJcbiAgICB0aGlzLmNvbGxpc2lvblNoYXBlID0gY29sbGlkZXI7XHJcbiAgICB0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlci5jb3B5KHRoaXMucG9zaXRpb24pO1xyXG4gIH1cclxuXHJcbiAgLy8gQGltcGxlbWVudGVkXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGlzIG9iamVjdCB0byBiZSBhIHRyaWdnZXIgZm9yIGEgc3BlY2lmaWMgZ3JvdXBcclxuICAgKiBAcGFyYW0gZ3JvdXAgVGhlIG5hbWUgb2YgdGhlIGdyb3VwIHRoYXQgYWN0aXZhdGVzIHRoZSB0cmlnZ2VyXHJcbiAgICogQHBhcmFtIG9uRW50ZXIgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHNlbmQgd2hlbiB0aGlzIHRyaWdnZXIgaXMgYWN0aXZhdGVkXHJcbiAgICogQHBhcmFtIG9uRXhpdCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc2VuZCB3aGVuIHRoaXMgdHJpZ2dlciBzdG9wcyBiZWluZyBhY3RpdmF0ZWRcclxuICAgKi9cclxuICBzZXRUcmlnZ2VyKGdyb3VwOiBzdHJpbmcsIG9uRW50ZXI6IHN0cmluZywgb25FeGl0OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIC8vIE1ha2UgdGhpcyBvYmplY3QgYSB0cmlnZ2VyXHJcbiAgICB0aGlzLmlzVHJpZ2dlciA9IHRydWU7XHJcblxyXG4gICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgdGhlIHBoeXNpY3MgbGF5ZXJcclxuICAgIGxldCBsYXllck51bWJlciA9IHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5nZXRHcm91cE51bWJlcihncm91cCk7XHJcblxyXG4gICAgaWYgKGxheWVyTnVtYmVyID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgVHJpZ2dlciBmb3IgR2FtZU5vZGUgJHt0aGlzLmlkfSBub3Qgc2V0IC0gZ3JvdXAgXCIke2dyb3VwfVwiIHdhcyBub3QgcmVjb2duaXplZCBieSB0aGUgcGh5c2ljcyBtYW5hZ2VyLmAsXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGhpcyB0byB0aGUgdHJpZ2dlciBtYXNrXHJcbiAgICB0aGlzLnRyaWdnZXJNYXNrIHw9IGxheWVyTnVtYmVyO1xyXG5cclxuICAgIC8vIExheWVyIG51bWJlcnMgYXJlIGJpdHMsIHNvIGdldCB3aGljaCBiaXQgaXQgaXNcclxuICAgIGxldCBpbmRleCA9IE1hdGgubG9nMihsYXllck51bWJlcik7XHJcblxyXG4gICAgLy8gU2V0IHRoZSBldmVudCBuYW1lc1xyXG4gICAgdGhpcy50cmlnZ2VyRW50ZXJzW2luZGV4XSA9IG9uRW50ZXI7XHJcbiAgICB0aGlzLnRyaWdnZXJFeGl0c1tpbmRleF0gPSBvbkV4aXQ7XHJcbiAgfVxyXG5cclxuICAvLyBAaW1wbGVtZW50ZWRcclxuICAvKipcclxuICAgKiBAcGFyYW0gZ3JvdXAgVGhlIHBoeXNpY3MgZ3JvdXAgdGhpcyBub2RlIHNob3VsZCBiZWxvbmcgdG9cclxuICAgKi9cclxuICBzZXRHcm91cChncm91cDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkuc2V0R3JvdXAodGhpcywgZ3JvdXApO1xyXG4gIH1cclxuXHJcbiAgLy8gQGltcGxlbWVuZWRcclxuICBnZXRMYXN0VmVsb2NpdHkoKTogVmVjMiB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmVsb2NpdHk7XHJcbiAgfVxyXG5cclxuICAvKi0tLS0tLS0tLS0gQUNUT1IgLS0tLS0tLS0tLSovXHJcbiAgZ2V0IGFpKCk6IEFJIHwgR29hcEFJIHtcclxuICAgIHJldHVybiB0aGlzLl9haTtcclxuICB9XHJcblxyXG4gIHNldCBhaShhaTogQUkgfCBHb2FwQUkpIHtcclxuICAgIGlmICghdGhpcy5fYWkpIHtcclxuICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBiZWVuIHByZXZpb3VzbHkgaGFkIGFuIGFpLCByZWdpc3RlciB1cyB3aXRoIHRoZSBhaSBtYW5hZ2VyXHJcbiAgICAgIHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkucmVnaXN0ZXJBY3Rvcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9haSA9IGFpO1xyXG4gICAgdGhpcy5haUFjdGl2ZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBAaW1wbGVtZW50ZWRcclxuICBhZGRBSTxUIGV4dGVuZHMgQUkgfCBHb2FwQUk+KFxyXG4gICAgYWk6IHN0cmluZyB8IChuZXcgKCkgPT4gVCksXHJcbiAgICBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55PixcclxuICAgIHR5cGU/OiBudW1iZXIsXHJcbiAgKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuX2FpKSB7XHJcbiAgICAgIHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkucmVnaXN0ZXJBY3Rvcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGFpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIHRoaXMuX2FpID0gdGhpcy5zY2VuZS5nZXRBSU1hbmFnZXIoKS5nZW5lcmF0ZUFJKGFpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2FpID0gbmV3IGFpKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUXVlc3Rpb24sIGhvdyBtdWNoIGRvIHdlIHdhbnQgZGlmZmVyZW50IHR5cGUgb2YgQUkgdG8gYmUgaGFuZGxlZCB0aGUgc2FtZSwgaS5lLiBzaG91bGQgR29hcEFJIGFuZCBBSSBzaW1pbGFyIG1ldGhvZHMgYW5kIHNpZ25hdHVyZXMgZm9yIHRoZSBzYWtlIG9mIHVuaXR5XHJcbiAgICB0aGlzLl9haS5pbml0aWFsaXplQUkodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5haUFjdGl2ZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBAaW1wbGVtZW50ZWRcclxuICBzZXRBSUFjdGl2ZShhY3RpdmU6IGJvb2xlYW4sIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgIHRoaXMuYWlBY3RpdmUgPSBhY3RpdmU7XHJcbiAgICBpZiAodGhpcy5haUFjdGl2ZSkge1xyXG4gICAgICB0aGlzLmFpLmFjdGl2YXRlKG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyotLS0tLS0tLS0tIFRXRUVOQUJMRSBQUk9QRVJUSUVTIC0tLS0tLS0tLS0qL1xyXG4gIHNldCBwb3NpdGlvblgodmFsdWU6IG51bWJlcikge1xyXG4gICAgdGhpcy5wb3NpdGlvbi54ID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBzZXQgcG9zaXRpb25ZKHZhbHVlOiBudW1iZXIpIHtcclxuICAgIHRoaXMucG9zaXRpb24ueSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgYWJzdHJhY3Qgc2V0IHNjYWxlWCh2YWx1ZTogbnVtYmVyKTtcclxuXHJcbiAgYWJzdHJhY3Qgc2V0IHNjYWxlWSh2YWx1ZTogbnVtYmVyKTtcclxuXHJcbiAgLyotLS0tLS0tLS0tIEdBTUUgTk9ERSAtLS0tLS0tLS0tKi9cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBzY2VuZSBmb3IgdGhpcyBvYmplY3QuXHJcbiAgICogQHBhcmFtIHNjZW5lIFRoZSBzY2VuZSB0aGlzIG9iamVjdCBiZWxvbmdzIHRvLlxyXG4gICAqL1xyXG4gIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xyXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgc2NlbmUgdGhpcyBvYmplY3QgaXMgaW4uXHJcbiAgICogQHJldHVybnMgVGhlIHNjZW5lIHRoaXMgb2JqZWN0IGJlbG9uZ3MgdG9cclxuICAgKi9cclxuICBnZXRTY2VuZSgpOiBTY2VuZSB7XHJcbiAgICByZXR1cm4gdGhpcy5zY2VuZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGxheWVyIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSBsYXllciBUaGUgbGF5ZXIgdGhpcyBvYmplY3Qgd2lsbCBiZSBvbi5cclxuICAgKi9cclxuICBzZXRMYXllcihsYXllcjogTGF5ZXIpOiB2b2lkIHtcclxuICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGxheWVyIHRoaXMgb2JqZWN0IGlzIG9uLlxyXG4gICAqIEByZXR1cm5zIFRoaXMgbGF5ZXIgdGhpcyBvYmplY3QgaXMgb24uXHJcbiAgICovXHJcbiAgZ2V0TGF5ZXIoKTogTGF5ZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubGF5ZXI7XHJcbiAgfVxyXG5cclxuICAvKiogQ2FsbGVkIGlmIHRoZSBwb3NpdGlvbiB2ZWN0b3IgaXMgbW9kaWZpZWQgb3IgcmVwbGFjZWQgKi9cclxuICBwcm90ZWN0ZWQgcG9zaXRpb25DaGFuZ2VkKCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuY29sbGlzaW9uU2hhcGUpIHtcclxuICAgICAgaWYgKHRoaXMuY29sbGlkZXJPZmZzZXQpIHtcclxuICAgICAgICB0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb25cclxuICAgICAgICAgIC5jbG9uZSgpXHJcbiAgICAgICAgICAuYWRkKHRoaXMuY29sbGlkZXJPZmZzZXQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyID0gdGhpcy5wb3NpdGlvbi5jbG9uZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoaXMgR2FtZU5vZGVcclxuICAgKiBAcGFyYW0gZGVsdGFUIFRoZSB0aW1lc3RlcCBvZiB0aGUgdXBkYXRlLlxyXG4gICAqL1xyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgLy8gRGVmZXIgZXZlbnQgaGFuZGxpbmcgdG8gQUkuXHJcbiAgICB3aGlsZSAodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSkge1xyXG4gICAgICB0aGlzLl9haS5oYW5kbGVFdmVudCh0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEBpbXBsZW1lbnRlZFxyXG4gIGRlYnVnUmVuZGVyKCk6IHZvaWQge1xyXG4gICAgLy8gRHJhdyB0aGUgcG9zaXRpb24gb2YgdGhpcyBHYW1lTm9kZVxyXG4gICAgRGVidWcuZHJhd1BvaW50KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgQ29sb3IuQkxVRSk7XHJcblxyXG4gICAgLy8gSWYgdmVsb2NpdHkgaXMgbm90IHplcm8sIGRyYXcgYSB2ZWN0b3IgZm9yIGl0XHJcbiAgICBpZiAodGhpcy5fdmVsb2NpdHkgJiYgIXRoaXMuX3ZlbG9jaXR5LmlzWmVybygpKSB7XHJcbiAgICAgIERlYnVnLmRyYXdSYXkoXHJcbiAgICAgICAgdGhpcy5yZWxhdGl2ZVBvc2l0aW9uLFxyXG4gICAgICAgIHRoaXMuX3ZlbG9jaXR5LmNsb25lKCkuc2NhbGVUbygyMCkuYWRkKHRoaXMucmVsYXRpdmVQb3NpdGlvbiksXHJcbiAgICAgICAgQ29sb3IuQkxVRSxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB0aGlzIGhhcyBhIGNvbGxpZGVyLCBkcmF3IGl0XHJcbiAgICBpZiAodGhpcy5jb2xsaXNpb25TaGFwZSkge1xyXG4gICAgICBsZXQgY29sb3IgPSB0aGlzLmlzQ29sbGlkaW5nID8gQ29sb3IuUkVEIDogQ29sb3IuR1JFRU47XHJcblxyXG4gICAgICBpZiAodGhpcy5pc1RyaWdnZXIpIHtcclxuICAgICAgICBjb2xvciA9IENvbG9yLk1BR0VOVEE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbG9yLmEgPSAwLjI7XHJcblxyXG4gICAgICBpZiAodGhpcy5jb2xsaXNpb25TaGFwZSBpbnN0YW5jZW9mIEFBQkIpIHtcclxuICAgICAgICBEZWJ1Zy5kcmF3Qm94KFxyXG4gICAgICAgICAgdGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIpLFxyXG4gICAgICAgICAgdGhpcy5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZS5zY2FsZWQodGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKSksXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgY29sb3IsXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbGxpc2lvblNoYXBlIGluc3RhbmNlb2YgQ2lyY2xlKSB7XHJcbiAgICAgICAgRGVidWcuZHJhd0NpcmNsZShcclxuICAgICAgICAgIHRoaXMuaW5SZWxhdGl2ZUNvb3JkaW5hdGVzKHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyKSxcclxuICAgICAgICAgIHRoaXMuY29sbGlzaW9uU2hhcGUuaHcgKiB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpLFxyXG4gICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgIGNvbG9yLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIFR3ZWVuYWJsZVByb3BlcnRpZXMge1xyXG4gIHBvc1ggPSBcInBvc2l0aW9uWFwiLFxyXG4gIHBvc1kgPSBcInBvc2l0aW9uWVwiLFxyXG4gIHNjYWxlWCA9IFwic2NhbGVYXCIsXHJcbiAgc2NhbGVZID0gXCJzY2FsZVlcIixcclxuICByb3RhdGlvbiA9IFwicm90YXRpb25cIixcclxuICBhbHBoYSA9IFwiYWxwaGFcIixcclxufVxyXG4iLCJpbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYSBnYW1lIG9iamVjdCB0aGF0IGRvZXNuJ3QgcmVseSBvbiBhbnkgcmVzb3VyY2VzIHRvIHJlbmRlciAtIGl0IGlzIGRyYXduIHRvIHRoZSBzY3JlZW4gYnkgdGhlIGNhbnZhc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR3JhcGhpYyBleHRlbmRzIENhbnZhc05vZGUge1xyXG4gIC8qKiBUaGUgY29sb3Igb2YgdGhlIEdyYXBoaWMgKi9cclxuICBjb2xvcjogQ29sb3I7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuY29sb3IgPSBDb2xvci5SRUQ7XHJcbiAgfVxyXG5cclxuICBnZXQgYWxwaGEoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNvbG9yLmE7XHJcbiAgfVxyXG5cclxuICBzZXQgYWxwaGEoYTogbnVtYmVyKSB7XHJcbiAgICB0aGlzLmNvbG9yLmEgPSBhO1xyXG4gIH1cclxuXHJcbiAgLy8gQGRlcHJlY2F0ZWRcclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBjb2xvciBvZiB0aGUgR3JhcGhpYy4gREVQUkVDQVRFRFxyXG4gICAqIEBwYXJhbSBjb2xvciBUaGUgbmV3IGNvbG9yIG9mIHRoZSBHcmFwaGljLlxyXG4gICAqL1xyXG4gIHNldENvbG9yKGNvbG9yOiBDb2xvcikge1xyXG4gICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNvbG9yUihyOiBudW1iZXIpIHtcclxuICAgIHRoaXMuY29sb3IuciA9IHI7XHJcbiAgfVxyXG5cclxuICBnZXQgY29sb3JSKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2xvci5yO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNvbG9yRyhnOiBudW1iZXIpIHtcclxuICAgIHRoaXMuY29sb3IuZyA9IGc7XHJcbiAgfVxyXG5cclxuICBnZXQgY29sb3JHKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2xvci5nO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNvbG9yQihiOiBudW1iZXIpIHtcclxuICAgIHRoaXMuY29sb3IuYiA9IGI7XHJcbiAgfVxyXG5cclxuICBnZXQgY29sb3JCKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2xvci5iO1xyXG4gIH1cclxufVxyXG4iLCJleHBvcnQgZW51bSBHcmFwaGljVHlwZSB7XHJcbiAgUE9JTlQgPSBcIlBPSU5UXCIsXHJcbiAgUkVDVCA9IFwiUkVDVFwiLFxyXG4gIExJTkUgPSBcIkxJTkVcIixcclxuICBQQVJUSUNMRSA9IFwiUEFSVElDTEVcIixcclxufVxyXG4iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL0dyYXBoaWNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmUgZXh0ZW5kcyBHcmFwaGljIHtcclxuICBwcm90ZWN0ZWQgX2VuZDogVmVjMjtcclxuICB0aGlja25lc3M6IG51bWJlcjtcclxuXHJcbiAgY29uc3RydWN0b3Ioc3RhcnQ6IFZlYzIsIGVuZDogVmVjMikge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgIHRoaXMuZW5kID0gZW5kO1xyXG4gICAgdGhpcy50aGlja25lc3MgPSAyO1xyXG5cclxuICAgIC8vIERvZXMgdGhpcyByZWFsbHkgaGF2ZSBhIG1lYW5pbmcgZm9yIGxpbmVzP1xyXG4gICAgdGhpcy5zaXplLnNldCg1LCA1KTtcclxuICB9XHJcblxyXG4gIHNldCBzdGFydChwb3M6IFZlYzIpIHtcclxuICAgIHRoaXMucG9zaXRpb24gPSBwb3M7XHJcbiAgfVxyXG5cclxuICBnZXQgc3RhcnQoKTogVmVjMiB7XHJcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIHNldCBlbmQocG9zOiBWZWMyKSB7XHJcbiAgICB0aGlzLl9lbmQgPSBwb3M7XHJcbiAgfVxyXG5cclxuICBnZXQgZW5kKCk6IFZlYzIge1xyXG4gICAgcmV0dXJuIHRoaXMuX2VuZDtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBQb2ludCBmcm9tIFwiLi9Qb2ludFwiO1xyXG5cclxuLyoqXHJcbiAqIC0gUG9zaXRpb24gWFxyXG4tIFZlbG9jaXR5IChzcGVlZCBhbmQgZGlyZWN0aW9uKSBYXHJcbi0gQ29sb3IgWFxyXG4tIExpZmV0aW1lIFxyXG4tIEFnZSBjYW4gYmUgaGFuZGxlZCBhcyBsaWZldGltZVxyXG4tIFNoYXBlIFhcclxuLSBTaXplIFhcclxuLSBUcmFuc3BhcmVuY3kgWFxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnRpY2xlIGV4dGVuZHMgUG9pbnQge1xyXG4gIGFnZTogbnVtYmVyO1xyXG5cclxuICBpblVzZTogYm9vbGVhbjtcclxuXHJcbiAgdmVsOiBWZWMyO1xyXG5cclxuICBtYXNzOiBudW1iZXI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyLCBzaXplOiBWZWMyLCBtYXNzOiBudW1iZXIpIHtcclxuICAgIC8vIEFyZSB3ZSBtYWtpbmcgdGhpcyBhIGNpcmNsZT9cclxuICAgIHN1cGVyKHBvc2l0aW9uKTtcclxuICAgIHRoaXMuaW5Vc2UgPSBmYWxzZTtcclxuICAgIHRoaXMubWFzcyA9IG1hc3M7XHJcbiAgfVxyXG5cclxuICBzZXRQYXJ0aWNsZUFjdGl2ZShsaWZldGltZTogbnVtYmVyLCBwb3NpdGlvbjogVmVjMikge1xyXG4gICAgdGhpcy5hZ2UgPSBsaWZldGltZTtcclxuICAgIHRoaXMuaW5Vc2UgPSB0cnVlO1xyXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIGRlY3JlbWVudEFnZShkZWNheTogbnVtYmVyKSB7XHJcbiAgICB0aGlzLmFnZSAtPSBkZWNheTtcclxuICB9XHJcblxyXG4gIHNldFBhcnRpY2xlSW5hY3RpdmUoKSB7XHJcbiAgICB0aGlzLmluVXNlID0gZmFsc2U7XHJcbiAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHNldCB2ZWxZKHk6IG51bWJlcikge1xyXG4gICAgdGhpcy52ZWwueSA9IHk7XHJcbiAgfVxyXG5cclxuICBnZXQgdmVsWSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMudmVsLnk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9HcmFwaGljXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5cclxuLyoqIEEgYmFzaWMgcG9pbnQgdG8gYmUgZHJhd24gb24gdGhlIHNjcmVlbi4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnQgZXh0ZW5kcyBHcmFwaGljIHtcclxuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMikge1xyXG4gICAgLy8gQXJlIHdlIG1ha2luZyB0aGlzIGEgY2lyY2xlP1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIHRoaXMuc2l6ZS5zZXQoNSwgNSk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9HcmFwaGljXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vKiogQSBiYXNpYyByZWN0YW5nbGUgdG8gYmUgZHJhd24gb24gdGhlIHNjcmVlbi4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdCBleHRlbmRzIEdyYXBoaWMge1xyXG4gIC8qKiBUaGUgYm9yZGVyIGNvbG9yIG9mIHRoZSBSZWN0ICovXHJcbiAgYm9yZGVyQ29sb3I6IENvbG9yO1xyXG5cclxuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBib3JkZXIgKi9cclxuICBib3JkZXJXaWR0aDogbnVtYmVyO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgc2l6ZTogVmVjMikge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XHJcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICB0aGlzLmJvcmRlcldpZHRoID0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGJvcmRlciBjb2xvciBvZiB0aGlzIHJlY3RhbmdsZVxyXG4gICAqIEBwYXJhbSBjb2xvciBUaGUgYm9yZGVyIGNvbG9yXHJcbiAgICovXHJcbiAgc2V0Qm9yZGVyQ29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XHJcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gY29sb3I7XHJcbiAgfVxyXG5cclxuICAvLyBAZGVwcmVjYXRlZFxyXG4gIGdldEJvcmRlckNvbG9yKCk6IENvbG9yIHtcclxuICAgIHJldHVybiB0aGlzLmJvcmRlckNvbG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgYm9yZGVyIHdpZHRoIG9mIHRoaXMgcmVjdGFuZ2xlXHJcbiAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIGluIHBpeGVsc1xyXG4gICAqL1xyXG4gIHNldEJvcmRlcldpZHRoKHdpZHRoOiBudW1iZXIpIHtcclxuICAgIHRoaXMuYm9yZGVyV2lkdGggPSB3aWR0aDtcclxuICB9XHJcblxyXG4gIGdldEJvcmRlcldpZHRoKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5ib3JkZXJXaWR0aDtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi9TcHJpdGVcIjtcclxuaW1wb3J0IEFuaW1hdGlvbk1hbmFnZXIgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9BbmltYXRpb25zL0FuaW1hdGlvbk1hbmFnZXJcIjtcclxuaW1wb3J0IFNwcml0ZXNoZWV0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvU3ByaXRlc2hlZXRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcblxyXG4vKiogQSBzcHJpdGUgd2l0aCBzcGVjaWZpZWQgYW5pbWF0aW9uIGZyYW1lcy4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0ZWRTcHJpdGUgZXh0ZW5kcyBTcHJpdGUge1xyXG4gIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhpcyBzcHJpdGUgc2hlZXQgKi9cclxuICBwcm90ZWN0ZWQgbnVtQ29sczogbnVtYmVyO1xyXG5cclxuICBnZXQgY29scygpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubnVtQ29scztcclxuICB9XHJcblxyXG4gIC8qKiBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhpcyBzcHJpdGUgc2hlZXQgKi9cclxuICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xyXG5cclxuICBnZXQgcm93cygpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubnVtUm93cztcclxuICB9XHJcblxyXG4gIC8qKiBUaGUgYW5pbWF0aW9uTWFuYWdlciBmb3IgdGhpcyBzcHJpdGUgKi9cclxuICBhbmltYXRpb246IEFuaW1hdGlvbk1hbmFnZXI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHNwcml0ZXNoZWV0OiBTcHJpdGVzaGVldCkge1xyXG4gICAgc3VwZXIoc3ByaXRlc2hlZXQubmFtZSk7XHJcbiAgICB0aGlzLm51bUNvbHMgPSBzcHJpdGVzaGVldC5jb2x1bW5zO1xyXG4gICAgdGhpcy5udW1Sb3dzID0gc3ByaXRlc2hlZXQucm93cztcclxuXHJcbiAgICAvLyBTZXQgdGhlIHNpemUgb2YgdGhlIHNwcml0ZSB0byB0aGUgc3ByaXRlIHNpemUgc3BlY2lmaWVkIGJ5IHRoZSBzcHJpdGVzaGVldFxyXG4gICAgdGhpcy5zaXplLnNldChzcHJpdGVzaGVldC5zcHJpdGVXaWR0aCwgc3ByaXRlc2hlZXQuc3ByaXRlSGVpZ2h0KTtcclxuXHJcbiAgICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb25NYW5hZ2VyKHRoaXMpO1xyXG5cclxuICAgIC8vIEFkZCB0aGUgYW5pbWF0aW9ucyB0byB0aGUgYW5pbWF0ZWQgc3ByaXRlXHJcbiAgICBmb3IgKGxldCBhbmltYXRpb24gb2Ygc3ByaXRlc2hlZXQuYW5pbWF0aW9ucykge1xyXG4gICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoYW5pbWF0aW9uLm5hbWUsIGFuaW1hdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBpbWFnZSBvZmZzZXQgZm9yIHRoZSBjdXJyZW50IGluZGV4IG9mIGFuaW1hdGlvblxyXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggd2UncmUgYXQgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBpbWFnZSBvZmZzZXRcclxuICAgKi9cclxuICBnZXRBbmltYXRpb25PZmZzZXQoaW5kZXg6IG51bWJlcik6IFZlYzIge1xyXG4gICAgLy8gcmV0dXJuIG5ldyBWZWMyKFxyXG4gICAgLy8gICAoaW5kZXggJSB0aGlzLm51bUNvbHMpICogdGhpcy5zaXplLngsXHJcbiAgICAvLyAgIE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpICogdGhpcy5zaXplLnksXHJcbiAgICAvLyApO1xyXG4gICAgY29uc3QgZnJhbWVEYXRhID0gdGhpcy5hbmltYXRpb24uZ2V0QW5pbWF0aW9uRGF0YSgpO1xyXG4gICAgcmV0dXJuIG5ldyBWZWMyKGZyYW1lRGF0YS54LCBmcmFtZURhdGEueSk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgc3ByaXRlIC0gYW4gaW4tZ2FtZSBpbWFnZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ2FudmFzTm9kZSB7XHJcbiAgLyoqIFRoZSBpZCBvZiB0aGUgaW1hZ2UgZnJvbSB0aGUgcmVzb3VyY2VNYW5hZ2VyICovXHJcbiAgaW1hZ2VJZDogc3RyaW5nO1xyXG4gIC8qKiBUaGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgaW4gYW4gYXRsYXMgaW1hZ2UgKi9cclxuICBpbWFnZU9mZnNldDogVmVjMjtcclxuICAvKiogV2hldGhlciBvciBub3QgdGhlIHgtYXhpcyBzaG91bGQgYmUgaW52ZXJ0ZWQgb24gcmVuZGVyICovXHJcbiAgaW52ZXJ0WDogYm9vbGVhbjtcclxuICAvKiogV2hldGhlciBvciBub3QgdGhlIHktYXhpcyBzaG91bGQgYmUgaW52ZXJ0ZWQgb24gcmVuZGVyICovXHJcbiAgaW52ZXJ0WTogYm9vbGVhbjtcclxuXHJcbiAgY29uc3RydWN0b3IoaW1hZ2VJZDogc3RyaW5nKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5pbWFnZUlkID0gaW1hZ2VJZDtcclxuICAgIGxldCBpbWFnZSA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEltYWdlKHRoaXMuaW1hZ2VJZCk7XHJcbiAgICB0aGlzLnNpemUgPSBuZXcgVmVjMihpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcclxuICAgIHRoaXMuaW1hZ2VPZmZzZXQgPSBWZWMyLlpFUk87XHJcbiAgICB0aGlzLmludmVydFggPSBmYWxzZTtcclxuICAgIHRoaXMuaW52ZXJ0WSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgZnJvbSAoMCwgMCkgaW4gdGhlIGltYWdlJ3MgY29vcmRpbmF0ZXNcclxuICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgb2YgdGhlIHNwcml0ZSBmcm9tICgwLCAwKSBpbiBpbWFnZSBjb29yZGluYXRlc1xyXG4gICAqL1xyXG4gIHNldEltYWdlT2Zmc2V0KG9mZnNldDogVmVjMik6IHZvaWQge1xyXG4gICAgdGhpcy5pbWFnZU9mZnNldCA9IG9mZnNldDtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xyXG5pbXBvcnQge1xyXG4gIFRpbGVkVGlsZW1hcERhdGEsXHJcbiAgVGlsZWRMYXllckRhdGEsXHJcbn0gZnJvbSBcIi4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4vQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvUGh5c2ljc01hbmFnZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYSB0aWxlbWFwIC0gdGhpcyBjYW4gY29uc2lzdCBvZiBhIGNvbWJpbmF0aW9uIG9mIHRpbGVzZXRzIGluIG9uZSBsYXllclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgVGlsZW1hcCBleHRlbmRzIENhbnZhc05vZGUge1xyXG4gIC8qKiBBbiBhcnJheSBvZiB0aGUgdGlsZXNldHMgdGhhdCB0aGlzIHRpbGVtYXAgdXNlcyAqL1xyXG4gIHByb3RlY3RlZCB0aWxlc2V0czogQXJyYXk8VGlsZXNldD47XHJcblxyXG4gIC8qKiBUaGUgc2l6ZSBvZiBhIHRpbGUgaW4gdGhpcyB0aWxlbWFwICovXHJcbiAgcHJvdGVjdGVkIHRpbGVTaXplOiBWZWMyO1xyXG5cclxuICAvKiogQW4gYXJyYXkgb2YgdGlsZSBkYXRhICovXHJcbiAgcHJvdGVjdGVkIGRhdGE6IEFycmF5PG51bWJlcj47XHJcblxyXG4gIC8qKiBBbiBhcnJheSBvZiB0aWxlIGNvbGxpc2lvbiBkYXRhICovXHJcbiAgcHJvdGVjdGVkIGNvbGxpc2lvbk1hcDogQXJyYXk8Ym9vbGVhbj47XHJcblxyXG4gIC8qKiBUaGUgbmFtZSBvZiB0aGUgdGlsZW1hcCAqL1xyXG4gIG5hbWU6IHN0cmluZztcclxuXHJcbiAgLy8gVE9ETzogTWFrZSB0aGlzIG5vIGxvbmdlciBiZSBzcGVjaWZpYyB0byBUaWxlZFxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgdGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsXHJcbiAgICBsYXllcjogVGlsZWRMYXllckRhdGEsXHJcbiAgICB0aWxlc2V0czogQXJyYXk8VGlsZXNldD4sXHJcbiAgICBzY2FsZTogVmVjMixcclxuICApIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLnRpbGVzZXRzID0gdGlsZXNldHM7XHJcbiAgICB0aGlzLnRpbGVTaXplID0gbmV3IFZlYzIoMCwgMCk7XHJcbiAgICB0aGlzLm5hbWUgPSBsYXllci5uYW1lO1xyXG5cclxuICAgIGxldCB0aWxlY291bnQgPSAwO1xyXG4gICAgZm9yIChsZXQgdGlsZXNldCBvZiB0aWxlc2V0cykge1xyXG4gICAgICB0aWxlY291bnQgKz0gdGlsZXNldC5nZXRUaWxlQ291bnQoKSArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb2xsaXNpb25NYXAgPSBuZXcgQXJyYXkodGlsZWNvdW50KTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2xsaXNpb25NYXAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGhpcy5jb2xsaXNpb25NYXBbaV0gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWZlciBwYXJzaW5nIG9mIHRoZSBkYXRhIHRvIGNoaWxkIGNsYXNzZXMgLSB0aGlzIGFsbG93cyBmb3IgaXNvbWV0cmljIHZzLiBvcnRob2dyYXBoaWMgdGlsZW1hcHMgYW5kIGhhbmRsaW5nIG9mIFRpbGVkIGRhdGEgb3Igb3RoZXIgZGF0YVxyXG4gICAgdGhpcy5wYXJzZVRpbGVtYXBEYXRhKHRpbGVtYXBEYXRhLCBsYXllcik7XHJcbiAgICB0aGlzLnNjYWxlLnNldChzY2FsZS54LCBzY2FsZS55KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHRpbGVzZXRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRpbGVtYXBcclxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgb2YgdGhlIHRpbGVzZXRzIGFzc29jYWl0ZWQgd2l0aCB0aGlzIHRpbGVtYXAuXHJcbiAgICovXHJcbiAgZ2V0VGlsZXNldHMoKTogVGlsZXNldFtdIHtcclxuICAgIHJldHVybiB0aGlzLnRpbGVzZXRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aWxlcyBpbiB0aGlzIHRpbGVtYXAgYXMgdGhleSBhcHBlYXIgaW4gdGhlIGdhbWUgd29ybGQgYWZ0ZXIgc2NhbGluZ1xyXG4gICAqIEByZXR1cm5zIEEgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIHNpemUgb2YgdGlsZXMgaW4gdGhpcyB0aWxlbWFwIGFzIHRoZXkgYXBwZWFyIGluIHRoZSBnYW1lIHdvcmxkIGFmdGVyIHNjYWxpbmcuXHJcbiAgICovXHJcbiAgZ2V0VGlsZVNpemUoKTogVmVjMiB7XHJcbiAgICByZXR1cm4gdGhpcy50aWxlU2l6ZS5zY2FsZWQodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgdGlsZSBzaXplIHRha2luZyB6b29tIGludG8gYWNjb3VudFxyXG4gICAqIEByZXR1cm5zIFRoZSB0aWxlIHNpemUgd2l0aCB6b29tXHJcbiAgICovXHJcbiAgZ2V0VGlsZVNpemVXaXRoWm9vbSgpOiBWZWMyIHtcclxuICAgIGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5nZXRUaWxlU2l6ZSgpLnNjYWxlKHpvb20pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyB0aGlzIHRpbGVtYXAgdG8gdGhlIHBoeXNpY3Mgc3lzdGVtXHJcbiAgICovXHJcbiAgYWRkUGh5c2ljcygpOiB2b2lkIHtcclxuICAgIHRoaXMuaGFzUGh5c2ljcyA9IHRydWU7XHJcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICB0aGlzLmdyb3VwID0gLTE7XHJcbiAgICB0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkucmVnaXN0ZXJUaWxlbWFwKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSB3b3JsZENvb3JkcyBUaGUgcG9zaXRpb24gaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgKiBAcmV0dXJucyBBIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCB3b3JsZCBwb3NpdGlvbi5cclxuICAgKi9cclxuICBhYnN0cmFjdCBnZXRUaWxlQXRXb3JsZFBvc2l0aW9uKHdvcmxkQ29vcmRzOiBWZWMyKTogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIGluIHRoZSB0aWxlRGF0YSBhcnJheVxyXG4gICAqIEByZXR1cm5zIFRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XHJcbiAgICovXHJcbiAgYWJzdHJhY3QgZ2V0VGlsZVdvcmxkUG9zaXRpb24oaW5kZXg6IG51bWJlcik6IFZlYzI7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIGluIHRoZSB0aWxlRGF0YSBhcnJheVxyXG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZURhdGEgYXJyYXlcclxuICAgKi9cclxuICBhYnN0cmFjdCBnZXRUaWxlKGluZGV4OiBudW1iZXIpOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGVcclxuICAgKiBAcGFyYW0gdHlwZSBUaGUgbmV3IGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcclxuICAgKi9cclxuICBhYnN0cmFjdCBzZXRUaWxlKGluZGV4OiBudW1iZXIsIHR5cGU6IG51bWJlcik6IHZvaWQ7XHJcblxyXG4gIC8vIFRPRE86IFRoaXMgc2hvdWxkbid0IHVzZSB0aWxlZCBkYXRhIHNwZWNpZmljYWxseSAtIGl0IHNob3VsZCBiZSBtb3JlIGdlbmVyYWxcclxuICAvKipcclxuICAgKiBTZXRzIHVwIHRoZSB0aWxlc2V0IHVzaW5nIHRoZSBkYXRhIGxvYWRlZCBmcm9tIGZpbGVcclxuICAgKiBAcGFyYW0gdGlsZW1hcERhdGEgVGhlIHRpbGVtYXAgZGF0YSBmcm9tIGZpbGVcclxuICAgKiBAcGFyYW0gbGF5ZXIgVGhlIGxheWVyIGRhdGEgZnJvbSBmaWxlXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHBhcnNlVGlsZW1hcERhdGEoXHJcbiAgICB0aWxlbWFwRGF0YTogVGlsZWRUaWxlbWFwRGF0YSxcclxuICAgIGxheWVyOiBUaWxlZExheWVyRGF0YSxcclxuICApOiB2b2lkO1xyXG59XHJcbiIsImltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9UaWxlbWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQge1xyXG4gIFRpbGVkVGlsZW1hcERhdGEsXHJcbiAgVGlsZWRMYXllckRhdGEsXHJcbn0gZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9ydGhvZ29uYWwgdGlsZW1hcCAtIGkuZS4gYSB0b3AgZG93biBvciBwbGF0Zm9ybWVyIHRpbGVtYXBcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9ydGhvZ29uYWxUaWxlbWFwIGV4dGVuZHMgVGlsZW1hcCB7XHJcbiAgLyoqIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGlsZW1hcCAqL1xyXG4gIHByb3RlY3RlZCBudW1Db2xzOiBudW1iZXI7XHJcbiAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGlsZW1hcCAqL1xyXG4gIHByb3RlY3RlZCBudW1Sb3dzOiBudW1iZXI7XHJcblxyXG4gIC8vIEBvdmVycmlkZVxyXG4gIHByb3RlY3RlZCBwYXJzZVRpbGVtYXBEYXRhKFxyXG4gICAgdGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsXHJcbiAgICBsYXllcjogVGlsZWRMYXllckRhdGEsXHJcbiAgKTogdm9pZCB7XHJcbiAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgdGlsZW1hcCBpbiBsb2NhbCBzcGFjZVxyXG4gICAgdGhpcy5udW1Db2xzID0gdGlsZW1hcERhdGEud2lkdGg7XHJcbiAgICB0aGlzLm51bVJvd3MgPSB0aWxlbWFwRGF0YS5oZWlnaHQ7XHJcblxyXG4gICAgLy8gVGhlIHNpemUgb2YgdGlsZXNcclxuICAgIHRoaXMudGlsZVNpemUuc2V0KHRpbGVtYXBEYXRhLnRpbGV3aWR0aCwgdGlsZW1hcERhdGEudGlsZWhlaWdodCk7XHJcblxyXG4gICAgLy8gVGhlIHNpemUgb2YgdGhlIHRpbGVtYXAgb24gdGhlIGNhbnZhc1xyXG4gICAgdGhpcy5zaXplLnNldChcclxuICAgICAgdGhpcy5udW1Db2xzICogdGhpcy50aWxlU2l6ZS54LFxyXG4gICAgICB0aGlzLm51bVJvd3MgKiB0aGlzLnRpbGVTaXplLnksXHJcbiAgICApO1xyXG4gICAgdGhpcy5wb3NpdGlvbi5jb3B5KHRoaXMuc2l6ZS5zY2FsZWQoMC41KSk7XHJcbiAgICB0aGlzLmRhdGEgPSBsYXllci5kYXRhO1xyXG4gICAgdGhpcy52aXNpYmxlID0gbGF5ZXIudmlzaWJsZTtcclxuXHJcbiAgICAvLyBXaGV0aGVyIHRoZSB0aWxlbWFwIGlzIGNvbGxpZGFibGUgb3Igbm90XHJcbiAgICB0aGlzLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xyXG4gICAgaWYgKGxheWVyLnByb3BlcnRpZXMpIHtcclxuICAgICAgZm9yIChsZXQgaXRlbSBvZiBsYXllci5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0ubmFtZSA9PT0gXCJDb2xsaWRhYmxlXCIpIHtcclxuICAgICAgICAgIHRoaXMuaXNDb2xsaWRhYmxlID0gaXRlbS52YWx1ZTtcclxuXHJcbiAgICAgICAgICAvLyBTZXQgYWxsIHRpbGVzIGJlc2lkZXMgXCJlbXB0eTogMFwiIHRvIGJlIGNvbGxpZGFibGVcclxuICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5jb2xsaXNpb25NYXAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXBbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGlsZW1hcFxyXG4gICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBudW1iZXIgb2YgY29sdW1ucyBhbmQgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSB0aWxlbWFwLlxyXG4gICAqL1xyXG4gIGdldERpbWVuc2lvbnMoKTogVmVjMiB7XHJcbiAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5udW1Db2xzLCB0aGlzLm51bVJvd3MpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHdvcmxkIHBvc2l0aW9uXHJcbiAgICogQHBhcmFtIHdvcmxkQ29vcmRzIFRoZSBjb29yZGluYXRlcyBpbiB3b3JsZCBzcGFjZVxyXG4gICAqIEByZXR1cm5zIFRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXHJcbiAgICovXHJcbiAgZ2V0VGlsZUF0V29ybGRQb3NpdGlvbih3b3JsZENvb3JkczogVmVjMik6IG51bWJlciB7XHJcbiAgICBsZXQgbG9jYWxDb29yZHMgPSB0aGlzLmdldENvbFJvd0F0KHdvcmxkQ29vcmRzKTtcclxuICAgIHJldHVybiB0aGlzLmdldFRpbGVBdFJvd0NvbChsb2NhbENvb3Jkcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCByb3cgYW5kIGNvbHVtblxyXG4gICAqIEBwYXJhbSByb3dDb2wgVGhlIGNvb3JkaW5hdGVzIGluIHRpbGVtYXAgc3BhY2VcclxuICAgKiBAcmV0dXJucyBUaGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZVxyXG4gICAqL1xyXG4gIGdldFRpbGVBdFJvd0NvbChyb3dDb2w6IFZlYzIpOiBudW1iZXIge1xyXG4gICAgaWYgKFxyXG4gICAgICByb3dDb2wueCA8IDAgfHxcclxuICAgICAgcm93Q29sLnggPj0gdGhpcy5udW1Db2xzIHx8XHJcbiAgICAgIHJvd0NvbC55IDwgMCB8fFxyXG4gICAgICByb3dDb2wueSA+PSB0aGlzLm51bVJvd3NcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZGF0YVtyb3dDb2wueSAqIHRoaXMubnVtQ29scyArIHJvd0NvbC54XTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXHJcbiAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0aWxlXHJcbiAgICovXHJcbiAgZ2V0VGlsZVdvcmxkUG9zaXRpb24oaW5kZXg6IG51bWJlcik6IFZlYzIge1xyXG4gICAgLy8gR2V0IHRoZSBsb2NhbCBwb3NpdGlvblxyXG4gICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xyXG4gICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpO1xyXG5cclxuICAgIC8vIEdldCB0aGUgd29ybGQgcG9zaXRpb25cclxuICAgIGxldCB4ID0gY29sICogdGhpcy50aWxlU2l6ZS54O1xyXG4gICAgbGV0IHkgPSByb3cgKiB0aGlzLnRpbGVTaXplLnk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBWZWMyKHgsIHkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XHJcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZVxyXG4gICAqIEByZXR1cm5zIFRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXHJcbiAgICovXHJcbiAgZ2V0VGlsZShpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdO1xyXG4gIH1cclxuXHJcbiAgLy8gQG92ZXJyaWRlXHJcbiAgc2V0VGlsZShpbmRleDogbnVtYmVyLCB0eXBlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMuZGF0YVtpbmRleF0gPSB0eXBlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHJvdyBhbmQgY29sdW1uXHJcbiAgICogQHBhcmFtIHJvd0NvbCBUaGUgcG9zaXRpb24gb2YgdGhlIHRpbGUgaW4gdGlsZW1hcCBzcGFjZVxyXG4gICAqIEBwYXJhbSB0eXBlIFRoZSBuZXcgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZVxyXG4gICAqL1xyXG4gIHNldFRpbGVBdFJvd0NvbChyb3dDb2w6IFZlYzIsIHR5cGU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgbGV0IGluZGV4ID0gcm93Q29sLnkgKiB0aGlzLm51bUNvbHMgKyByb3dDb2wueDtcclxuICAgIHRoaXMuc2V0VGlsZShpbmRleCwgdHlwZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCByb3cgYW5kIGNvbHVtbiBvZiB0aGUgdGlsZW1hcCBpcyBjb2xsaWRhYmxlXHJcbiAgICogQHBhcmFtIGluZGV4T3JDb2wgVGhlIGluZGV4IG9mIHRoZSB0aWxlIG9yIHRoZSBjb2x1bW4gaXQgaXMgaW5cclxuICAgKiBAcGFyYW0gcm93IFRoZSByb3cgdGhlIHRpbGUgaXMgaW5cclxuICAgKiBAcmV0dXJucyBBIGZsYWcgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZSB0aWxlIGlzIGNvbGxpZGFibGUuXHJcbiAgICovXHJcbiAgaXNUaWxlQ29sbGlkYWJsZShpbmRleE9yQ29sOiBudW1iZXIsIHJvdz86IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgLy8gVGhlIHZhbHVlIG9mIHRoZSB0aWxlXHJcbiAgICBsZXQgdGlsZSA9IDA7XHJcblxyXG4gICAgaWYgKHJvdykge1xyXG4gICAgICAvLyBXZSBoYXZlIGEgY29sdW1uIGFuZCBhIHJvd1xyXG4gICAgICB0aWxlID0gdGhpcy5nZXRUaWxlQXRSb3dDb2wobmV3IFZlYzIoaW5kZXhPckNvbCwgcm93KSk7XHJcblxyXG4gICAgICBpZiAodGlsZSA8IDApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChpbmRleE9yQ29sIDwgMCB8fCBpbmRleE9yQ29sID49IHRoaXMuZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAvLyBUaWxlcyB0aGF0IGRvbid0IGV4aXN0IGFyZW4ndCBjb2xsaWRhYmxlXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFdlIGhhdmUgYW4gaW5kZXhcclxuICAgICAgdGlsZSA9IHRoaXMuZ2V0VGlsZShpbmRleE9yQ29sKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5jb2xsaXNpb25NYXBbdGlsZV07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUYWtlcyBpbiB3b3JsZCBjb29yZGluYXRlcyBhbmQgcmV0dXJucyB0aGUgcm93IGFuZCBjb2x1bW4gb2YgdGhlIHRpbGUgYXQgdGhhdCBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSB3b3JsZENvb3JkcyBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvdGVudGlhbCB0aWxlIGluIHdvcmxkIHNwYWNlXHJcbiAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3RlbnRpYWwgdGlsZSBpbiB0aWxlbWFwIHNwYWNlXHJcbiAgICovXHJcbiAgZ2V0Q29sUm93QXQod29ybGRDb29yZHM6IFZlYzIpOiBWZWMyIHtcclxuICAgIGxldCBjb2wgPSBNYXRoLmZsb29yKHdvcmxkQ29vcmRzLnggLyB0aGlzLnRpbGVTaXplLnggLyB0aGlzLnNjYWxlLngpO1xyXG4gICAgbGV0IHJvdyA9IE1hdGguZmxvb3Iod29ybGRDb29yZHMueSAvIHRoaXMudGlsZVNpemUueSAvIHRoaXMuc2NhbGUueSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBWZWMyKGNvbCwgcm93KTtcclxuICB9XHJcblxyXG4gIC8vIEBvdmVycmlkZVxyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge31cclxuXHJcbiAgLy8gQG92ZXJyaWRlXHJcbiAgZGVidWdSZW5kZXIoKSB7XHJcbiAgICAvLyBIYWxmIG9mIHRoZSB0aWxlIHNpemVcclxuICAgIGxldCB6b29tZWRIYWxmVGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplV2l0aFpvb20oKS5zY2FsZWQoMC41KTtcclxuICAgIGxldCBoYWxmVGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCkuc2NhbGVkKDAuNSk7XHJcblxyXG4gICAgLy8gVGhlIGNlbnRlciBvZiB0aGUgdG9wIGxlZnQgdGlsZVxyXG4gICAgbGV0IHRvcExlZnQgPSB0aGlzLnBvc2l0aW9uLmNsb25lKCkuc3ViKHRoaXMuc2l6ZS5zY2FsZWQoMC41KSk7XHJcblxyXG4gICAgLy8gQSB2ZWMgdG8gc3RvcmUgdGhlIGNlbnRlclxyXG4gICAgbGV0IGNlbnRlciA9IFZlYzIuWkVSTztcclxuXHJcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLm51bUNvbHM7IGNvbCsrKSB7XHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgeC1wb3NpdGlvblxyXG4gICAgICBjZW50ZXIueCA9IHRvcExlZnQueCArIGNvbCAqIDIgKiBoYWxmVGlsZVNpemUueCArIGhhbGZUaWxlU2l6ZS54O1xyXG5cclxuICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5udW1Sb3dzOyByb3crKykge1xyXG4gICAgICAgIGlmICh0aGlzLmlzQ29sbGlkYWJsZSAmJiB0aGlzLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKSB7XHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHktcG9zaXRpb25cclxuICAgICAgICAgIGNlbnRlci55ID0gdG9wTGVmdC55ICsgcm93ICogMiAqIGhhbGZUaWxlU2l6ZS55ICsgaGFsZlRpbGVTaXplLnk7XHJcblxyXG4gICAgICAgICAgLy8gRHJhdyBhIGJveCBmb3IgdGhpcyB0aWxlXHJcbiAgICAgICAgICBEZWJ1Zy5kcmF3Qm94KFxyXG4gICAgICAgICAgICB0aGlzLmluUmVsYXRpdmVDb29yZGluYXRlcyhjZW50ZXIpLFxyXG4gICAgICAgICAgICB6b29tZWRIYWxmVGlsZVNpemUsXHJcbiAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICBDb2xvci5CTFVFLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4vQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uL0lucHV0L0lucHV0XCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgVUlFbGVtZW50IC0gdGhlIHBhcmVudCBjbGFzcyBvZiB0aGluZ3MgbGlrZSBidXR0b25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBVSUVsZW1lbnQgZXh0ZW5kcyBDYW52YXNOb2RlIHtcclxuICAvLyBTdHlsZSBhdHRyaWJ1dGVzIC0gVE9ETyAtIGFic3RyYWN0IHRoaXMgaW50byBhIHN0eWxlIG9iamVjdC9pbnRlcmZhY2VcclxuICAvKiogVGhlIGJhY2tnb3VuZCBjb2xvciAqL1xyXG4gIGJhY2tncm91bmRDb2xvcjogQ29sb3I7XHJcbiAgLyoqIFRoZSBib3JkZXIgY29sb3IgKi9cclxuICBib3JkZXJDb2xvcjogQ29sb3I7XHJcbiAgLyoqIFRoZSBib3JkZXIgcmFkaXVzICovXHJcbiAgYm9yZGVyUmFkaXVzOiBudW1iZXI7XHJcbiAgLyoqIFRoZSBib3JkZXIgd2lkdGggKi9cclxuICBib3JkZXJXaWR0aDogbnVtYmVyO1xyXG4gIC8qKiBUaGUgcGFkZGluZyAqL1xyXG4gIHBhZGRpbmc6IFZlYzI7XHJcblxyXG4gIC8vIEV2ZW50QXR0cmlidXRlc1xyXG4gIC8qKiBUaGUgcmVhY3Rpb24gb2YgdGhpcyBVSUVsZW1lbnQgb24gYSBjbGljayAqL1xyXG4gIG9uQ2xpY2s6IEZ1bmN0aW9uO1xyXG4gIC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCBvbiBjbGljayAqL1xyXG4gIG9uQ2xpY2tFdmVudElkOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSByZWFjdGlvbiB0byB0aGUgcmVsZWFzZSBvZiBhIGNsaWNrICovXHJcbiAgb25SZWxlYXNlOiBGdW5jdGlvbjtcclxuICAvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgb24gdGhlIHJlbGVhc2Ugb2YgYSBjbGljayAqL1xyXG4gIG9uUmVsZWFzZUV2ZW50SWQ6IHN0cmluZztcclxuICAvKiogVGhlIHJlYWN0aW9uIHdoZW4gYSBtb3VzZSBlbnRlcnMgdGhpcyBVSUVsZW1lbnQgKi9cclxuICBvbkVudGVyOiBGdW5jdGlvbjtcclxuICAvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgd2hlbiBhIG1vdXNlIGVudGVycyB0aGlzIFVJRWxlbWVudCAqL1xyXG4gIG9uRW50ZXJFdmVudElkOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSByZWFjdGlvbiB3aGVuIGEgbW91c2UgbGVhdmVzIHRoaXMgVUlFbGVtZW50ICovXHJcbiAgb25MZWF2ZTogRnVuY3Rpb247XHJcbiAgLyoqIFRoZSBldmVudCBwcm9wb2dhdGVkIHdoZW4gYSBtb3VzZSBsZWF2ZXMgdGhpcyBVSUVsZW1lbnQgKi9cclxuICBvbkxlYXZlRXZlbnRJZDogc3RyaW5nO1xyXG5cclxuICAvKiogV2hldGhlciBvciBub3QgdGhpcyBVSUVsZW1lbnQgaXMgY3VycmVudGx5IGNsaWNrZWQgb24gKi9cclxuICBwcm90ZWN0ZWQgaXNDbGlja2VkOiBib29sZWFuO1xyXG4gIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIFVJRWxlbWVudCBpcyBjdXJyZW50bHkgaG92ZXJlZCBvdmVyICovXHJcbiAgcHJvdGVjdGVkIGlzRW50ZXJlZDogYm9vbGVhbjtcclxuXHJcbiAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XHJcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xyXG4gICAgdGhpcy5ib3JkZXJSYWRpdXMgPSA1O1xyXG4gICAgdGhpcy5ib3JkZXJXaWR0aCA9IDE7XHJcbiAgICB0aGlzLnBhZGRpbmcgPSBWZWMyLlpFUk87XHJcblxyXG4gICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcclxuICAgIHRoaXMub25DbGlja0V2ZW50SWQgPSBudWxsO1xyXG4gICAgdGhpcy5vblJlbGVhc2UgPSBudWxsO1xyXG4gICAgdGhpcy5vblJlbGVhc2VFdmVudElkID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLm9uRW50ZXIgPSBudWxsO1xyXG4gICAgdGhpcy5vbkVudGVyRXZlbnRJZCA9IG51bGw7XHJcbiAgICB0aGlzLm9uTGVhdmUgPSBudWxsO1xyXG4gICAgdGhpcy5vbkxlYXZlRXZlbnRJZCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5pc0NsaWNrZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuaXNFbnRlcmVkID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBAZGVwcmVjYXRlZFxyXG4gIHNldEJhY2tncm91bmRDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XHJcbiAgfVxyXG5cclxuICAvLyBAZGVwcmVjYXRlZFxyXG4gIHNldFBhZGRpbmcocGFkZGluZzogVmVjMik6IHZvaWQge1xyXG4gICAgdGhpcy5wYWRkaW5nLmNvcHkocGFkZGluZyk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgIC8vIFNlZSBvZiB0aGlzIG9iamVjdCB3YXMganVzdCBjbGlja2VkXHJcbiAgICBpZiAoSW5wdXQuaXNNb3VzZUp1c3RQcmVzc2VkKCkpIHtcclxuICAgICAgLy8gQ2hhbmdlZCBmcm9tIElucHV0LmdldE1vdXNlUHJlc3NQb3NpdGlvbigpXHJcbiAgICAgIGxldCBjbGlja1BvcyA9IElucHV0LmdldE1vdXNlUG9zaXRpb24oKTtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHRoaXMuY29udGFpbnMoY2xpY2tQb3MueCwgY2xpY2tQb3MueSkgJiZcclxuICAgICAgICB0aGlzLnZpc2libGUgJiZcclxuICAgICAgICAhdGhpcy5sYXllci5pc0hpZGRlbigpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRoaXMuaXNDbGlja2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMub25DbGljayAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgdGhpcy5vbkNsaWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9uQ2xpY2tFdmVudElkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBsZXQgZGF0YSA9IHt9O1xyXG4gICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uQ2xpY2tFdmVudElkLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB0aGUgbW91c2Ugd2Fzbid0IGp1c3QgcHJlc3NlZCwgdGhlbiB3ZSBkZWZpbml0ZWx5IHdlcmVuJ3QgY2xpY2tlZFxyXG4gICAgaWYgKCFJbnB1dC5pc01vdXNlUHJlc3NlZCgpKSB7XHJcbiAgICAgIGlmICh0aGlzLmlzQ2xpY2tlZCkge1xyXG4gICAgICAgIHRoaXMuaXNDbGlja2VkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiB0aGUgbW91c2UgaXMgaG92ZXJpbmcgb3ZlciB0aGlzIGVsZW1lbnRcclxuICAgIGxldCBtb3VzZVBvcyA9IElucHV0LmdldE1vdXNlUG9zaXRpb24oKTtcclxuICAgIGlmIChtb3VzZVBvcyAmJiB0aGlzLmNvbnRhaW5zKG1vdXNlUG9zLngsIG1vdXNlUG9zLnkpKSB7XHJcbiAgICAgIHRoaXMuaXNFbnRlcmVkID0gdHJ1ZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm9uRW50ZXIgIT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLm9uRW50ZXIoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5vbkVudGVyRXZlbnRJZCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGxldCBkYXRhID0ge307XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uRW50ZXJFdmVudElkLCBkYXRhKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRW50ZXJlZCkge1xyXG4gICAgICB0aGlzLmlzRW50ZXJlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgaWYgKHRoaXMub25MZWF2ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMub25MZWF2ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLm9uTGVhdmVFdmVudElkICE9PSBudWxsKSB7XHJcbiAgICAgICAgbGV0IGRhdGEgPSB7fTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25MZWF2ZUV2ZW50SWQsIGRhdGEpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDbGlja2VkKSB7XHJcbiAgICAgIC8vIElmIG1vdXNlIGlzIGRyYWdnZWQgb2ZmIG9mIGVsZW1lbnQgd2hpbGUgZG93biwgaXQgaXMgbm90IGNsaWNrZWQgYW55bW9yZVxyXG4gICAgICB0aGlzLmlzQ2xpY2tlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyBiYWNrZ3JvdW5kIGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcclxuICAgKiBAcmV0dXJucyBUaGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgVUlFbGVtZW50XHJcbiAgICovXHJcbiAgY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCk6IENvbG9yIHtcclxuICAgIHJldHVybiB0aGlzLmJhY2tncm91bmRDb2xvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRhYmxlIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgYm9yZGVyIGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcclxuICAgKiBAcmV0dXJucyBUaGUgYm9yZGVyIGNvbG9yIG9mIHRoZSBVSUVsZW1lbnRcclxuICAgKi9cclxuICBjYWxjdWxhdGVCb3JkZXJDb2xvcigpOiBDb2xvciB7XHJcbiAgICByZXR1cm4gdGhpcy5ib3JkZXJDb2xvcjtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IExhYmVsIGZyb20gXCIuL0xhYmVsXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcblxyXG4vKiogQSBjbGlja2FibGUgYnV0dG9uIFVJRWxlbWVudCAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b24gZXh0ZW5kcyBMYWJlbCB7XHJcbiAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHRleHQ6IHN0cmluZykge1xyXG4gICAgc3VwZXIocG9zaXRpb24sIHRleHQpO1xyXG5cclxuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gbmV3IENvbG9yKDE1MCwgNzUsIDIwMyk7XHJcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gbmV3IENvbG9yKDQxLCA0NiwgMzApO1xyXG4gICAgdGhpcy50ZXh0Q29sb3IgPSBuZXcgQ29sb3IoMjU1LCAyNTUsIDI1NSk7XHJcbiAgfVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICBjYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3IoKTogQ29sb3Ige1xyXG4gICAgLy8gQ2hhbmdlIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGlmIGNsaWNrZWQgb3IgaG92ZXJlZFxyXG4gICAgaWYgKHRoaXMuaXNFbnRlcmVkICYmICF0aGlzLmlzQ2xpY2tlZCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3IubGlnaHRlbigpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ2xpY2tlZCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3IuZGFya2VuKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL1VJRWxlbWVudFwiO1xyXG5cclxuLyoqIEEgYmFzaWMgdGV4dC1jb250YWluaW5nIGxhYmVsICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhYmVsIGV4dGVuZHMgVUlFbGVtZW50IHtcclxuICAvKiogVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IG9mIHRoaXMgVUlFbGVtZW50ICovXHJcbiAgdGV4dENvbG9yOiBDb2xvcjtcclxuICAvKiogVGhlIHZhbHVlIG9mIHRoZSB0ZXh0IG9mIHRoaXMgVUlFbGVtZW50ICovXHJcbiAgdGV4dDogc3RyaW5nO1xyXG4gIC8qKiBUaGUgbmFtZSBvZiB0aGUgZm9udCAqL1xyXG4gIGZvbnQ6IHN0cmluZztcclxuICAvKiogVGhlIHNpemUgb2YgdGhlIGZvbnQgKi9cclxuICBmb250U2l6ZTogbnVtYmVyO1xyXG4gIC8qKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgdGhlIHRleHQgd2l0aGluIHRoZSBsYWJlbCAqL1xyXG4gIHByb3RlY3RlZCBoQWxpZ246IHN0cmluZztcclxuICAvKiogVGhlIHZlcnRpY2FsIGFsaWdubWVudCBvZiB0ZXh0IHdpdGhpbiB0aGUgbGFiZWwgKi9cclxuICBwcm90ZWN0ZWQgdkFsaWduOiBzdHJpbmc7XHJcblxyXG4gIC8qKiBBIGZsYWcgZm9yIGlmIHRoZSB3aWR0aCBvZiB0aGUgdGV4dCBoYXMgYmVlbiBtZWFzdXJlZCBvbiB0aGUgY2FudmFzIGZvciBhdXRvIHdpZHRoIGFzc2lnbm1lbnQgKi9cclxuICBwcm90ZWN0ZWQgc2l6ZUFzc2lnbmVkOiBib29sZWFuO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgdGV4dDogc3RyaW5nKSB7XHJcbiAgICBzdXBlcihwb3NpdGlvbik7XHJcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgdGhpcy50ZXh0Q29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMSk7XHJcbiAgICB0aGlzLmZvbnQgPSBcIkFyaWFsXCI7XHJcbiAgICB0aGlzLmZvbnRTaXplID0gMzA7XHJcbiAgICB0aGlzLmhBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICB0aGlzLnZBbGlnbiA9IFwiY2VudGVyXCI7XHJcblxyXG4gICAgdGhpcy5zaXplQXNzaWduZWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIEBkZXByZWNhdGVkXHJcbiAgc2V0VGV4dCh0ZXh0OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgfVxyXG5cclxuICAvLyBAZGVwcmVjYXRlZFxyXG4gIHNldFRleHRDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuICAgIHRoaXMudGV4dENvbG9yID0gY29sb3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGEgc3RyaW5nIGNvbnRhaW5nIHRoZSBmb250IGRldGFpbHMgZm9yIHJlbmRlcmluZ1xyXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGZvbnQgZGV0YWlsc1xyXG4gICAqL1xyXG4gIGdldEZvbnRTdHJpbmcoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLmZvbnRTaXplICsgXCJweCBcIiArIHRoaXMuZm9udDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRhYmxlIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgdGV4dCBjb2xvciAtIHVzZWZ1bCBmb3IgZWxlbWVudHMgdGhhdCB3YW50IHRvIGJlIGNvbG9yZWQgb24gZGlmZmVyZW50IGFmdGVyIGNlcnRhaW4gZXZlbnRzXHJcbiAgICogQHJldHVybnMgYSBzdHJpbmcgY29udGFpbmcgdGhlIHRleHQgY29sb3JcclxuICAgKi9cclxuICBjYWxjdWxhdGVUZXh0Q29sb3IoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLnRleHRDb2xvci50b1N0cmluZ1JHQkEoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVzZXMgdGhlIGNhbnZhcyB0byBjYWxjdWxhdGUgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0XHJcbiAgICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgKiBAcmV0dXJucyBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHJlbmRlcmVkIHRleHQgd2lkdGhcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgY2FsY3VsYXRlVGV4dFdpZHRoKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogbnVtYmVyIHtcclxuICAgIGN0eC5mb250ID0gdGhpcy5mb250U2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnQ7XHJcbiAgICByZXR1cm4gY3R4Lm1lYXN1cmVUZXh0KHRoaXMudGV4dCkud2lkdGg7XHJcbiAgfVxyXG5cclxuICBzZXRIQWxpZ24oYWxpZ246IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdGhpcy5oQWxpZ24gPSBhbGlnbjtcclxuICB9XHJcblxyXG4gIHNldFZBbGlnbihhbGlnbjogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLnZBbGlnbiA9IGFsaWduO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRoZSBvZmZzZXQgb2YgdGhlIHRleHQgLSB0aGlzIGlzIHVzZWQgZm9yIHJlbmRlcmluZyB0ZXh0IHdpdGggZGlmZmVyZW50IGFsaWdubWVudHNcclxuICAgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG4gICAqIEByZXR1cm5zIFRoZSBvZmZzZXQgb2YgdGhlIHRleHQgaW4gYSBWZWMyXHJcbiAgICovXHJcbiAgY2FsY3VsYXRlVGV4dE9mZnNldChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IFZlYzIge1xyXG4gICAgbGV0IHRleHRXaWR0aCA9IHRoaXMuY2FsY3VsYXRlVGV4dFdpZHRoKGN0eCk7XHJcblxyXG4gICAgbGV0IG9mZnNldCA9IG5ldyBWZWMyKDAsIDApO1xyXG5cclxuICAgIGxldCBoRGlmZiA9IHRoaXMuc2l6ZS54IC0gdGV4dFdpZHRoO1xyXG4gICAgaWYgKHRoaXMuaEFsaWduID09PSBIQWxpZ24uQ0VOVEVSKSB7XHJcbiAgICAgIG9mZnNldC54ID0gaERpZmYgLyAyO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmhBbGlnbiA9PT0gSEFsaWduLlJJR0hUKSB7XHJcbiAgICAgIG9mZnNldC54ID0gaERpZmYgLSB0aGlzLnBhZGRpbmcueDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9mZnNldC54ID0gdGhpcy5wYWRkaW5nLng7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMudkFsaWduID09PSBWQWxpZ24uVE9QKSB7XHJcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xyXG4gICAgICBvZmZzZXQueSA9IDA7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMudkFsaWduID09PSBWQWxpZ24uQk9UVE9NKSB7XHJcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xyXG4gICAgICBvZmZzZXQueSA9IHRoaXMuc2l6ZS55O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgIG9mZnNldC55ID0gdGhpcy5zaXplLnkgLyAyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvZmZzZXQ7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgc2l6ZUNoYW5nZWQoKTogdm9pZCB7XHJcbiAgICBzdXBlci5zaXplQ2hhbmdlZCgpO1xyXG4gICAgdGhpcy5zaXplQXNzaWduZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXV0b21hdGljYWxseSBzaXplcyB0aGUgZWxlbWVudCB0byB0aGUgdGV4dCB3aXRoaW4gaXRcclxuICAgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBhdXRvU2l6ZShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQge1xyXG4gICAgbGV0IHdpZHRoID0gdGhpcy5jYWxjdWxhdGVUZXh0V2lkdGgoY3R4KTtcclxuICAgIGxldCBoZWlnaHQgPSB0aGlzLmZvbnRTaXplO1xyXG4gICAgdGhpcy5zaXplLnNldCh3aWR0aCArIHRoaXMucGFkZGluZy54ICogMiwgaGVpZ2h0ICsgdGhpcy5wYWRkaW5nLnkgKiAyKTtcclxuICAgIHRoaXMuc2l6ZUFzc2lnbmVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxseSBhc3NpZ25zIGEgc2l6ZSB0byB0aGUgVUlFbGVtZW50IGlmIG5vbmUgaXMgcHJvdmlkZWRcclxuICAgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG4gICAqL1xyXG4gIGhhbmRsZUluaXRpYWxTaXppbmcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5zaXplQXNzaWduZWQpIHtcclxuICAgICAgdGhpcy5hdXRvU2l6ZShjdHgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIE9uIHRoZSBuZXh0IHJlbmRlciwgc2l6ZSB0aGlzIGVsZW1lbnQgdG8gaXQncyBjdXJyZW50IHRleHQgdXNpbmcgaXRzIGN1cnJlbnQgZm9udCBzaXplICovXHJcbiAgc2l6ZVRvVGV4dCgpOiB2b2lkIHtcclxuICAgIHRoaXMuc2l6ZUFzc2lnbmVkID0gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZW51bSBWQWxpZ24ge1xyXG4gIFRPUCA9IFwidG9wXCIsXHJcbiAgQ0VOVEVSID0gXCJjZW50ZXJcIixcclxuICBCT1RUT00gPSBcImJvdHRvbVwiLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBIQWxpZ24ge1xyXG4gIExFRlQgPSBcImxlZnRcIixcclxuICBDRU5URVIgPSBcImNlbnRlclwiLFxyXG4gIFJJR0hUID0gXCJyaWdodFwiLFxyXG59XHJcbiIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL0lucHV0L0lucHV0XCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL1VJRWxlbWVudFwiO1xyXG5cclxuLyoqIEEgc2xpZGVyIFVJRWxlbWVudCAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbGlkZXIgZXh0ZW5kcyBVSUVsZW1lbnQge1xyXG4gIC8qKiBUaGUgdmFsdWUgb2YgdGhlIHNsaWRlciBmcm9tIFswLCAxXSAqL1xyXG4gIHByb3RlY3RlZCB2YWx1ZTogbnVtYmVyO1xyXG4gIC8qKiBUaGUgY29sb3Igb2YgdGhlIHNsaWRlciBuaWIgKi9cclxuICBwdWJsaWMgbmliQ29sb3I6IENvbG9yO1xyXG4gIC8qKiBUaGUgc2l6ZSBvZiB0aGUgbmliICovXHJcbiAgcHVibGljIG5pYlNpemU6IFZlYzI7XHJcbiAgLyoqIFRoZSBjb2xvciBvZiB0aGUgc2xpZGVyIHRyYWNrICovXHJcbiAgcHVibGljIHNsaWRlckNvbG9yOiBDb2xvcjtcclxuICAvKiogVGhlIHJlYWN0aW9uIG9mIHRoaXMgVUlFbGVtZW50IHRvIGEgdmFsdWUgY2hhbmdlICovXHJcbiAgcHVibGljIG9uVmFsdWVDaGFuZ2U6IEZ1bmN0aW9uO1xyXG4gIC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCBieSB0aGlzIFVJRWxlbWVudCB3aGVuIHZhbHVlIGNoYW5nZXMgKi9cclxuICBwdWJsaWMgb25WYWx1ZUNoYW5nZUV2ZW50SWQ6IHN0cmluZztcclxuXHJcbiAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIGluaXRWYWx1ZTogbnVtYmVyKSB7XHJcbiAgICBzdXBlcihwb3NpdGlvbik7XHJcblxyXG4gICAgdGhpcy52YWx1ZSA9IGluaXRWYWx1ZTtcclxuICAgIHRoaXMubmliQ29sb3IgPSBDb2xvci5SRUQ7XHJcbiAgICB0aGlzLnNsaWRlckNvbG9yID0gQ29sb3IuQkxBQ0s7XHJcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgdGhpcy5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgdGhpcy5uaWJTaXplID0gbmV3IFZlYzIoMTAsIDIwKTtcclxuXHJcbiAgICAvLyBTZXQgYSBkZWZhdWx0IHNpemVcclxuICAgIHRoaXMuc2l6ZS5zZXQoMjAwLCAyMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIG9mIHRoZSBzbGlkZXJcclxuICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHNsaWRlclxyXG4gICAqL1xyXG4gIGdldFZhbHVlKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKiBBIG1ldGhvZCBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gdGhlIHZhbHVlIGNoYW5naW5nICovXHJcbiAgcHJvdGVjdGVkIHZhbHVlQ2hhbmdlZCgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLm9uVmFsdWVDaGFuZ2UpIHtcclxuICAgICAgdGhpcy5vblZhbHVlQ2hhbmdlKHRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm9uVmFsdWVDaGFuZ2VFdmVudElkKSB7XHJcbiAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vblZhbHVlQ2hhbmdlRXZlbnRJZCwge1xyXG4gICAgICAgIHRhcmdldDogdGhpcyxcclxuICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgIGlmICh0aGlzLmlzQ2xpY2tlZCkge1xyXG4gICAgICBsZXQgdmFsID0gTWF0aFV0aWxzLmludkxlcnAoXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54IC0gdGhpcy5zaXplLnggLyAyLFxyXG4gICAgICAgIHRoaXMucG9zaXRpb24ueCArIHRoaXMuc2l6ZS54IC8gMixcclxuICAgICAgICBJbnB1dC5nZXRNb3VzZVBvc2l0aW9uKCkueCxcclxuICAgICAgKTtcclxuICAgICAgdGhpcy52YWx1ZSA9IE1hdGhVdGlscy5jbGFtcDAxKHZhbCk7XHJcbiAgICAgIHRoaXMudmFsdWVDaGFuZ2VkKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi9MYWJlbFwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL0lucHV0L0lucHV0XCI7XHJcblxyXG4vKiogQSB0ZXh0IGlucHV0IFVJRWxlbWVudCAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0SW5wdXQgZXh0ZW5kcyBMYWJlbCB7XHJcbiAgLyoqIEEgZmxhZyB0aGUgcmVwcmVzZW50cyB3aGV0aGVyIHRoZSB1c2VyIGNhbiB0eXBlIGluIHRoaXMgVGV4dElucHV0ICovXHJcbiAgZm9jdXNlZDogYm9vbGVhbjtcclxuICAvKiogVGhlIHBvc2l0aW9uIG9mIHRoZSBjdXJzb3IgaW4gdGhpcyBUZXh0SW5wdXQgKi9cclxuICBjdXJzb3JDb3VudGVyOiBudW1iZXI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyKSB7XHJcbiAgICBzdXBlcihwb3NpdGlvbiwgXCJcIik7XHJcblxyXG4gICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLmN1cnNvckNvdW50ZXIgPSAwO1xyXG5cclxuICAgIC8vIEdpdmUgYSBkZWZhdWx0IHNpemUgdG8gdGhlIHggb25seVxyXG4gICAgdGhpcy5zaXplLnNldCgyMDAsIHRoaXMuZm9udFNpemUpO1xyXG4gICAgdGhpcy5oQWxpZ24gPSBcImxlZnRcIjtcclxuXHJcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gQ29sb3IuQkxBQ0s7XHJcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICBpZiAoSW5wdXQuaXNNb3VzZUp1c3RQcmVzc2VkKCkpIHtcclxuICAgICAgbGV0IGNsaWNrUG9zID0gSW5wdXQuZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5zKGNsaWNrUG9zLngsIGNsaWNrUG9zLnkpKSB7XHJcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmN1cnNvckNvdW50ZXIgPSAzMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmZvY3VzZWQpIHtcclxuICAgICAgbGV0IGtleXMgPSBJbnB1dC5nZXRLZXlzSnVzdFByZXNzZWQoKTtcclxuICAgICAgbGV0IG51bXMgPSBcIjEyMzQ1Njc4OTBcIjtcclxuICAgICAgbGV0IHNwZWNpYWxDaGFycyA9IFwiYH4hQCMkJV4mKigpLV89K1t7XX1cXFxcfDs6J1xcXCIsPC4+Lz9cIjtcclxuICAgICAgbGV0IGxldHRlcnMgPSBcInF3ZXJ0eXVpb3Bhc2RmZ2hqa2x6eGN2Ym5tXCI7XHJcbiAgICAgIGxldCBtYXNrID0gbnVtcyArIHNwZWNpYWxDaGFycyArIGxldHRlcnM7XHJcbiAgICAgIGtleXMgPSBrZXlzLmZpbHRlcihrZXkgPT4gbWFzay5pbmNsdWRlcyhrZXkpKTtcclxuICAgICAgbGV0IHNoaWZ0UHJlc3NlZCA9IElucHV0LmlzS2V5UHJlc3NlZChcInNoaWZ0XCIpO1xyXG4gICAgICBsZXQgYmFja3NwYWNlUHJlc3NlZCA9IElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJiYWNrc3BhY2VcIik7XHJcbiAgICAgIGxldCBzcGFjZVByZXNzZWQgPSBJbnB1dC5pc0tleUp1c3RQcmVzc2VkKFwic3BhY2VcIik7XHJcblxyXG4gICAgICBpZiAoYmFja3NwYWNlUHJlc3NlZCkge1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zdWJzdHJpbmcoMCwgdGhpcy50ZXh0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNwYWNlUHJlc3NlZCkge1xyXG4gICAgICAgIHRoaXMudGV4dCArPSBcIiBcIjtcclxuICAgICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBpZiAoc2hpZnRQcmVzc2VkKSB7XHJcbiAgICAgICAgICB0aGlzLnRleHQgKz0ga2V5c1swXS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnRleHQgKz0ga2V5c1swXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiZXhwb3J0IGVudW0gVUlFbGVtZW50VHlwZSB7XHJcbiAgQlVUVE9OID0gXCJCVVRUT05cIixcclxuICBMQUJFTCA9IFwiTEFCRUxcIixcclxuICBTTElERVIgPSBcIlNMSURFUlwiLFxyXG4gIFRFWFRfSU5QVVQgPSBcIlRFWFRJTlBVVFwiLFxyXG59XHJcbiIsImltcG9ydCBOYXZpZ2FibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL05hdmlnYWJsZVwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4vTmF2aWdhdGlvblBhdGhcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFuYWdlciBjbGFzcyBmb3IgbmF2aWdhdGlvbi5cclxuICogSGFuZGxlcyBhbGwgbmF2aWdhYmxlIGVudGl0aWVzLCBzdWNoIGFuZCBhbGxvd3MgdGhlbSB0byBiZSBhY2Nlc3NlZCBieSBvdXRzaWRlIHN5c3RlbXMgYnkgcmVxdWVzdGluZyBhIHBhdGhcclxuICogZnJvbSBvbmUgcG9zaXRpb24gdG8gYW5vdGhlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25NYW5hZ2VyIHtcclxuICAvKiogVGhlIGxpc3Qgb2YgYWxsIG5hdmlnYWJsZSBlbnRpdGllcyAqL1xyXG4gIHByb3RlY3RlZCBuYXZpZ2FibGVFbnRpdGllczogTWFwPE5hdmlnYWJsZT47XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5uYXZpZ2FibGVFbnRpdGllcyA9IG5ldyBNYXAoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBuYXZpZ2FibGUgZW50aXR5IHRvIHRoZSBOYXZpZ2F0aW9uTWFuYWdlclxyXG4gICAqIEBwYXJhbSBuYXZOYW1lIFRoZSBuYW1lIG9mIHRoZSBuYXZpZ2FibGUgZW50aXRyeVxyXG4gICAqIEBwYXJhbSBuYXYgVGhlIGFjdHVhbCBOYXZpZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBhZGROYXZpZ2FibGVFbnRpdHkobmF2TmFtZTogc3RyaW5nLCBuYXY6IE5hdmlnYWJsZSk6IHZvaWQge1xyXG4gICAgdGhpcy5uYXZpZ2FibGVFbnRpdGllcy5hZGQobmF2TmFtZSwgbmF2KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYSBwYXRoIGZyb21lIG9uZSBwb2ludCB0byBhbm90aGVyIHVzaW5nIGEgc3BlY2lmaWVkIE5hdmlnYWJsZSBvYmplY3RcclxuICAgKiBAcGFyYW0gbmF2TmFtZSBUaGUgbmFtZSBvZiB0aGUgcmVnaXN0ZXJlZCBOYXZpZ2FibGUgb2JqZWN0XHJcbiAgICogQHBhcmFtIGZyb21Qb3NpdGlvbiBUaGUgc3RhcnRpbmcgcG9zaXRpb24gb2YgbmF2aWdhdGlvblxyXG4gICAqIEBwYXJhbSB0b1Bvc2l0aW9uIFRoZSBlbmRpbmcgcG9zaXRpb24gb2YgTmF2aWdhdGlvblxyXG4gICAqIEBwYXJhbSBkaXJlY3QgSWYgdHJ1ZSwgZ28gZGlyZWN0IGZyb20gZnJvbVBvc2l0aW9uIHRvIHRvUG9zaXRpb24sIGRvbid0IHVzZSBOYXZNZXNoXHJcbiAgICogQHJldHVybnMgQSBOYXZpZ2F0aW9uUGF0aCBjb250YWluaW5nIHRoZSByb3V0ZSB0byB0YWtlIG92ZXIgdGhlIE5hdmlnYWJsZSBlbnRpdHkgdG8gZ2V0IGJldHdlZW4gdGhlIHByb3ZpZGVkIHBvc2l0aW9ucy5cclxuICAgKi9cclxuICBnZXRQYXRoKFxyXG4gICAgbmF2TmFtZTogc3RyaW5nLFxyXG4gICAgZnJvbVBvc2l0aW9uOiBWZWMyLFxyXG4gICAgdG9Qb3NpdGlvbjogVmVjMixcclxuICAgIGRpcmVjdD86IGJvb2xlYW4sXHJcbiAgKTogTmF2aWdhdGlvblBhdGgge1xyXG4gICAgbGV0IG5hdiA9IHRoaXMubmF2aWdhYmxlRW50aXRpZXMuZ2V0KG5hdk5hbWUpO1xyXG4gICAgcmV0dXJuIG5hdi5nZXROYXZpZ2F0aW9uUGF0aChcclxuICAgICAgZnJvbVBvc2l0aW9uLmNsb25lKCksXHJcbiAgICAgIHRvUG9zaXRpb24uY2xvbmUoKSxcclxuICAgICAgZGlyZWN0LFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFN0YWNrIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhY2tcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHBhdGggdGhhdCBBSXMgY2FuIGZvbGxvdy4gVXNlcyBmaW5pc2hNb3ZlKCkgaW4gUGh5c2ljYWwgdG8gZGV0ZXJtaW5lIHByb2dyZXNzIG9uIHRoZSByb3V0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdGlvblBhdGgge1xyXG4gIC8qKiBUaGUgbmF2aWdhdGlvbiBwYXRoLCBzdG9yZWQgYXMgYSBzdGFjayBvZiBuZXh0IHBvc2l0aW9ucyAqL1xyXG4gIHByb3RlY3RlZCBwYXRoOiBTdGFjazxWZWMyPjtcclxuICAvKiogVGhlIGN1cnJlbnQgZGlyZWN0aW9uIG9mIG1vdmVtZW50ICovXHJcbiAgcHJvdGVjdGVkIGN1cnJlbnRNb3ZlRGlyZWN0aW9uOiBWZWMyO1xyXG4gIC8qKiBUaGUgZGlzdGFuY2UgYSBub2RlIG11c3QgYmUgdG8gYSBwb2ludCB0byBjb25zaWRlciBpdCBhcyBoYXZpbmcgYXJyaXZlZCAqL1xyXG4gIHByb3RlY3RlZCBkaXN0YW5jZVRocmVzaG9sZDogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE5hdmlnYXRpb25QYXRoXHJcbiAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggb2Ygbm9kZXMgdG8gdGFrZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHBhdGg6IFN0YWNrPFZlYzI+KSB7XHJcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgdGhpcy5jdXJyZW50TW92ZURpcmVjdGlvbiA9IFZlYzIuWkVSTztcclxuICAgIHRoaXMuZGlzdGFuY2VUaHJlc2hvbGQgPSA0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgc3RhdHVzIG9mIG5hdmlnYXRpb24gYWxvbmcgdGhpcyBOYXZpZ2F0aW9uUGF0aFxyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG5vZGUgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGF0aCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgaXNEb25lKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMucGF0aC5pc0VtcHR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBtb3ZlbWVudCBkaXJlY3Rpb24gaW4gdGhlIGN1cnJlbnQgcG9zaXRpb24gYWxvbmcgdGhlIHBhdGhcclxuICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBtb3ZlIGFsb25nIHRoZSBwYXRoXHJcbiAgICogQHJldHVybnMgVGhlIG1vdmVtZW50IGRpcmVjdGlvbiBhcyBhIFZlYzJcclxuICAgKi9cclxuICBnZXRNb3ZlRGlyZWN0aW9uKG5vZGU6IEdhbWVOb2RlKTogVmVjMiB7XHJcbiAgICAvLyBSZXR1cm4gZGlyZWN0aW9uIHRvIG5leHQgcG9pbnQgaW4gdGhlIG5hdlxyXG4gICAgcmV0dXJuIG5vZGUucG9zaXRpb24uZGlyVG8odGhpcy5wYXRoLnBlZWsoKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoaXMgTmF2aWdhdGlvblBhdGggdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIEdhbWVOb2RlXHJcbiAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgbW92aW5nIGFsb25nIHRoZSBwYXRoXHJcbiAgICovXHJcbiAgaGFuZGxlUGF0aFByb2dyZXNzKG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XHJcbiAgICBpZiAoXHJcbiAgICAgIG5vZGUucG9zaXRpb24uZGlzdGFuY2VTcVRvKHRoaXMucGF0aC5wZWVrKCkpIDxcclxuICAgICAgdGhpcy5kaXN0YW5jZVRocmVzaG9sZCAqIHRoaXMuZGlzdGFuY2VUaHJlc2hvbGRcclxuICAgICkge1xyXG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIG91ciBub2RlLCBtb3ZlIG9uIHRvIHRoZSBuZXh0IGRlc3RpbmF0aW9uXHJcbiAgICAgIHRoaXMucGF0aC5wb3AoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKCk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBQb3NpdGlvbkdyYXBoIGZyb20gXCIuLi9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGhcIjtcclxuaW1wb3J0IE5hdmlnYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvTmF2aWdhYmxlXCI7XHJcbmltcG9ydCBTdGFjayBmcm9tIFwiLi4vRGF0YVR5cGVzL1N0YWNrXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR3JhcGhVdGlscyBmcm9tIFwiLi4vVXRpbHMvR3JhcGhVdGlsc1wiO1xyXG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4vTmF2aWdhdGlvblBhdGhcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIE5hdm1lc2guIE5hdm1lc2hlcyBhcmUgZ3JhcGhzIGluIHRoZSBnYW1lIHdvcmxkIGFsb25nIHdoaWNoIG5vZGVzIGNhbiBtb3ZlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2bWVzaCBpbXBsZW1lbnRzIE5hdmlnYWJsZSB7XHJcbiAgLyoqIFRoZSBncmFwaCBvZiBwb2ludHMgaW4gdGhlIE5hdk1lc2ggKi9cclxuICBwcm90ZWN0ZWQgZ3JhcGg6IFBvc2l0aW9uR3JhcGg7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgTmF2bWVzaCBmcm9tIHRoZSBwb2ludHMgaW4gdGhlIHNwZWVjaWZpZWQgZ3JhcGhcclxuICAgKiBAcGFyYW0gZ3JhcGggVGhlIGdyYXBoIHRvIGNvbnN0cnVjdCBhIG5hdm1lc2ggZnJvbVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBQb3NpdGlvbkdyYXBoKSB7XHJcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XHJcbiAgfVxyXG5cclxuICAvLyBAaW1wbGVtZW50ZWRcclxuICBnZXROYXZpZ2F0aW9uUGF0aChcclxuICAgIGZyb21Qb3NpdGlvbjogVmVjMixcclxuICAgIHRvUG9zaXRpb246IFZlYzIsXHJcbiAgICBkaXJlY3Q6IGJvb2xlYW4sXHJcbiAgKTogTmF2aWdhdGlvblBhdGgge1xyXG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5nZXRDbG9zZXN0Tm9kZShmcm9tUG9zaXRpb24pO1xyXG4gICAgbGV0IGVuZCA9IHRoaXMuZ2V0Q2xvc2VzdE5vZGUodG9Qb3NpdGlvbik7XHJcblxyXG4gICAgbGV0IHBhdGhTdGFjayA9IG5ldyBTdGFjazxWZWMyPih0aGlzLmdyYXBoLm51bVZlcnRpY2VzKTtcclxuXHJcbiAgICAvLyBQdXNoIHRoZSBmaW5hbCBwb3NpdGlvbiBhbmQgdGhlIGZpbmFsIHBvc2l0aW9uIGluIHRoZSBncmFwaFxyXG4gICAgcGF0aFN0YWNrLnB1c2godG9Qb3NpdGlvbi5jbG9uZSgpKTtcclxuXHJcbiAgICBpZiAoZGlyZWN0KSB7XHJcbiAgICAgIHJldHVybiBuZXcgTmF2aWdhdGlvblBhdGgocGF0aFN0YWNrKTtcclxuICAgIH1cclxuXHJcbiAgICBwYXRoU3RhY2sucHVzaCh0aGlzLmdyYXBoLnBvc2l0aW9uc1tlbmRdKTtcclxuXHJcbiAgICBsZXQgcGFyZW50ID0gR3JhcGhVdGlscy5kamlrc3RyYSh0aGlzLmdyYXBoLCBzdGFydCk7XHJcblxyXG4gICAgLy8gQWRkIGFsbCBwYXJlbnRzIGFsb25nIHRoZSBwYXRoXHJcbiAgICBsZXQgaSA9IGVuZDtcclxuICAgIHdoaWxlIChwYXJlbnRbaV0gIT09IC0xKSB7XHJcbiAgICAgIHBhdGhTdGFjay5wdXNoKHRoaXMuZ3JhcGgucG9zaXRpb25zW3BhcmVudFtpXV0pO1xyXG4gICAgICBpID0gcGFyZW50W2ldO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgTmF2aWdhdGlvblBhdGgocGF0aFN0YWNrKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGNsb3Nlc3Qgbm9kZSBpbiB0aGlzIE5hdm1lc2ggdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gcXVlcnlcclxuICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGNsb3Nlc3Qgbm9kZSBpbiB0aGUgTmF2bWVzaCB0byB0aGUgcG9zaXRpb25cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZ2V0Q2xvc2VzdE5vZGUocG9zaXRpb246IFZlYzIpOiBudW1iZXIge1xyXG4gICAgbGV0IG4gPSB0aGlzLmdyYXBoLm51bVZlcnRpY2VzO1xyXG4gICAgbGV0IGkgPSAxO1xyXG4gICAgbGV0IGluZGV4ID0gMDtcclxuICAgIGxldCBkaXN0ID0gcG9zaXRpb24uZGlzdGFuY2VTcVRvKHRoaXMuZ3JhcGgucG9zaXRpb25zWzBdKTtcclxuICAgIHdoaWxlIChpIDwgbikge1xyXG4gICAgICBsZXQgZCA9IHBvc2l0aW9uLmRpc3RhbmNlU3FUbyh0aGlzLmdyYXBoLnBvc2l0aW9uc1tpXSk7XHJcbiAgICAgIGlmIChkIDwgZGlzdCkge1xyXG4gICAgICAgIGRpc3QgPSBkO1xyXG4gICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgfVxyXG4gICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBQaHlzaWNhbCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcclxuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcclxuaW1wb3J0IFBoeXNpY3NNYW5hZ2VyIGZyb20gXCIuL1BoeXNpY3NNYW5hZ2VyXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IEFyZWFDb2xsaXNpb24gZnJvbSBcIi4uL0RhdGFUeXBlcy9QaHlzaWNzL0FyZWFDb2xsaXNpb25cIjtcclxuaW1wb3J0IFVuaXF1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVW5pcXVlXCI7XHJcblxyXG4vKipcclxuICogQUxHT1JJVEhNOlxyXG4gKiBcdEluIGFuIGVmZm9ydCB0byBrZWVwIHRoaW5ncyBzaW1wbGUgYW5kIHdvcmtpbmcgZWZmZWN0aXZlbHksIGVhY2ggZHluYW1pYyBub2RlIHdpbGwgcmVzb2x2ZSBpdHNcclxuICogXHRjb2xsaXNpb25zIGNvbnNpZGVyaW5nIHRoZSByZXN0IG9mIHRoZSB3b3JsZCBhcyBzdGF0aWMuXHJcbiAqXHJcbiAqIFx0Q29sbGlzaW9uIGRldGVjdGluZyB3aWxsIGhhcHBlbiBmaXJzdC4gVGhpcyBjYW4gYmUgY29uc2lkZXJlZCBhIGJyb2FkIHBoYXNlLCBidXQgaXQgaXMgbm90IGVzcGVjaWFsbHlcclxuICogXHRlZmZpY2llbnQsIGFzIGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgZm9yIHRoaXMgZ2FtZSBlbmdpbmUuIEV2ZXJ5IGR5bmFtaWMgbm9kZSBpcyBjaGVja2VkIGFnYWluc3QgZXZlcnlcclxuICogXHRvdGhlciBub2RlIGZvciBjb2xsaXNpb24gYXJlYS4gSWYgY29sbGlzaW9uIGFyZWEgaXMgbm9uLXplcm8gKG1lYW5pbmcgdGhlIGN1cnJlbnQgbm9kZSBzd2VlcHMgaW50byBhbm90aGVyKSxcclxuICogXHRpdCBpcyBhZGRlZCB0byBhIGxpc3Qgb2YgaGl0cy5cclxuICpcclxuICogXHRJTklUSUFMSVpBVElPTjpcclxuICogXHRcdC0gUGh5c2ljcyBjb25zdGFudHMgYXJlIHJlc2V0XHJcbiAqIFx0XHQtIFN3ZXB0IHNoYXBlcyBhcmUgcmVjYWxjdWxhdGVkLiBJZiBhIG5vZGUgaXNuJ3QgbW92aW5nLCBpdCBpcyBza2lwcGVkLlxyXG4gKlxyXG4gKiBcdENPTExJU0lPTiBERVRFQ1RJT046XHJcbiAqIFx0XHQtIEZvciBhIG5vZGUsIGNvbGxpc2lvbiBhcmVhIHdpbGwgYmUgY2FsY3VsYXRlZCB1c2luZyB0aGUgc3dlcHQgQUFCQiBvZiB0aGUgbm9kZSBhZ2FpbnN0IGV2ZXJ5IG90aGVyIEFBQkIgaW4gYSBzdGF0aWMgc3RhdGVcclxuICogXHRcdC0gVGhlc2UgY29sbGlzaW9ucyB3aWxsIGJlIHNvcnRlZCBieSBhcmVhIGluIGRlc2NlbmRpbmcgb3JkZXJcclxuICpcclxuICogXHRDT0xMSVNJT04gUkVTT0xVVElPTjpcclxuICogXHRcdC0gRm9yIGVhY2ggaGl0LCB0aW1lIG9mIGNvbGxpc2lvbiBpcyBjYWxjdWxhdGVkIHVzaW5nIGEgc3dlcHQgbGluZSB0aHJvdWdoIHRoZSBBQUJCIG9mIHRoZSBzdGF0aWMgbm9kZSBleHBhbmRlZFxyXG4gKiBcdFx0XHR3aXRoIG1pbmtvd3NraSBzdW1zIChkaXNjcmV0ZWx5LCBidXQgdGhlIGNvbmNlcHQgaXMgdGhlcmUpXHJcbiAqIFx0XHQtIFRoZSBjb2xsaXNpb24gaXMgcmVzb2x2ZWQgYmFzZWQgb24gdGhlIG5lYXIgdGltZSBvZiB0aGUgY29sbGlzaW9uIChmcm9tIG1ldGhvZCBvZiBzZXBhcmF0ZWQgYXhlcylcclxuICogXHRcdFx0LSBYIGlzIHJlc29sdmVkIGJ5IG5lYXIgeCwgWSBieSBuZWFyIHkuXHJcbiAqIFx0XHRcdC0gVGhlcmUgaXMgc29tZSBmdWRnaW5nIHRvIGFsbG93IGZvciBzbGlkaW5nIGFsb25nIHdhbGxzIG9mIHNlcGFyYXRlIGNvbGxpZGVycy4gU29ydGluZyBieSBhcmVhIGFsc28gaGVscHMgd2l0aCB0aGlzLlxyXG4gKiBcdFx0XHQtIENvcm5lciB0byBjb3JuZXIgY29sbGlzaW9ucyBhcmUgcmVzb2x2ZSB0byBmYXZvciB4LW1vdmVtZW50LiBUaGlzIGlzIGluIGNvbnNpZGVyYXRpb24gb2YgcGxhdGZvcm1lcnMsIHRvIGdpdmVcclxuICogXHRcdFx0XHR0aGUgcGxheWVyIHNvbWUgaGVscCB3aXRoIGp1bXBzXHJcbiAqXHJcbiAqIFx0UHJvczpcclxuICogXHRcdC0gRXZlcnl0aGluZyBoYXBwZW5zIHdpdGggYSBjb25zaXN0ZW50IHRpbWUuIFRoZXJlIGlzIGEgZGlzdGluY3QgYmVmb3JlIGFuZCBhZnRlciBmb3IgZWFjaCByZXNvbHV0aW9uLlxyXG4gKiBcdFx0LSBObyBiYWNrLXRyYWNraW5nIG5lZWRzIHRvIGJlIGRvbmUuIE9uY2Ugd2UgcmVzb2x2ZSBhIG5vZGUsIGl0IGlzIGRlZmluaXRpdmVseSByZXNvbHZlZC5cclxuICpcclxuICogXHRDb25zOlxyXG4gKiBcdFx0LSBOb2RlcyB0aGF0IGFyZSBwcm9jZXNzZWQgZWFybHkgaGF2ZSBtb3ZlbWVudCBwcmlvcml0eSBvdmVyIG90aGVyIG5vZGVzLiBUaGlzIGNhbiBsZWFkIHRvIHNvbWUgdW5kZXNpcmFibGUgaW50ZXJhY3Rpb25zLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNQaHlzaWNzTWFuYWdlciBleHRlbmRzIFBoeXNpY3NNYW5hZ2VyIHtcclxuICAvKiogVGhlIGFycmF5IG9mIHN0YXRpYyBub2RlcyAqL1xyXG4gIHByb3RlY3RlZCBzdGF0aWNOb2RlczogQXJyYXk8UGh5c2ljYWw+O1xyXG5cclxuICAvKiogVGhlIGFycmF5IG9mIGR5bmFtaWMgbm9kZXMgKi9cclxuICBwcm90ZWN0ZWQgZHluYW1pY05vZGVzOiBBcnJheTxQaHlzaWNhbD47XHJcblxyXG4gIC8qKiBUaGUgYXJyYXkgb2YgdGlsZW1hcHMgKi9cclxuICBwcm90ZWN0ZWQgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xyXG5cclxuICAvKiogQW4gYXJyYXkgb2YgdGhlIGNvbGxpc2lvbiBtYXNrcyBmb3IgZWFjaCBncm91cCAqL1xyXG4gIHByb3RlY3RlZCBjb2xsaXNpb25NYXNrczogQXJyYXk8bnVtYmVyPjtcclxuXHJcbiAgY29uc3RydWN0b3Iob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pikge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuc3RhdGljTm9kZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgIHRoaXMuZHluYW1pY05vZGVzID0gbmV3IEFycmF5KCk7XHJcbiAgICB0aGlzLnRpbGVtYXBzID0gbmV3IEFycmF5KCk7XHJcbiAgICB0aGlzLmNvbGxpc2lvbk1hc2tzID0gbmV3IEFycmF5KDMyKTtcclxuXHJcbiAgICAvLyBQYXJzZSBvcHRpb25zXHJcbiAgICB0aGlzLnBhcnNlT3B0aW9ucyhvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhcnNlcyB0aGUgb3B0aW9ucyBmb3IgY29uc3RydWN0aW5nIHRoZSBwaHlzaWNzIG1hbmFnZXJcclxuICAgKiBAcGFyYW0gb3B0aW9ucyBBIHJlY29yZCBvZiBvcHRpb25zXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIHBhcnNlT3B0aW9ucyhvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcbiAgICBpZiAob3B0aW9ucy5ncm91cE5hbWVzICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5jb2xsaXNpb25zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmdyb3VwTmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgZ3JvdXAgPSBvcHRpb25zLmdyb3VwTmFtZXNbaV07XHJcblxyXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBncm91cCBuYW1lIGFuZCBudW1iZXJcclxuICAgICAgICB0aGlzLmdyb3VwTmFtZXNbaV0gPSBncm91cDtcclxuXHJcbiAgICAgICAgdGhpcy5ncm91cE1hcC5zZXQoZ3JvdXAsIDEgPDwgaSk7XHJcblxyXG4gICAgICAgIGxldCBjb2xsaXNpb25NYXNrID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvcHRpb25zLmNvbGxpc2lvbnNbaV0ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIGlmIChvcHRpb25zLmNvbGxpc2lvbnNbaV1bal0pIHtcclxuICAgICAgICAgICAgY29sbGlzaW9uTWFzayB8PSAxIDw8IGo7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbGxpc2lvbk1hc2tzW2ldID0gY29sbGlzaW9uTWFzaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQG92ZXJyaWRlXHJcbiAgcmVnaXN0ZXJPYmplY3Qobm9kZTogUGh5c2ljYWwpOiB2b2lkIHtcclxuICAgIGlmIChub2RlLmlzU3RhdGljKSB7XHJcbiAgICAgIC8vIFN0YXRpYyBhbmQgbm90IGNvbGxpZGFibGVcclxuICAgICAgdGhpcy5zdGF0aWNOb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gRHluYW1pYyBhbmQgbm90IGNvbGxpZGFibGVcclxuICAgICAgdGhpcy5keW5hbWljTm9kZXMucHVzaChub2RlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEBvdmVycmlkZVxyXG4gIGRlcmVnaXN0ZXJPYmplY3Qobm9kZTogUGh5c2ljYWwpOiB2b2lkIHtcclxuICAgIGlmIChub2RlLmlzU3RhdGljKSB7XHJcbiAgICAgIC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBzdGF0aWMgbGlzdFxyXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RhdGljTm9kZXMuaW5kZXhPZihub2RlKTtcclxuICAgICAgdGhpcy5zdGF0aWNOb2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIGR5bmFtaWMgbGlzdFxyXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZHluYW1pY05vZGVzLmluZGV4T2Yobm9kZSk7XHJcbiAgICAgIHRoaXMuZHluYW1pY05vZGVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICByZWdpc3RlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xyXG4gICAgdGhpcy50aWxlbWFwcy5wdXNoKHRpbGVtYXApO1xyXG4gIH1cclxuXHJcbiAgLy8gQG92ZXJyaWRlXHJcbiAgZGVyZWdpc3RlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnRpbGVtYXBzLmluZGV4T2YodGlsZW1hcCk7XHJcbiAgICB0aGlzLnRpbGVtYXBzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgfVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGZvciAobGV0IG5vZGUgb2YgdGhpcy5keW5hbWljTm9kZXMpIHtcclxuICAgICAgLyotLS0tLS0tLS0tIElOSVRJQUxJWkFUSU9OIFBIQVNFIC0tLS0tLS0tLS0qL1xyXG4gICAgICAvLyBDbGVhciBmcmFtZSBkZXBlbmRlbnQgYm9vbGVhbiB2YWx1ZXMgZm9yIGVhY2ggbm9kZVxyXG4gICAgICBub2RlLm9uR3JvdW5kID0gZmFsc2U7XHJcbiAgICAgIG5vZGUub25DZWlsaW5nID0gZmFsc2U7XHJcbiAgICAgIG5vZGUub25XYWxsID0gZmFsc2U7XHJcbiAgICAgIG5vZGUuY29sbGlkZWRXaXRoVGlsZW1hcCA9IGZhbHNlO1xyXG4gICAgICBub2RlLmlzQ29sbGlkaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAvLyBJZiB0aGlzIG5vZGUgaXMgbm90IGFjdGl2ZSwgZG9uJ3QgcHJvY2VzcyBpdFxyXG4gICAgICBpZiAoIW5vZGUuYWN0aXZlKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgc3dlcHQgc2hhcGVzIG9mIGVhY2ggbm9kZVxyXG4gICAgICBpZiAobm9kZS5tb3ZpbmcpIHtcclxuICAgICAgICAvLyBJZiBtb3ZpbmcsIHJlZmxlY3QgdGhhdCBpbiB0aGUgc3dlcHQgc2hhcGVcclxuICAgICAgICBub2RlLnN3ZXB0UmVjdC5zd2VlcChcclxuICAgICAgICAgIG5vZGUuX3ZlbG9jaXR5LFxyXG4gICAgICAgICAgbm9kZS5jb2xsaXNpb25TaGFwZS5jZW50ZXIsXHJcbiAgICAgICAgICBub2RlLmNvbGxpc2lvblNoYXBlLmhhbGZTaXplLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSWYgb3VyIG5vZGUgaXNuJ3QgbW92aW5nLCBkb24ndCBib3RoZXIgdG8gY2hlY2sgaXQgKG90aGVyIG5vZGVzIHdpbGwgZGV0ZWN0IGlmIHRoZXkgcnVuIGludG8gaXQpXHJcbiAgICAgICAgbm9kZS5fdmVsb2NpdHkuemVybygpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKi0tLS0tLS0tLS0gREVURUNUSU9OIFBIQVNFIC0tLS0tLS0tLS0qL1xyXG4gICAgICAvLyBHYXRoZXIgYSBzZXQgb2Ygb3ZlcmxhcHNcclxuICAgICAgbGV0IG92ZXJsYXBzID0gbmV3IEFycmF5PEFyZWFDb2xsaXNpb24+KCk7XHJcblxyXG4gICAgICBsZXQgZ3JvdXBJbmRleCA9IG5vZGUuZ3JvdXAgPT09IC0xID8gLTEgOiBNYXRoLmxvZzIobm9kZS5ncm91cCk7XHJcblxyXG4gICAgICAvLyBGaXJzdCwgY2hlY2sgdGhpcyBub2RlIGFnYWluc3QgZXZlcnkgc3RhdGljIG5vZGUgKG9yZGVyIGRvZXNuJ3QgYWN0dWFsbHkgbWF0dGVyIGhlcmUsIHNpbmNlIHdlIHNvcnQgYW55d2F5cylcclxuICAgICAgZm9yIChsZXQgb3RoZXIgb2YgdGhpcy5zdGF0aWNOb2Rlcykge1xyXG4gICAgICAgIC8vIElnbm9yZSBpbmFjdGl2ZSBub2Rlc1xyXG4gICAgICAgIGlmICghb3RoZXIuYWN0aXZlKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgbGV0IGNvbGxpZGVyID0gb3RoZXIuY29sbGlzaW9uU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgbGV0IGFyZWEgPSBub2RlLnN3ZXB0UmVjdC5vdmVybGFwQXJlYShjb2xsaWRlcik7XHJcbiAgICAgICAgaWYgKGFyZWEgPiAwKSB7XHJcbiAgICAgICAgICAvLyBXZSBoYWQgYSBjb2xsaXNpb25cclxuICAgICAgICAgIG92ZXJsYXBzLnB1c2goXHJcbiAgICAgICAgICAgIG5ldyBBcmVhQ29sbGlzaW9uKGFyZWEsIGNvbGxpZGVyLCBvdGhlciwgXCJHYW1lTm9kZVwiLCBudWxsKSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGVuLCBjaGVjayBpdCBhZ2FpbnN0IGV2ZXJ5IGR5bmFtaWMgbm9kZVxyXG4gICAgICBmb3IgKGxldCBvdGhlciBvZiB0aGlzLmR5bmFtaWNOb2Rlcykge1xyXG4gICAgICAgIC8vIElnbm9yZSBvdXJzZWx2ZXNcclxuICAgICAgICBpZiAobm9kZSA9PT0gb3RoZXIpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAvLyBJZ25vcmUgaW5hY3RpdmUgbm9kZXNcclxuICAgICAgICBpZiAoIW90aGVyLmFjdGl2ZSkgY29udGludWU7XHJcblxyXG4gICAgICAgIGxldCBjb2xsaWRlciA9IG90aGVyLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIGxldCBhcmVhID0gbm9kZS5zd2VwdFJlY3Qub3ZlcmxhcEFyZWEoY29sbGlkZXIpO1xyXG4gICAgICAgIGlmIChhcmVhID4gMCkge1xyXG4gICAgICAgICAgLy8gV2UgaGFkIGEgY29sbGlzaW9uXHJcbiAgICAgICAgICBvdmVybGFwcy5wdXNoKFxyXG4gICAgICAgICAgICBuZXcgQXJlYUNvbGxpc2lvbihhcmVhLCBjb2xsaWRlciwgb3RoZXIsIFwiR2FtZU5vZGVcIiwgbnVsbCksXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTGFzdGx5LCBnYXRoZXIgYSBzZXQgb2YgQUFCQnMgZnJvbSB0aGUgdGlsZW1hcC5cclxuICAgICAgLy8gVGhpcyBzdGVwIGludm9sdmVzIHRoZSBtb3N0IGV4dHJhIHdvcmssIHNvIGl0IGlzIGFic3RyYWN0ZWQgaW50byBhIG1ldGhvZFxyXG4gICAgICBmb3IgKGxldCB0aWxlbWFwIG9mIHRoaXMudGlsZW1hcHMpIHtcclxuICAgICAgICAvLyBJZ25vcmUgaW5hY3RpdmUgdGlsZW1hcHNcclxuICAgICAgICBpZiAoIXRpbGVtYXAuYWN0aXZlKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgaWYgKHRpbGVtYXAgaW5zdGFuY2VvZiBPcnRob2dvbmFsVGlsZW1hcCkge1xyXG4gICAgICAgICAgdGhpcy5jb2xsaWRlV2l0aE9ydGhvZ29uYWxUaWxlbWFwKG5vZGUsIHRpbGVtYXAsIG92ZXJsYXBzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNvcnQgdGhlIG92ZXJsYXBzIGJ5IGFyZWFcclxuICAgICAgb3ZlcmxhcHMgPSBvdmVybGFwcy5zb3J0KChhLCBiKSA9PiBiLmFyZWEgLSBhLmFyZWEpO1xyXG5cclxuICAgICAgLy8gS2VlcCB0cmFjayBvZiBoaXRzIHRvIHVzZSBsYXRlclxyXG4gICAgICBsZXQgaGl0cyA9IFtdO1xyXG5cclxuICAgICAgLyotLS0tLS0tLS0tIFJFU09MVVRJT04gUEhBU0UgLS0tLS0tLS0tLSovXHJcbiAgICAgIC8vIEZvciBldmVyeSBvdmVybGFwLCBkZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBjb2xsaWRlIHdpdGggaXQgYW5kIHdoZW5cclxuICAgICAgZm9yIChsZXQgb3ZlcmxhcCBvZiBvdmVybGFwcykge1xyXG4gICAgICAgIC8vIElnbm9yZSBub2RlcyB3ZSBkb24ndCBpbnRlcmFjdCB3aXRoXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgZ3JvdXBJbmRleCAhPT0gLTEgJiZcclxuICAgICAgICAgIG92ZXJsYXAub3RoZXIuZ3JvdXAgIT09IC0xICYmXHJcbiAgICAgICAgICAodGhpcy5jb2xsaXNpb25NYXNrc1tncm91cEluZGV4XSAmIG92ZXJsYXAub3RoZXIuZ3JvdXApID09PSAwXHJcbiAgICAgICAgKVxyXG4gICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgIC8vIERvIGEgc3dlcHQgbGluZSB0ZXN0IG9uIHRoZSBzdGF0aWMgQUFCQiB3aXRoIHRoaXMgQUFCQiBzaXplIGFzIHBhZGRpbmcgKHRoaXMgaXMgYmFzaWNhbGx5IHVzaW5nIGEgbWlua293c2tpIHN1bSEpXHJcbiAgICAgICAgLy8gU3RhcnQgdGhlIHN3ZWVwIGF0IHRoZSBwb3NpdGlvbiBvZiB0aGlzIG5vZGUgd2l0aCBhIGRlbHRhIG9mIF92ZWxvY2l0eVxyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gbm9kZS5jb2xsaXNpb25TaGFwZS5jZW50ZXI7XHJcbiAgICAgICAgY29uc3QgZGVsdGEgPSBub2RlLl92ZWxvY2l0eTtcclxuICAgICAgICBjb25zdCBwYWRkaW5nID0gbm9kZS5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZTtcclxuICAgICAgICBjb25zdCBvdGhlckFBQkIgPSBvdmVybGFwLmNvbGxpZGVyO1xyXG5cclxuICAgICAgICBjb25zdCBoaXQgPSBvdGhlckFBQkIuaW50ZXJzZWN0U2VnbWVudChcclxuICAgICAgICAgIG5vZGUuY29sbGlzaW9uU2hhcGUuY2VudGVyLFxyXG4gICAgICAgICAgbm9kZS5fdmVsb2NpdHksXHJcbiAgICAgICAgICBub2RlLmNvbGxpc2lvblNoYXBlLmhhbGZTaXplLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIG92ZXJsYXAuaGl0ID0gaGl0O1xyXG5cclxuICAgICAgICBpZiAoaGl0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBoaXRzLnB1c2goaGl0KTtcclxuXHJcbiAgICAgICAgICAvLyBXZSBnb3QgYSBoaXQsIHJlc29sdmUgd2l0aCB0aGUgdGltZSBpbnNpZGUgb2YgdGhlIGhpdFxyXG4gICAgICAgICAgbGV0IHRuZWFyeCA9IGhpdC5uZWFyVGltZXMueDtcclxuICAgICAgICAgIGxldCB0bmVhcnkgPSBoaXQubmVhclRpbWVzLnk7XHJcblxyXG4gICAgICAgICAgLy8gQWxsb3cgZWRnZSBjbGlwcGluZyAoZWRnZSBvdmVybGFwcyBkb24ndCBjb3VudCwgb25seSBhcmVhIG92ZXJsYXBzKVxyXG4gICAgICAgICAgLy8gSW1wb3J0YW50bHkgZG9uJ3QgYWxsb3cgYm90aCBjYXNlcyB0byBiZSB0cnVlLiBUaGVuIHdlIGNsaXAgdGhyb3VnaCBjb3JuZXJzLiBGYXZvciB4IHRvIGhlbHAgcGxheWVycyBsYW5kIGp1bXBzXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHRuZWFyeCA8IDEuMCAmJlxyXG4gICAgICAgICAgICAocG9pbnQueSA9PT0gb3RoZXJBQUJCLnRvcCAtIHBhZGRpbmcueSB8fFxyXG4gICAgICAgICAgICAgIHBvaW50LnkgPT09IG90aGVyQUFCQi5ib3R0b20gKyBwYWRkaW5nLnkpICYmXHJcbiAgICAgICAgICAgIGRlbHRhLnggIT09IDBcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICB0bmVhcnggPSAxLjA7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICB0bmVhcnkgPCAxLjAgJiZcclxuICAgICAgICAgICAgKHBvaW50LnggPT09IG90aGVyQUFCQi5sZWZ0IC0gcGFkZGluZy54IHx8XHJcbiAgICAgICAgICAgICAgcG9pbnQueCA9PT0gb3RoZXJBQUJCLnJpZ2h0ICsgcGFkZGluZy54KSAmJlxyXG4gICAgICAgICAgICBkZWx0YS55ICE9PSAwXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdG5lYXJ5ID0gMS4wO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChoaXQubmVhclRpbWVzLnggPj0gMCAmJiBoaXQubmVhclRpbWVzLnggPCAxKSB7XHJcbiAgICAgICAgICAgIC8vIEFueSB0aWxlbWFwIG9iamVjdHMgdGhhdCBtYWRlIGl0IGhlcmUgYXJlIGNvbGxpZGFibGVcclxuICAgICAgICAgICAgaWYgKG92ZXJsYXAudHlwZSA9PT0gXCJUaWxlbWFwXCIgfHwgb3ZlcmxhcC5vdGhlci5pc0NvbGxpZGFibGUpIHtcclxuICAgICAgICAgICAgICBub2RlLl92ZWxvY2l0eS54ID0gbm9kZS5fdmVsb2NpdHkueCAqIHRuZWFyeDtcclxuICAgICAgICAgICAgICBub2RlLmlzQ29sbGlkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChoaXQubmVhclRpbWVzLnkgPj0gMCAmJiBoaXQubmVhclRpbWVzLnkgPCAxKSB7XHJcbiAgICAgICAgICAgIC8vIEFueSB0aWxlbWFwIG9iamVjdHMgdGhhdCBtYWRlIGl0IGhlcmUgYXJlIGNvbGxpZGFibGVcclxuICAgICAgICAgICAgaWYgKG92ZXJsYXAudHlwZSA9PT0gXCJUaWxlbWFwXCIgfHwgb3ZlcmxhcC5vdGhlci5pc0NvbGxpZGFibGUpIHtcclxuICAgICAgICAgICAgICBub2RlLl92ZWxvY2l0eS55ID0gbm9kZS5fdmVsb2NpdHkueSAqIHRuZWFyeTtcclxuICAgICAgICAgICAgICBub2RlLmlzQ29sbGlkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLyotLS0tLS0tLS0tIElORk9STUFUSU9OL1RSSUdHRVIgUEhBU0UgLS0tLS0tLS0tLSovXHJcbiAgICAgIC8vIENoZWNrIGlmIHdlIGVuZGVkIHVwIG9uIHRoZSBncm91bmQsIGNlaWxpbmcgb3Igd2FsbFxyXG4gICAgICAvLyBBbHNvIGNoZWNrIGZvciB0cmlnZ2Vyc1xyXG4gICAgICBmb3IgKGxldCBvdmVybGFwIG9mIG92ZXJsYXBzKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgdHJpZ2dlci4gSWYgd2UgY2FyZSBhYm91dCB0aGUgdHJpZ2dlciwgcmVhY3RcclxuICAgICAgICBpZiAob3ZlcmxhcC5vdGhlci5pc1RyaWdnZXIgJiYgb3ZlcmxhcC5vdGhlci50cmlnZ2VyTWFzayAmIG5vZGUuZ3JvdXApIHtcclxuICAgICAgICAgIC8vIEdldCB0aGUgYml0IHRoYXQgdGhpcyBncm91cCBpcyByZXByZXNlbnRlZCBieVxyXG4gICAgICAgICAgbGV0IGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIobm9kZS5ncm91cCkpO1xyXG5cclxuICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIHRyaWdnZXJFbnRlciBldmVudCBuYW1lXHJcbiAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KG92ZXJsYXAub3RoZXIudHJpZ2dlckVudGVyc1tpbmRleF0sIHtcclxuICAgICAgICAgICAgbm9kZTogKDxHYW1lTm9kZT5ub2RlKS5pZCxcclxuICAgICAgICAgICAgb3RoZXI6ICg8R2FtZU5vZGU+b3ZlcmxhcC5vdGhlcikuaWQsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElnbm9yZSBjb2xsaXNpb24gc2lkZXMgZm9yIG5vZGVzIHdlIGRvbid0IGludGVyYWN0IHdpdGhcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBncm91cEluZGV4ICE9PSAtMSAmJlxyXG4gICAgICAgICAgb3ZlcmxhcC5vdGhlci5ncm91cCAhPT0gLTEgJiZcclxuICAgICAgICAgICh0aGlzLmNvbGxpc2lvbk1hc2tzW2dyb3VwSW5kZXhdICYgb3ZlcmxhcC5vdGhlci5ncm91cCkgPT09IDBcclxuICAgICAgICApXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgLy8gT25seSBjaGVjayBmb3IgZGlyZWN0aW9uIGlmIHRoZSBvdmVybGFwIHdhcyBjb2xsaWRhYmxlXHJcbiAgICAgICAgaWYgKG92ZXJsYXAudHlwZSA9PT0gXCJUaWxlbWFwXCIgfHwgb3ZlcmxhcC5vdGhlci5pc0NvbGxpZGFibGUpIHtcclxuICAgICAgICAgIGxldCBjb2xsaXNpb25TaWRlID0gb3ZlcmxhcC5jb2xsaWRlci50b3VjaGVzQUFCQldpdGhvdXRDb3JuZXJzKFxyXG4gICAgICAgICAgICBub2RlLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGlmIChjb2xsaXNpb25TaWRlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIHRvdWNoLCBub3QgaW5jbHVkaW5nIGNvcm5lciBjYXNlcywgY2hlY2sgdGhlIGNvbGxpc2lvbiBub3JtYWxcclxuICAgICAgICAgICAgaWYgKG92ZXJsYXAuaGl0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgLy8gSWYgd2UgaGl0IGEgdGlsZW1hcCwga2VlcCB0cmFjayBvZiBpdFxyXG4gICAgICAgICAgICAgIGlmIChvdmVybGFwLnR5cGUgPT0gXCJUaWxlbWFwXCIpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuY29sbGlkZWRXaXRoVGlsZW1hcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uU2lkZS55ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSBpcyBvbiB0b3Agb2Ygb3ZlcmxhcCwgc28gb25Hcm91bmRcclxuICAgICAgICAgICAgICAgIG5vZGUub25Hcm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sbGlzaW9uU2lkZS55ID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIGlzIG9uIGJvdHRvbSBvZiBvdmVybGFwLCBzbyBvbkNlaWxpbmdcclxuICAgICAgICAgICAgICAgIG5vZGUub25DZWlsaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSB3YXNuJ3QgdG91Y2hpbmcgb24geSwgc28gaXQgaXMgdG91Y2hpbmcgb24geFxyXG4gICAgICAgICAgICAgICAgbm9kZS5vbldhbGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVzb2x2ZSB0aGUgY29sbGlzaW9uIHdpdGggdGhlIG5vZGUsIGFuZCBtb3ZlIGl0XHJcbiAgICAgIG5vZGUuZmluaXNoTW92ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBhIGNvbGxpc2lvbiBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgYW4gb3J0aG9nb25hbCB0aWxlbWFwXHJcbiAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGVcclxuICAgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0aGUgbm9kZSBtYXkgYmUgY29sbGlkaW5nIHdpdGhcclxuICAgKiBAcGFyYW0gb3ZlcmxhcHMgVGhlIGxpc3Qgb2Ygb3ZlcmxhcHNcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgY29sbGlkZVdpdGhPcnRob2dvbmFsVGlsZW1hcChcclxuICAgIG5vZGU6IFBoeXNpY2FsLFxyXG4gICAgdGlsZW1hcDogT3J0aG9nb25hbFRpbGVtYXAsXHJcbiAgICBvdmVybGFwczogQXJyYXk8QXJlYUNvbGxpc2lvbj4sXHJcbiAgKTogdm9pZCB7XHJcbiAgICAvLyBHZXQgdGhlIG1pbiBhbmQgbWF4IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdmluZyBub2RlXHJcbiAgICBsZXQgbWluID0gbmV3IFZlYzIobm9kZS5zd2VwdFJlY3QubGVmdCwgbm9kZS5zd2VwdFJlY3QudG9wKTtcclxuICAgIGxldCBtYXggPSBuZXcgVmVjMihub2RlLnN3ZXB0UmVjdC5yaWdodCwgbm9kZS5zd2VwdFJlY3QuYm90dG9tKTtcclxuXHJcbiAgICAvLyBDb252ZXJ0IHRoZSBtaW4vbWF4IHgveSB0byB0aGUgbWluIGFuZCBtYXggcm93L2NvbCBpbiB0aGUgdGlsZW1hcCBhcnJheVxyXG4gICAgbGV0IG1pbkluZGV4ID0gdGlsZW1hcC5nZXRDb2xSb3dBdChtaW4pO1xyXG4gICAgbGV0IG1heEluZGV4ID0gdGlsZW1hcC5nZXRDb2xSb3dBdChtYXgpO1xyXG5cclxuICAgIGxldCB0aWxlU2l6ZSA9IHRpbGVtYXAuZ2V0VGlsZVNpemUoKTtcclxuXHJcbiAgICAvLyBMb29wIG92ZXIgYWxsIHBvc3NpYmxlIHRpbGVzICh3aGljaCBpc24ndCBtYW55IGluIHRoZSBzY29wZSBvZiB0aGUgdmVsb2NpdHkgcGVyIGZyYW1lKVxyXG4gICAgZm9yIChsZXQgY29sID0gbWluSW5kZXgueDsgY29sIDw9IG1heEluZGV4Lng7IGNvbCsrKSB7XHJcbiAgICAgIGZvciAobGV0IHJvdyA9IG1pbkluZGV4Lnk7IHJvdyA8PSBtYXhJbmRleC55OyByb3crKykge1xyXG4gICAgICAgIGlmICh0aWxlbWFwLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKSB7XHJcbiAgICAgICAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdGlsZVxyXG4gICAgICAgICAgbGV0IHRpbGVQb3MgPSBuZXcgVmVjMihcclxuICAgICAgICAgICAgY29sICogdGlsZVNpemUueCArIHRpbGVTaXplLnggLyAyLFxyXG4gICAgICAgICAgICByb3cgKiB0aWxlU2l6ZS55ICsgdGlsZVNpemUueSAvIDIsXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb2xsaWRlciBmb3IgdGhpcyB0aWxlXHJcbiAgICAgICAgICBsZXQgY29sbGlkZXIgPSBuZXcgQUFCQih0aWxlUG9zLCB0aWxlU2l6ZS5zY2FsZWQoMSAvIDIpKTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgY29sbGlzaW9uIGFyZWEgYmV0d2VlbiB0aGUgbm9kZSBhbmQgdGhlIHRpbGVcclxuICAgICAgICAgIGxldCBhcmVhID0gbm9kZS5zd2VwdFJlY3Qub3ZlcmxhcEFyZWEoY29sbGlkZXIpO1xyXG4gICAgICAgICAgaWYgKGFyZWEgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhZCBhIGNvbGxpc2lvblxyXG4gICAgICAgICAgICBvdmVybGFwcy5wdXNoKFxyXG4gICAgICAgICAgICAgIG5ldyBBcmVhQ29sbGlzaW9uKFxyXG4gICAgICAgICAgICAgICAgYXJlYSxcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyLFxyXG4gICAgICAgICAgICAgICAgdGlsZW1hcCxcclxuICAgICAgICAgICAgICAgIFwiVGlsZW1hcFwiLFxyXG4gICAgICAgICAgICAgICAgbmV3IFZlYzIoY29sLCByb3cpLFxyXG4gICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XHJcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi9FdmVudHMvRW1pdHRlclwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBQaHlzaWNhbCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBwaHlzaWNzIG1hbmFnZXIuXHJcbiAqIFRoaXMgY2xhc3MgZXhwb3NlcyBmdW5jdGlvbnMgZm9yIHN1YmNsYXNzZXMgdG8gaW1wbGVtZW50IHRoYXQgc2hvdWxkIGFsbG93IGZvciBhIHdvcmtpbmcgcGh5c2ljcyBzeXN0ZW0gdG8gYmUgY3JlYXRlZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFBoeXNpY3NNYW5hZ2VyIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XHJcbiAgLyoqIFRoZSBldmVudCByZWNlaXZlciBmb3IgdGhlIHBoeXNpY3Mgc3lzdGVtICovXHJcbiAgcHJvdGVjdGVkIHJlY2VpdmVyOiBSZWNlaXZlcjtcclxuICAvKiogVGhlIGV2ZW50IGVtaXR0ZXIgZm9yIHRoZSBwaHlzaWNzIHN5c3RlbSAqL1xyXG4gIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xyXG5cclxuICAvKiogTWFwcyBsYXllciBuYW1lcyB0byBudW1iZXJzICovXHJcbiAgcHJvdGVjdGVkIGdyb3VwTWFwOiBNYXA8bnVtYmVyPjtcclxuXHJcbiAgLyoqIE1hcHMgbGF5ZXIgbnVtYmVycyB0byBuYW1lcyAqL1xyXG4gIHByb3RlY3RlZCBncm91cE5hbWVzOiBBcnJheTxzdHJpbmc+O1xyXG5cclxuICAvKiogVGhlIGRlZmF1bHQgZ3JvdXAgbmFtZSAqL1xyXG4gIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9HUk9VUDogc3RyaW5nID0gXCJEZWZhdWx0XCI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xyXG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuXHJcbiAgICAvLyBUaGUgY3JlYXRpb24gYW5kIGltcGxlbWVudGF0aW9uIG9mIGxheWVycyBpcyBkZWZlcnJlZCB0byB0aGUgc3ViY2xhc3NcclxuICAgIHRoaXMuZ3JvdXBNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmdyb3VwTmFtZXMgPSBuZXcgQXJyYXkoKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICB0aGlzLnJlY2VpdmVyLmRlc3Ryb3koKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVycyBhIGdhbWVub2RlIHdpdGggdGhpcyBwaHlzaWNzIG1hbmFnZXJcclxuICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcmVnaXN0ZXJcclxuICAgKi9cclxuICBhYnN0cmFjdCByZWdpc3Rlck9iamVjdChvYmplY3Q6IFBoeXNpY2FsKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyByZWZlcmVuY2VzIHRvIHRoaXMgb2JqZWN0IGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlcnJcclxuICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gZGVyZWdpc3RlclxyXG4gICAqL1xyXG4gIGFic3RyYWN0IGRlcmVnaXN0ZXJPYmplY3Qob2JqZWN0OiBQaHlzaWNhbCk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVycyBhIHRpbGVtYXAgd2l0aCB0aGlzIHBoeXNpY3MgbWFuYWdlclxyXG4gICAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRvIHJlZ2lzdGVyXHJcbiAgICovXHJcbiAgYWJzdHJhY3QgcmVnaXN0ZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIHJlZmVyZW5jZXMgdG8gdGhpcyB0aWxlbWFwIGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlcnJcclxuICAgKiBAcGFyYW0gdGlsZW1hcCBUaGUgb2JqZWN0IHRvIGRlcmVnaXN0ZXJcclxuICAgKi9cclxuICBhYnN0cmFjdCBkZXJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZDtcclxuXHJcbiAgYWJzdHJhY3QgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgcGh5c2ljcyBsYXllciBvZiB0aGUgR2FtZU5vZGVcclxuICAgKiBAcGFyYW0gbm9kZSBUaGUgR2FtZU5vZGVcclxuICAgKiBAcGFyYW0gZ3JvdXAgVGhlIGdyb3VwIHRoYXQgdGhlIEdhbWVOb2RlIHNob3VsZCBiZSBvblxyXG4gICAqL1xyXG4gIHNldEdyb3VwKG5vZGU6IFBoeXNpY2FsLCBncm91cDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBub2RlLmdyb3VwID0gdGhpcy5ncm91cE1hcC5nZXQoZ3JvdXApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmVzIHRoZSBsYXllciBudW1iZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBuYW1lXHJcbiAgICogQHBhcmFtIGxheWVyIFRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG4gICAqIEByZXR1cm5zIFRoZSBsYXllciBudW1iZXIsIG9yIDAgaWYgdGhlcmUgaXMgbm90IGEgbGF5ZXIgd2l0aCB0aGF0IG5hbWUgcmVnaXN0ZXJlZFxyXG4gICAqL1xyXG4gIGdldEdyb3VwTnVtYmVyKGdyb3VwOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgaWYgKHRoaXMuZ3JvdXBNYXAuaGFzKGdyb3VwKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5ncm91cE1hcC5nZXQoZ3JvdXApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFsbCBncm91cCBuYW1lcyBhc3NvY2lhdGVkIHdpdGggdGhlIG51bWJlciBwcm92aWRlZFxyXG4gICAqIEBwYXJhbSBncm91cHMgQSBtYXNrIG9mIGdyb3Vwc1xyXG4gICAqIEByZXR1cm5zIEFsbCBncm91cHMgY29udGFpbmVkIGluIHRoZSBtYXNrXHJcbiAgICovXHJcbiAgZ2V0R3JvdXBOYW1lcyhncm91cHM6IG51bWJlcik6IEFycmF5PHN0cmluZz4ge1xyXG4gICAgaWYgKGdyb3VwcyA9PT0gLTEpIHtcclxuICAgICAgcmV0dXJuIFtQaHlzaWNzTWFuYWdlci5ERUZBVUxUX0dST1VQXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxldCBnID0gMTtcclxuICAgICAgbGV0IG5hbWVzID0gW107XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcclxuICAgICAgICBpZiAoZyAmIGdyb3Vwcykge1xyXG4gICAgICAgICAgLy8gVGhpcyBncm91cCBpcyBpbiB0aGUgZ3JvdXBzIG51bWJlclxyXG4gICAgICAgICAgbmFtZXMucHVzaCh0aGlzLmdyb3VwTmFtZXNbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2hpZnQgdGhlIGJpdCBvdmVyXHJcbiAgICAgICAgZyA9IGcgPDwgMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuLi9FdmVudHMvRXZlbnRRdWV1ZVwiO1xyXG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRUeXBlXCI7XHJcblxyXG4vLyBAaWdub3JlUGFnZVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjb3JkZXIge1xyXG4gIHByaXZhdGUgcmVjZWl2ZXI6IFJlY2VpdmVyO1xyXG4gIHByaXZhdGUgbG9nOiBRdWV1ZTxMb2dJdGVtPjtcclxuICBwcml2YXRlIHJlY29yZGluZzogYm9vbGVhbjtcclxuICBwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XHJcbiAgcHJpdmF0ZSBmcmFtZTogbnVtYmVyO1xyXG4gIHByaXZhdGUgcGxheWluZzogYm9vbGVhbjtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XHJcbiAgICB0aGlzLmxvZyA9IG5ldyBRdWV1ZSgxMDAwKTtcclxuICAgIHRoaXMucmVjb3JkaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuZnJhbWUgPSAwO1xyXG5cclxuICAgIHRoaXMuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcclxuICAgIHRoaXMuZXZlbnRRdWV1ZS5zdWJzY3JpYmUodGhpcy5yZWNlaXZlciwgXCJhbGxcIik7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnJlY29yZGluZykge1xyXG4gICAgICB0aGlzLmZyYW1lICs9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucGxheWluZykge1xyXG4gICAgICAvLyBJZiBwbGF5aW5nLCBpZ25vcmUgZXZlbnRzLCBqdXN0IGZlZWQgdGhlIHJlY29yZCB0byB0aGUgZXZlbnQgcXVldWVcclxuICAgICAgdGhpcy5yZWNlaXZlci5pZ25vcmVFdmVudHMoKTtcclxuXHJcbiAgICAgIC8qXHJcblx0XHRcdFx0V2hpbGUgdGhlcmUgaXMgYSBuZXh0IGl0ZW0sIGFuZCB3aGlsZSBpdCBzaG91bGQgb2NjdXIgaW4gdGhpcyBmcmFtZSxcclxuXHRcdFx0XHRzZW5kIHRoZSBldmVudC4gaS5lLiwgd2hpbGUgY3VycmVudF9mcmFtZSAqIGN1cnJlbnRfZGVsdGFfdCBpcyBncmVhdGVyXHJcblx0XHRcdFx0dGhhbiByZWNvcmRlZF9mcmFtZSAqIHJlY29yZGVkX2RlbHRhX3RcclxuXHRcdFx0Ki9cclxuICAgICAgd2hpbGUgKFxyXG4gICAgICAgIHRoaXMubG9nLmhhc0l0ZW1zKCkgJiZcclxuICAgICAgICB0aGlzLmxvZy5wZWVrTmV4dCgpLmZyYW1lICogdGhpcy5sb2cucGVla05leHQoKS5kZWx0YSA8XHJcbiAgICAgICAgICB0aGlzLmZyYW1lICogZGVsdGFUXHJcbiAgICAgICkge1xyXG4gICAgICAgIGxldCBldmVudCA9IHRoaXMubG9nLmRlcXVldWUoKS5ldmVudDtcclxuICAgICAgICBjb25zb2xlLmxvZyhldmVudCk7XHJcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGV2ZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF0aGlzLmxvZy5oYXNJdGVtcygpKSB7XHJcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZnJhbWUgKz0gMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIElmIG5vdCBwbGF5aW5nLCBoYW5kbGUgZXZlbnRzXHJcbiAgICAgIHdoaWxlICh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuXHJcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuU1RPUF9SRUNPUkRJTkcpIHtcclxuICAgICAgICAgIHRoaXMucmVjb3JkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5yZWNvcmRpbmcpIHtcclxuICAgICAgICAgIHRoaXMubG9nLmVucXVldWUobmV3IExvZ0l0ZW0odGhpcy5mcmFtZSwgZGVsdGFULCBldmVudCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuU1RBUlRfUkVDT1JESU5HKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5jbGVhcigpO1xyXG4gICAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgdGhpcy5mcmFtZSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5QTEFZX1JFQ09SRElORykge1xyXG4gICAgICAgICAgdGhpcy5mcmFtZSA9IDA7XHJcbiAgICAgICAgICB0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgdGhpcy5wbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIExvZ0l0ZW0ge1xyXG4gIGZyYW1lOiBudW1iZXI7XHJcbiAgZGVsdGE6IG51bWJlcjtcclxuICBldmVudDogR2FtZUV2ZW50O1xyXG5cclxuICBjb25zdHJ1Y3RvcihmcmFtZTogbnVtYmVyLCBkZWx0YVQ6IG51bWJlciwgZXZlbnQ6IEdhbWVFdmVudCkge1xyXG4gICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xyXG4gICAgdGhpcy5kZWx0YSA9IGRlbHRhVDtcclxuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5cclxuLyoqICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFJlZ2lzdHJ5PFQ+IGV4dGVuZHMgTWFwPFQ+IHtcclxuICAvKiogUHJlbG9hZHMgcmVnaXN0cnkgZGF0YSAqL1xyXG4gIHB1YmxpYyBhYnN0cmFjdCBwcmVsb2FkKCk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVycyBhbiBpdGVtIGFuZCBwcmVsb2FkcyBhbnkgbmVjZXNzYXJ5IGZpbGVzXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHJlZ2lzdGVyIHRoaXMgaXRlbSB3aXRoXHJcbiAgICogQHBhcmFtIGFyZ3MgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIG5lZWRlZCBmb3IgcmVnaXN0cmF0aW9uXHJcbiAgICovXHJcbiAgcHVibGljIGFic3RyYWN0IHJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oa2V5OiBzdHJpbmcsIC4uLmFyZ3M6IGFueSk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVycyBhbiBpdGVtIGFuZCBwcmVsb2FkcyBhbnkgbmVjZXNzYXJ5IGZpbGVzXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHJlZ2lzdGVyIHRoaXMgaXRlbSB3aXRoXHJcbiAgICogQHBhcmFtIGFyZ3MgQW55IGFkaXRpb25hbCBhcmd1bWVudHMgbmVlZGVkIGZvciByZWdpc3RyYXRpb25cclxuICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgcmVnaXN0ZXJJdGVtKGtleTogc3RyaW5nLCAuLi5hcmdzOiBhbnkpOiB2b2lkO1xyXG59XHJcbiIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlXCI7XHJcbmltcG9ydCBMYWJlbFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9MYWJlbFNoYWRlclR5cGVcIjtcclxuaW1wb3J0IFBvaW50U2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1BvaW50U2hhZGVyVHlwZVwiO1xyXG5pbXBvcnQgUmVjdFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9SZWN0U2hhZGVyVHlwZVwiO1xyXG5pbXBvcnQgU3ByaXRlU2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1Nwcml0ZVNoYWRlclR5cGVcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgUmVnaXN0cnkgZnJvbSBcIi4vUmVnaXN0cnlcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHJlZ2lzdHJ5IHRoYXQgaGFuZGxlcyBzaGFkZXJzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJSZWdpc3RyeSBleHRlbmRzIFJlZ2lzdHJ5PFNoYWRlclR5cGU+IHtcclxuICAvLyBTaGFkZXIgbmFtZXNcclxuICBwdWJsaWMgc3RhdGljIFBPSU5UX1NIQURFUiA9IFwicG9pbnRcIjtcclxuICBwdWJsaWMgc3RhdGljIFJFQ1RfU0hBREVSID0gXCJyZWN0XCI7XHJcbiAgcHVibGljIHN0YXRpYyBTUFJJVEVfU0hBREVSID0gXCJzcHJpdGVcIjtcclxuICBwdWJsaWMgc3RhdGljIExBQkVMX1NIQURFUiA9IFwibGFiZWxcIjtcclxuXHJcbiAgcHJpdmF0ZSByZWdpc3RyeUl0ZW1zOiBBcnJheTxTaGFkZXJSZWdpc3RyeUl0ZW0+ID0gbmV3IEFycmF5KCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZWxvYWRzIGFsbCBidWlsdC1pbiBzaGFkZXJzXHJcbiAgICovXHJcbiAgcHVibGljIHByZWxvYWQoKSB7XHJcbiAgICAvLyBHZXQgdGhlIHJlc291cmNlTWFuYWdlciBhbmQgcXVldWUgYWxsIGJ1aWx0LWluIHNoYWRlcnMgZm9yIHByZWxvYWRpbmdcclxuICAgIGNvbnN0IHJtID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcblxyXG4gICAgLy8gUXVldWUgYSBsb2FkIGZvciB0aGUgcG9pbnQgc2hhZGVyXHJcbiAgICB0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oXHJcbiAgICAgIFNoYWRlclJlZ2lzdHJ5LlBPSU5UX1NIQURFUixcclxuICAgICAgUG9pbnRTaGFkZXJUeXBlLFxyXG4gICAgICBcImJ1aWx0aW4vc2hhZGVycy9wb2ludC52c2hhZGVyXCIsXHJcbiAgICAgIFwiYnVpbHRpbi9zaGFkZXJzL3BvaW50LmZzaGFkZXJcIixcclxuICAgICk7XHJcblxyXG4gICAgLy8gUXVldWUgYSBsb2FkIGZvciB0aGUgcmVjdCBzaGFkZXJcclxuICAgIHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShcclxuICAgICAgU2hhZGVyUmVnaXN0cnkuUkVDVF9TSEFERVIsXHJcbiAgICAgIFJlY3RTaGFkZXJUeXBlLFxyXG4gICAgICBcImJ1aWx0aW4vc2hhZGVycy9yZWN0LnZzaGFkZXJcIixcclxuICAgICAgXCJidWlsdGluL3NoYWRlcnMvcmVjdC5mc2hhZGVyXCIsXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFF1ZXVlIGEgbG9hZCBmb3IgdGhlIHNwcml0ZSBzaGFkZXJcclxuICAgIHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShcclxuICAgICAgU2hhZGVyUmVnaXN0cnkuU1BSSVRFX1NIQURFUixcclxuICAgICAgU3ByaXRlU2hhZGVyVHlwZSxcclxuICAgICAgXCJidWlsdGluL3NoYWRlcnMvc3ByaXRlLnZzaGFkZXJcIixcclxuICAgICAgXCJidWlsdGluL3NoYWRlcnMvc3ByaXRlLmZzaGFkZXJcIixcclxuICAgICk7XHJcblxyXG4gICAgLy8gUXVldWUgYSBsb2FkIGZvciB0aGUgbGFiZWwgc2hhZGVyXHJcbiAgICB0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oXHJcbiAgICAgIFNoYWRlclJlZ2lzdHJ5LkxBQkVMX1NIQURFUixcclxuICAgICAgTGFiZWxTaGFkZXJUeXBlLFxyXG4gICAgICBcImJ1aWx0aW4vc2hhZGVycy9sYWJlbC52c2hhZGVyXCIsXHJcbiAgICAgIFwiYnVpbHRpbi9zaGFkZXJzL2xhYmVsLmZzaGFkZXJcIixcclxuICAgICk7XHJcblxyXG4gICAgLy8gUXVldWUgYSBsb2FkIGZvciBhbnkgcHJlbG9hZGVkIGl0ZW1zXHJcbiAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMucmVnaXN0cnlJdGVtcykge1xyXG4gICAgICBjb25zdCBzaGFkZXIgPSBuZXcgaXRlbS5jb25zdHIoaXRlbS5rZXkpO1xyXG4gICAgICBzaGFkZXIuaW5pdEJ1ZmZlck9iamVjdCgpO1xyXG4gICAgICB0aGlzLmFkZChpdGVtLmtleSwgc2hhZGVyKTtcclxuXHJcbiAgICAgIC8vIExvYWQgaWYgZGVzaXJlZFxyXG4gICAgICBpZiAoaXRlbS5wcmVsb2FkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBybS5zaGFkZXIoXHJcbiAgICAgICAgICBpdGVtLmtleSxcclxuICAgICAgICAgIGl0ZW0ucHJlbG9hZC52c2hhZGVyTG9jYXRpb24sXHJcbiAgICAgICAgICBpdGVtLnByZWxvYWQuZnNoYWRlckxvY2F0aW9uLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVycyBhIHNoYWRlciBpbiB0aGUgcmVnaXN0cnkgYW5kIGxvYWRzIGl0IGJlZm9yZSB0aGUgZ2FtZSBiZWdpbnNcclxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgeW91IHdpc2ggdG8gYXNzaWduIHRvIHRoZSBzaGFkZXJcclxuICAgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgU2hhZGVyVHlwZVxyXG4gICAqIEBwYXJhbSB2c2hhZGVyTG9jYXRpb24gVGhlIGxvY2F0aW9uIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyXHJcbiAgICogQHBhcmFtIGZzaGFkZXJMb2NhdGlvbiB0aGUgbG9jYXRpb24gb2YgdGhlIGZyYWdtZW50IHNoYWRlclxyXG4gICAqL1xyXG4gIHB1YmxpYyByZWdpc3RlckFuZFByZWxvYWRJdGVtKFxyXG4gICAga2V5OiBzdHJpbmcsXHJcbiAgICBjb25zdHI6IG5ldyAocHJvZ3JhbUtleTogc3RyaW5nKSA9PiBTaGFkZXJUeXBlLFxyXG4gICAgdnNoYWRlckxvY2F0aW9uOiBzdHJpbmcsXHJcbiAgICBmc2hhZGVyTG9jYXRpb246IHN0cmluZyxcclxuICApOiB2b2lkIHtcclxuICAgIGxldCBzaGFkZXJQcmVsb2FkID0gbmV3IFNoYWRlclByZWxvYWQoKTtcclxuICAgIHNoYWRlclByZWxvYWQudnNoYWRlckxvY2F0aW9uID0gdnNoYWRlckxvY2F0aW9uO1xyXG4gICAgc2hhZGVyUHJlbG9hZC5mc2hhZGVyTG9jYXRpb24gPSBmc2hhZGVyTG9jYXRpb247XHJcblxyXG4gICAgbGV0IHJlZ2lzdHJ5SXRlbSA9IG5ldyBTaGFkZXJSZWdpc3RyeUl0ZW0oKTtcclxuICAgIHJlZ2lzdHJ5SXRlbS5rZXkgPSBrZXk7XHJcbiAgICByZWdpc3RyeUl0ZW0uY29uc3RyID0gY29uc3RyO1xyXG4gICAgcmVnaXN0cnlJdGVtLnByZWxvYWQgPSBzaGFkZXJQcmVsb2FkO1xyXG5cclxuICAgIHRoaXMucmVnaXN0cnlJdGVtcy5wdXNoKHJlZ2lzdHJ5SXRlbSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RlcnMgYSBzaGFkZXIgaW4gdGhlIHJlZ2lzdHJ5LiBOT1RFOiBJZiB5b3UgdXNlIHRoaXMsIHlvdSBNVVNUIGxvYWQgdGhlIHNoYWRlciBiZWZvcmUgdXNlLlxyXG4gICAqIElmIHlvdSB3aXNoIHRvIHByZWxvYWQgdGhlIHNoYWRlciwgdXNlIHJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oKVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSB5b3Ugd2lzaCB0byBhc3NpZ24gdG8gdGhlIHNoYWRlclxyXG4gICAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBTaGFkZXJUeXBlXHJcbiAgICovXHJcbiAgcHVibGljIHJlZ2lzdGVySXRlbShcclxuICAgIGtleTogc3RyaW5nLFxyXG4gICAgY29uc3RyOiBuZXcgKHByb2dyYW1LZXk6IHN0cmluZykgPT4gU2hhZGVyVHlwZSxcclxuICApOiB2b2lkIHtcclxuICAgIGxldCByZWdpc3RyeUl0ZW0gPSBuZXcgU2hhZGVyUmVnaXN0cnlJdGVtKCk7XHJcbiAgICByZWdpc3RyeUl0ZW0ua2V5ID0ga2V5O1xyXG4gICAgcmVnaXN0cnlJdGVtLmNvbnN0ciA9IGNvbnN0cjtcclxuXHJcbiAgICB0aGlzLnJlZ2lzdHJ5SXRlbXMucHVzaChyZWdpc3RyeUl0ZW0pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgU2hhZGVyUmVnaXN0cnlJdGVtIHtcclxuICBrZXk6IHN0cmluZztcclxuICBjb25zdHI6IG5ldyAocHJvZ3JhbUtleTogc3RyaW5nKSA9PiBTaGFkZXJUeXBlO1xyXG4gIHByZWxvYWQ6IFNoYWRlclByZWxvYWQ7XHJcbn1cclxuXHJcbmNsYXNzIFNoYWRlclByZWxvYWQge1xyXG4gIHZzaGFkZXJMb2NhdGlvbjogc3RyaW5nO1xyXG4gIGZzaGFkZXJMb2NhdGlvbjogc3RyaW5nO1xyXG59XHJcbiIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gXCIuL1JlZ2lzdHJpZXMvUmVnaXN0cnlcIjtcclxuaW1wb3J0IFNoYWRlclJlZ2lzdHJ5IGZyb20gXCIuL1JlZ2lzdHJpZXMvU2hhZGVyUmVnaXN0cnlcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgUmVnaXN0cnkgaXMgdGhlIHN5c3RlbSdzIHdheSBvZiBjb252ZXJ0aW5nIGNsYXNzZXMgYW5kIHR5cGVzIGludG8gc3RyaW5nXHJcbiAqIHJlcHJlc2VudGF0aW9ucyBmb3IgdXNlIGVsc2V3aGVyZSBpbiB0aGUgYXBwbGljYXRpb24uXHJcbiAqIEl0IGFsbG93cyBjbGFzc2VzIHRvIGJlIGFjY2Vzc2VkIHdpdGhvdXQgZXhwbGljaXRseSB1c2luZyBjb25zdHJ1Y3RvcnMgaW4gY29kZSxcclxuICogYW5kIGZvciByZXNvdXJjZXMgdG8gYmUgbG9hZGVkIGF0IEdhbWUgY3JlYXRpb24gdGltZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ2lzdHJ5TWFuYWdlciB7XHJcbiAgcHVibGljIHN0YXRpYyBzaGFkZXJzID0gbmV3IFNoYWRlclJlZ2lzdHJ5KCk7XHJcblxyXG4gIC8qKiBBZGRpdGlvbmFsIGN1c3RvbSByZWdpc3RyaWVzIHRvIGFkZCB0byB0aGUgcmVnaXN0cnkgbWFuYWdlciAqL1xyXG4gIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0cmllczogTWFwPFJlZ2lzdHJ5PGFueT4+ID0gbmV3IE1hcCgpO1xyXG5cclxuICBzdGF0aWMgcHJlbG9hZCgpIHtcclxuICAgIHRoaXMuc2hhZGVycy5wcmVsb2FkKCk7XHJcblxyXG4gICAgdGhpcy5yZWdpc3RyaWVzLmZvckVhY2goKGtleTogc3RyaW5nKSA9PlxyXG4gICAgICB0aGlzLnJlZ2lzdHJpZXMuZ2V0KGtleSkucHJlbG9hZCgpLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBhZGRDdXN0b21SZWdpc3RyeShuYW1lOiBzdHJpbmcsIHJlZ2lzdHJ5OiBSZWdpc3RyeTxhbnk+KSB7XHJcbiAgICB0aGlzLnJlZ2lzdHJpZXMuYWRkKG5hbWUsIHJlZ2lzdHJ5KTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRSZWdpc3RyeShrZXk6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cmllcy5nZXQoa2V5KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IHtcclxuICBBbmltYXRpb25EYXRhLFxyXG4gIEFuaW1hdGlvbkZyYW1lLFxyXG4gIEFuaW1hdGlvblN0YXRlLFxyXG59IGZyb20gXCIuL0FuaW1hdGlvblR5cGVzXCI7XHJcblxyXG4vKipcclxuICogQW4gYW5pbWF0aW9uIG1hbmFnZXIgY2xhc3MgZm9yIGFuIGFuaW1hdGVkIENhbnZhc05vZGUuXHJcbiAqIFRoaXMgY2xhc3Mga2VlcHMgdHJhY2sgb2YgdGhlIHBvc3NpYmxlIGFuaW1hdGlvbnMsIGFzIHdlbGwgYXMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0YXRlLFxyXG4gKiBhbmQgYWJzdHJhY3RzIGFsbCBpbnRlcmFjdGlvbnMgd2l0aCBwbGF5aW5nLCBwYXVzaW5nLCBhbmQgc3RvcHBpbmcgYW5pbWF0aW9ucyBhcyB3ZWxsIGFzXHJcbiAqIGNyZWF0aW5nIG5ldyBhbmltYXRpb25zIGZyb20gdGhlIENhbnZhc05vZGUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25NYW5hZ2VyIHtcclxuICAvKiogVGhlIG93bmVyIG9mIHRoaXMgYW5pbWF0aW9uIG1hbmFnZXIgKi9cclxuICBwcm90ZWN0ZWQgb3duZXI6IENhbnZhc05vZGU7XHJcblxyXG4gIC8qKiBUaGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUgb2YgdGhpcyBzcHJpdGUgKi9cclxuICBwcm90ZWN0ZWQgYW5pbWF0aW9uU3RhdGU6IEFuaW1hdGlvblN0YXRlO1xyXG5cclxuICAvKiogVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIG9mIHRoaXMgc3ByaXRlICovXHJcbiAgcHJvdGVjdGVkIGN1cnJlbnRBbmltYXRpb246IHN0cmluZztcclxuXHJcbiAgLyoqIFRoZSBjdXJyZW50IGZyYW1lIG9mIHRoaXMgYW5pbWF0aW9uICovXHJcbiAgcHJvdGVjdGVkIGN1cnJlbnRGcmFtZTogbnVtYmVyO1xyXG5cclxuICAvKiogVGhlIHByb2dyZXNzIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbiB0aHJvdWdoIHRoZSBjdXJyZW50IGZyYW1lICovXHJcbiAgcHJvdGVjdGVkIGZyYW1lUHJvZ3Jlc3M6IG51bWJlcjtcclxuXHJcbiAgLyoqIFdoZXRoZXIgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGlzIGxvb3Bpbmcgb3Igbm90ICovXHJcbiAgcHJvdGVjdGVkIGxvb3A6IGJvb2xlYW47XHJcblxyXG4gIC8qKiBUaGUgbWFwIG9mIGFuaW1hdGlvbnMgKi9cclxuICBwcm90ZWN0ZWQgYW5pbWF0aW9uczogTWFwPEFuaW1hdGlvbkRhdGE+O1xyXG5cclxuICAvKiogVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChpZiBhbnkpIHRvIHNlbmQgd2hlbiB0aGUgY3VycmVudCBhbmltYXRpb24gc3RvcHMgcGxheWluZy4gKi9cclxuICBwcm90ZWN0ZWQgb25FbmRFdmVudDogc3RyaW5nO1xyXG5cclxuICAvKiogVGhlIGV2ZW50IGVtaXR0ZXIgZm9yIHRoaXMgYW5pbWF0aW9uIG1hbmFnZXIgKi9cclxuICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcclxuXHJcbiAgLyoqIEEgcXVldWVkIGFuaW1hdGlvbiAqL1xyXG4gIHByb3RlY3RlZCBwZW5kaW5nQW5pbWF0aW9uOiBzdHJpbmc7XHJcblxyXG4gIC8qKiBUaGUgbG9vcCBzdGF0dXMgb2YgYSBwZW5kaW5nIGFuaW1hdGlvbiAqL1xyXG4gIHByb3RlY3RlZCBwZW5kaW5nTG9vcDogYm9vbGVhbjtcclxuXHJcbiAgLyoqIFRoZSBvbkVuZCBldmVudCBvZiBhIHBlbmRpbmcgYW5pbWF0aW9uICovXHJcbiAgcHJvdGVjdGVkIHBlbmRpbmdPbkVuZDogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IEFuaW1hdGlvbk1hbmFnZXJcclxuICAgKiBAcGFyYW0gb3duZXIgVGhlIG93bmVyIG9mIHRoZSBBbmltYXRpb25NYW5hZ2VyXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3duZXI6IENhbnZhc05vZGUpIHtcclxuICAgIHRoaXMub3duZXIgPSBvd25lcjtcclxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xyXG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gXCJcIjtcclxuICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XHJcbiAgICB0aGlzLmxvb3AgPSBmYWxzZTtcclxuICAgIHRoaXMuYW5pbWF0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMub25FbmRFdmVudCA9IG51bGw7XHJcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGFuIGFuaW1hdGlvbiB0byB0aGlzIHNwcml0ZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIHVuaXF1ZSBrZXkgb2YgdGhlIGFuaW1hdGlvblxyXG4gICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIGFuaW1hdGlvbiBkYXRhXHJcbiAgICovXHJcbiAgYWRkKGtleTogc3RyaW5nLCBhbmltYXRpb246IEFuaW1hdGlvbkRhdGEpOiB2b2lkIHtcclxuICAgIHRoaXMuYW5pbWF0aW9ucy5hZGQoa2V5LCBhbmltYXRpb24pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgaW5kZXggc3BlY2lmaWVkIGJ5IHRoZSBjdXJyZW50IGFuaW1hdGlvbiBhbmQgY3VycmVudCBmcmFtZVxyXG4gICAqIEByZXR1cm5zIFRoZSBpbmRleCBpbiB0aGUgY3VycmVudCBhbmltYXRpb25cclxuICAgKi9cclxuICBnZXRJbmRleCgpOiBudW1iZXIge1xyXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9ucy5oYXModGhpcy5jdXJyZW50QW5pbWF0aW9uKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25zLmdldCh0aGlzLmN1cnJlbnRBbmltYXRpb24pLmZyYW1lc1tcclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZVxyXG4gICAgICBdLmluZGV4O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gTm8gY3VycmVudCBhbmltYXRpb24sIHdhcm4gdGhlIHVzZXJcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIGBBbmltYXRpb24gaW5kZXggd2FzIHJlcXVlc3RlZCwgYnV0IHRoZSBjdXJyZW50IGFuaW1hdGlvbjogJHt0aGlzLmN1cnJlbnRBbmltYXRpb259IHdhcyBpbnZhbGlkYCxcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRBbmltYXRpb25EYXRhKCk6IEFuaW1hdGlvbkZyYW1lIHtcclxuICAgIGlmICh0aGlzLmFuaW1hdGlvbnMuaGFzKHRoaXMuY3VycmVudEFuaW1hdGlvbikpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9ucy5nZXQodGhpcy5jdXJyZW50QW5pbWF0aW9uKS5mcmFtZXNbXHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVcclxuICAgICAgXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBpcyBjdXJyZW50bHkgcGxheWluZ1xyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgYW5pbWF0aW9uIHRvIGNoZWNrXHJcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBpcyBwbGF5aW5nLCBmYWxzZSBvdGhlcndpc2VcclxuICAgKi9cclxuICBpc1BsYXlpbmcoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9PT0ga2V5ICYmXHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBMQVlJTkdcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGluZGV4IGFuZCBhZHZhbmNlcyB0aGUgYW5pbWF0aW9uIGZyYW1lXHJcbiAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBhbmltYXRpb24gZnJhbWVcclxuICAgKi9cclxuICBnZXRJbmRleEFuZEFkdmFuY2VBbmltYXRpb24oKTogbnVtYmVyIHtcclxuICAgIC8vIElmIHdlIGFyZW4ndCBwbGF5aW5nLCB3ZSB3b24ndCBiZSBhZHZhbmNpbmcgdGhlIGFuaW1hdGlvblxyXG4gICAgaWYgKCEodGhpcy5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUExBWUlORykpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5kZXgoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5hbmltYXRpb25zLmhhcyh0aGlzLmN1cnJlbnRBbmltYXRpb24pKSB7XHJcbiAgICAgIGxldCBjdXJyZW50QW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zLmdldCh0aGlzLmN1cnJlbnRBbmltYXRpb24pO1xyXG4gICAgICBsZXQgaW5kZXggPSBjdXJyZW50QW5pbWF0aW9uLmZyYW1lc1t0aGlzLmN1cnJlbnRGcmFtZV0uaW5kZXg7XHJcblxyXG4gICAgICAvLyBBZHZhbmNlIHRoZSBhbmltYXRpb25cclxuICAgICAgdGhpcy5mcmFtZVByb2dyZXNzICs9IDE7XHJcbiAgICAgIGlmIChcclxuICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPj1cclxuICAgICAgICBjdXJyZW50QW5pbWF0aW9uLmZyYW1lc1t0aGlzLmN1cnJlbnRGcmFtZV0uZHVyYXRpb25cclxuICAgICAgKSB7XHJcbiAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIG9uIHRoaXMgZnJhbWUgZm9yIGl0cyB3aG9sZSBkdXJhdGlvbiwgZ28gdG8gdGhlIG5leHQgb25lXHJcbiAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSArPSAxO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RnJhbWUgPj0gY3VycmVudEFuaW1hdGlvbi5mcmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAvLyBXZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGlzIGFuaW1hdGlvblxyXG4gICAgICAgICAgaWYgKHRoaXMubG9vcCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmVuZEN1cnJlbnRBbmltYXRpb24oKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJldHVybiB0aGUgY3VycmVudCBpbmRleFxyXG4gICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBObyBjdXJyZW50IGFuaW1hdGlvbiwgY2FuJ3QgYWR2YW5jZS4gV2FybiB0aGUgdXNlclxyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgYEFuaW1hdGlvbiBpbmRleCBhbmQgYWR2YW5jZSB3YXMgcmVxdWVzdGVkLCBidXQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uICgke3RoaXMuY3VycmVudEFuaW1hdGlvbn0pIGluIG5vZGUgd2l0aCBpZDogJHt0aGlzLm93bmVyLmlkfSB3YXMgaW52YWxpZGAsXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEVuZHMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCBmaXJlcyBhbnkgbmVjZXNzYXJ5IGV2ZW50cywgYXMgd2VsbCBhcyBzdGFydGluZyBhbnkgbmV3IGFuaW1hdGlvbnMgKi9cclxuICBwcm90ZWN0ZWQgZW5kQ3VycmVudEFuaW1hdGlvbigpOiB2b2lkIHtcclxuICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xyXG5cclxuICAgIGlmICh0aGlzLm9uRW5kRXZlbnQgIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uRW5kRXZlbnQsIHtcclxuICAgICAgICBvd25lcjogdGhpcy5vd25lci5pZCxcclxuICAgICAgICBhbmltYXRpb246IHRoaXMuY3VycmVudEFuaW1hdGlvbixcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIGFuaW1hdGlvbiwgcGxheSBpdFxyXG4gICAgaWYgKHRoaXMucGVuZGluZ0FuaW1hdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLnBsYXkodGhpcy5wZW5kaW5nQW5pbWF0aW9uLCB0aGlzLnBlbmRpbmdMb29wLCB0aGlzLnBlbmRpbmdPbkVuZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQbGF5cyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbi4gRG9lcyBub3QgcmVzdGFydCBpdCBpZiBpdCBpcyBhbHJlYWR5IHBsYXlpbmdcclxuICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcGxheVxyXG4gICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRvIGxvb3AgdGhlIGFuaW1hdGlvbi4gRmFsc2UgYnkgZGVmYXVsdFxyXG4gICAqIEBwYXJhbSBvbkVuZCBUaGUgbmFtZSBvZiBhbiBldmVudCB0byBzZW5kIHdoZW4gdGhpcyBhbmltYXRpb24gbmF0dXJhbGx5IHN0b3BzIHBsYXlpbmcuIFRoaXMgb25seSBtYXR0ZXJzIGlmIGxvb3AgaXMgZmFsc2UuXHJcbiAgICovXHJcbiAgcGxheUlmTm90QWxyZWFkeShhbmltYXRpb246IHN0cmluZywgbG9vcD86IGJvb2xlYW4sIG9uRW5kPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uICE9PSBhbmltYXRpb24pIHtcclxuICAgICAgdGhpcy5wbGF5KGFuaW1hdGlvbiwgbG9vcCwgb25FbmQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGxheXMgdGhlIHNwZWNpZmllZCBhbmltYXRpb25cclxuICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcGxheVxyXG4gICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRvIGxvb3AgdGhlIGFuaW1hdGlvbi4gRmFsc2UgYnkgZGVmYXVsdFxyXG4gICAqIEBwYXJhbSBvbkVuZCBUaGUgbmFtZSBvZiBhbiBldmVudCB0byBzZW5kIHdoZW4gdGhpcyBhbmltYXRpb24gbmF0dXJhbGx5IHN0b3BzIHBsYXlpbmcuIFRoaXMgb25seSBtYXR0ZXJzIGlmIGxvb3AgaXMgZmFsc2UuXHJcbiAgICovXHJcbiAgcGxheShhbmltYXRpb246IHN0cmluZywgbG9vcD86IGJvb2xlYW4sIG9uRW5kPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xyXG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XHJcblxyXG4gICAgLy8gSWYgbG9vcCBhcmcgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdFxyXG4gICAgaWYgKGxvb3AgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLmxvb3AgPSBsb29wO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gT3RoZXJ3aXNlLCB1c2Ugd2hhdCB0aGUganNvbiBmaWxlIHNwZWNpZmllZFxyXG4gICAgICB0aGlzLmxvb3AgPSB0aGlzLmFuaW1hdGlvbnMuZ2V0KGFuaW1hdGlvbikucmVwZWF0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvbkVuZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMub25FbmRFdmVudCA9IG9uRW5kO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5vbkVuZEV2ZW50ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBwZW5kaW5nIGFuaW1hdGlvblxyXG4gICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFF1ZXVlcyBhIHNpbmdsZSBhbmltYXRpb24gdG8gYmUgcGxheWVkIGFmdGVyIHRoZSBjdXJyZW50IG9uZS4gRG9lcyBOT1Qgc3RhY2suXHJcbiAgICogUXVldWVpbmcgYWRkaXRpb25hbCBhbmltYXRpb25zIHBhc3QgMSB3aWxsIGp1c3QgcmVwbGFjZSB0aGUgcXVldWVkIGFuaW1hdGlvblxyXG4gICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIGFuaW1hdGlvbiB0byBxdWV1ZVxyXG4gICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRoZSBsb29wIHRoZSBxdWV1ZWQgYW5pbWF0aW9uXHJcbiAgICogQHBhcmFtIG9uRW5kIFRoZSBldmVudCB0byBmaXJlIHdoZW4gdGhlIHF1ZXVlZCBhbmltYXRpb24gZW5kc1xyXG4gICAqL1xyXG4gIHF1ZXVlKGFuaW1hdGlvbjogc3RyaW5nLCBsb29wOiBib29sZWFuID0gZmFsc2UsIG9uRW5kPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICB0aGlzLnBlbmRpbmdMb29wID0gbG9vcDtcclxuICAgIGlmIChvbkVuZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMucGVuZGluZ09uRW5kID0gb25FbmQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBlbmRpbmdPbkVuZCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogUGF1c2VzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiAqL1xyXG4gIHBhdXNlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBBVVNFRDtcclxuICB9XHJcblxyXG4gIC8qKiBSZXN1bWVzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpZiBwb3NzaWJsZSAqL1xyXG4gIHJlc3VtZSgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QQVVTRUQpIHtcclxuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogU3RvcHMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLiBUaGUgYW5pbWF0aW9uIGNhbm5vdCBiZSByZXN1bWVkIGFmdGVyIHRoaXMuICovXHJcbiAgc3RvcCgpOiB2b2lkIHtcclxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBUd2VlbmFibGVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uLy4uL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCB7IEVhc2VGdW5jdGlvblR5cGUgfSBmcm9tIFwiLi4vLi4vVXRpbHMvRWFzZUZ1bmN0aW9uc1wiO1xyXG5cclxuLy8gQGlnbm9yZVBhZ2VcclxuXHJcbmV4cG9ydCBlbnVtIEFuaW1hdGlvblN0YXRlIHtcclxuICBTVE9QUEVEID0gMCxcclxuICBQQVVTRUQgPSAxLFxyXG4gIFBMQVlJTkcgPSAyLFxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uRGF0YSB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGZyYW1lczogQXJyYXk8QW5pbWF0aW9uRnJhbWU+O1xyXG4gIHJlcGVhdDogYm9vbGVhbiA9IGZhbHNlO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uRnJhbWUge1xyXG4gIGluZGV4OiBudW1iZXI7XHJcbiAgZHVyYXRpb246IG51bWJlcjtcclxuICB4OiBudW1iZXI7XHJcbiAgeTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVHdlZW5FZmZlY3Qge1xyXG4gIC8qKiBUaGUgcHJvcGVydHkgdG8gdHdlZW4gKi9cclxuICBwcm9wZXJ0eTogVHdlZW5hYmxlUHJvcGVydGllcztcclxuXHJcbiAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBUd2VlbiBzaG91bGQgcmVzZXQgdGhlIHByb3BlcnR5IHRvIGl0cyBvcmlnaW5hbCB2YWx1ZSBhZnRlciBwbGF5aW5nICovXHJcbiAgcmVzZXRPbkNvbXBsZXRlOiBib29sZWFuO1xyXG5cclxuICAvKiogVGhlIHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgdHdlZW4gKi9cclxuICBzdGFydDogYW55O1xyXG5cclxuICAvKiogVGhlIGVuZGluZyB2YWx1ZSBmb3IgdGhlIHR3ZWVuICovXHJcbiAgZW5kOiBhbnk7XHJcblxyXG4gIC8qKiBUaGUgZWFzZSBmdW5jdGlvbiB0byB1c2UgKi9cclxuICBlYXNlOiBFYXNlRnVuY3Rpb25UeXBlO1xyXG5cclxuICAvKiogRE8gTk9UIE1PRElGWSAtIFRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgLSBzZXQgYXV0b21hdGljYWxseSAqL1xyXG4gIGluaXRpYWxWYWx1ZTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVHdlZW5EYXRhIHtcclxuICAvLyBNZW1iZXJzIGZvciBpbml0aWFsaXphdGlvbiBieSB0aGUgdXNlclxyXG4gIC8qKiBUaGUgYW1vdW50IG9mIHRpbWUgaW4gbXMgdG8gd2FpdCBiZWZvcmUgZXhlY3V0aW5nIHRoZSB0d2VlbiAqL1xyXG4gIHN0YXJ0RGVsYXk6IG51bWJlcjtcclxuICAvKiogVGhlIGR1cmF0aW9uIG9mIHRpbWUgb3ZlciB3aGljaCB0aGUgdmFsdWUgd2l0aCBjaGFuZ2UgZnJvbSBzdGFydCB0byBlbmQgKi9cclxuICBkdXJhdGlvbjogbnVtYmVyO1xyXG4gIC8qKiBBbiBhcnJheSBvZiB0aGUgZWZmZWN0cyBvbiB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0ICovXHJcbiAgZWZmZWN0czogQXJyYXk8VHdlZW5FZmZlY3Q+O1xyXG4gIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHR3ZWVuIHNob3VsZCByZXZlcnNlIGZyb20gZW5kIHRvIHN0YXJ0IGZvciBlYWNoIHByb3BlcnR5IHdoZW4gaXQgZmluaXNoZXMgKi9cclxuICByZXZlcnNlT25Db21wbGV0ZTogYm9vbGVhbjtcclxuICAvKiogV2hldGhlciBvciBub3QgdGhpcyB0d2VlbiBzaG91bGQgbG9vcCB3aGVuIGl0IGNvbXBsZXRlcyAqL1xyXG4gIGxvb3A6IGJvb2xlYW47XHJcbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kIChpZiBhbnkpIHdoZW4gdGhlIHR3ZWVuIGZpbmlzaGVzIHBsYXlpbmcgKi9cclxuICBvbkVuZDogc3RyaW5nO1xyXG5cclxuICAvLyBNZW1iZXJzIGZvciBtYW5hZ2VtZW50IGJ5IHRoZSB0d2VlbiBtYW5hZ2VyXHJcbiAgLyoqIFRoZSBwcm9ncmVzcyBvZiB0aGlzIHR3ZWVuIHRocm91Z2ggaXRzIGVmZmVjdHMgKi9cclxuICBwcm9ncmVzczogbnVtYmVyO1xyXG5cclxuICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRoYXQgaGFzIHBhc3NlZCBmcm9tIHdoZW4gdGhpcyB0d2VlbiBzdGFydGVkIHJ1bm5pbmcgKi9cclxuICBlbGFwc2VkVGltZTogbnVtYmVyO1xyXG5cclxuICAvKiogVGhlIHN0YXRlIG9mIHRoaXMgdHdlZW4gKi9cclxuICBhbmltYXRpb25TdGF0ZTogQW5pbWF0aW9uU3RhdGU7XHJcblxyXG4gIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHR3ZWVuIGlzIGN1cnJlbnRseSByZXZlcnNpbmcgKi9cclxuICByZXZlcnNpbmc6IGJvb2xlYW47XHJcbn1cclxuIiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IFBhcnRpY2xlU3lzdGVtIGZyb20gXCIuL1BhcnRpY2xlU3lzdGVtXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUGFydGljbGVTeXN0ZW1NYW5hZ2VyID0gbnVsbDtcclxuXHJcbiAgcHJvdGVjdGVkIHBhcnRpY2xlU3lzdGVtczogQXJyYXk8UGFydGljbGVTeXN0ZW0+O1xyXG5cclxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5wYXJ0aWNsZVN5c3RlbXMgPSBuZXcgQXJyYXkoKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIge1xyXG4gICAgaWYgKFBhcnRpY2xlU3lzdGVtTWFuYWdlci5pbnN0YW5jZSA9PT0gbnVsbCkge1xyXG4gICAgICBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgUGFydGljbGVTeXN0ZW1NYW5hZ2VyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFBhcnRpY2xlU3lzdGVtTWFuYWdlci5pbnN0YW5jZTtcclxuICB9XHJcblxyXG4gIHJlZ2lzdGVyUGFydGljbGVTeXN0ZW0oc3lzdGVtOiBQYXJ0aWNsZVN5c3RlbSkge1xyXG4gICAgdGhpcy5wYXJ0aWNsZVN5c3RlbXMucHVzaChzeXN0ZW0pO1xyXG4gIH1cclxuXHJcbiAgZGVyZWdpc3RlclBhcnRpY2xlU3lzdGVtKHN5c3RlbTogUGFydGljbGVTeXN0ZW0pIHtcclxuICAgIGxldCBpbmRleCA9IHRoaXMucGFydGljbGVTeXN0ZW1zLmluZGV4T2Yoc3lzdGVtKTtcclxuICAgIHRoaXMucGFydGljbGVTeXN0ZW1zLnNwbGljZShpbmRleCwgMSk7XHJcbiAgfVxyXG5cclxuICBjbGVhclBhcnRpY2xlU3lzdGVtcygpIHtcclxuICAgIHRoaXMucGFydGljbGVTeXN0ZW1zID0gbmV3IEFycmF5KCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGZvciAobGV0IHBhcnRpY2xlU3lzdGVtIG9mIHRoaXMucGFydGljbGVTeXN0ZW1zKSB7XHJcbiAgICAgIHBhcnRpY2xlU3lzdGVtLnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IHsgQW5pbWF0aW9uU3RhdGUsIFR3ZWVuRGF0YSB9IGZyb20gXCIuL0FuaW1hdGlvblR5cGVzXCI7XHJcbmltcG9ydCBFYXNlRnVuY3Rpb25zIGZyb20gXCIuLi8uLi9VdGlscy9FYXNlRnVuY3Rpb25zXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uLy4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5pbXBvcnQgVHdlZW5NYW5hZ2VyIGZyb20gXCIuL1R3ZWVuTWFuYWdlclwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1hbmFnZXIgZm9yIHRoZSB0d2VlbnMgb2YgYSBHYW1lTm9kZS5cclxuICogVHdlZW5zIGFyZSBzaG9ydCBhbmltYXRpb25zIHBsYXllZCBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gdHdvIHByb3BlcnRpZXMgdXNpbmcgYW4gZWFzaW5nIGZ1bmN0aW9uLlxyXG4gKiBGb3IgYSBnb29kIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zLCBjaGVjayBvdXQgQGxpbmsoaHR0cHM6Ly9lYXNpbmdzLm5ldC8pKGh0dHBzOi8vZWFzaW5ncy5uZXQvKS5cclxuICogTXVsdGlwbGUgdHdlZW4gY2FuIGJlIHBsYXllZCBhdCB0aGUgc2FtZSB0aW1lLCBhcyBsb25nIGFzIHRoZXkgZG9uJ3QgY2hhbmdlIHRoZSBzYW1lIHByb3BlcnR5LlxyXG4gKiBUaGlzIGFsbG93cyBmb3Igc29tZSBpbnRlcmVzdGluZyBwb2xpc2hlcyBvciBhbmltYXRpb25zIHRoYXQgbWF5IGJlIHZlcnkgZGlmZmljdWx0IHRvIGRvIHdpdGggc3ByaXRlIHdvcmsgYWxvbmVcclxuICogLSBlc3BlY2lhbGx5IHBpeGVsIGFydCAoc3VjaCBhcyByb3RhdGlvbnMgb3Igc2NhbGluZykuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUd2VlbkNvbnRyb2xsZXIge1xyXG4gIC8qKiBUaGUgR2FtZU5vZGUgdGhpcyBUd2VlbkNvbnRyb2xsZXIgYWN0cyB1cG9uICovXHJcbiAgcHJvdGVjdGVkIG93bmVyOiBHYW1lTm9kZTtcclxuICAvKiogVGhlIGxpc3Qgb2YgY3JlYXRlZCB0d2VlbnMgKi9cclxuICBwcm90ZWN0ZWQgdHdlZW5zOiBNYXA8VHdlZW5EYXRhPjtcclxuICAvKiogQW4gZXZlbnQgZW1pdHRlciAqL1xyXG4gIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IFR3ZWVuQ29udHJvbGxlclxyXG4gICAqIEBwYXJhbSBvd25lciBUaGUgb3duZXIgb2YgdGhlIFR3ZWVuQ29udHJvbGxlclxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG93bmVyOiBHYW1lTm9kZSkge1xyXG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xyXG4gICAgdGhpcy50d2VlbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG5cclxuICAgIC8vIEdpdmUgb3Vyc2VsdmVzIHRvIHRoZSBUd2Vlbk1hbmFnZXJcclxuICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLnJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzdHJveXMgdGhpcyBUd2VlbkNvbnRyb2xsZXJcclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgLy8gT25seSB0aGUgZ2FtZW5vZGUgYW5kIHRoZSB0d2VlbiBtYW5hZ2VyIHNob3VsZCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoaXNcclxuICAgIGRlbGV0ZSB0aGlzLm93bmVyLnR3ZWVucztcclxuICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLmRlcmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSB0d2VlbiB0byB0aGlzIGdhbWUgbm9kZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIG5hbWUgb2YgdGhlIHR3ZWVuXHJcbiAgICogQHBhcmFtIHR3ZWVuIFRoZSBkYXRhIG9mIHRoZSB0d2VlblxyXG4gICAqL1xyXG4gIGFkZChrZXk6IHN0cmluZywgdHdlZW46IFJlY29yZDxzdHJpbmcsIGFueT4gfCBUd2VlbkRhdGEpOiB2b2lkIHtcclxuICAgIGxldCB0eXBlZFR3ZWVuID0gPFR3ZWVuRGF0YT50d2VlbjtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIG1lbWJlcnMgdGhhdCB3ZSBuZWVkIChhbmQgdGhlIHVzZXIgZGlkbid0IHByb3ZpZGUpXHJcbiAgICB0eXBlZFR3ZWVuLnByb2dyZXNzID0gMDtcclxuICAgIHR5cGVkVHdlZW4uZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgdHlwZWRUd2Vlbi5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XHJcblxyXG4gICAgdGhpcy50d2VlbnMuYWRkKGtleSwgdHlwZWRUd2Vlbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQbGF5IGEgdHdlZW4gd2l0aCBhIGNlcnRhaW4gbmFtZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIG5hbWUgb2YgdGhlIHR3ZWVuIHRvIHBsYXlcclxuICAgKiBAcGFyYW0gbG9vcCBXaGV0aGVyIG9yIG5vdCB0aGUgdHdlZW4gc2hvdWxkIGxvb3BcclxuICAgKi9cclxuICBwbGF5KGtleTogc3RyaW5nLCBsb29wPzogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMudHdlZW5zLmhhcyhrZXkpKSB7XHJcbiAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xyXG5cclxuICAgICAgLy8gU2V0IGxvb3AgaWYgbmVlZGVkXHJcbiAgICAgIGlmIChsb29wICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0d2Vlbi5sb29wID0gbG9vcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2V0IHRoZSBpbml0aWFsIHZhbHVlc1xyXG4gICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHdlZW4uZWZmZWN0cykge1xyXG4gICAgICAgIGlmIChlZmZlY3QucmVzZXRPbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICBlZmZlY3QuaW5pdGlhbFZhbHVlID0gdGhpcy5vd25lcltlZmZlY3QucHJvcGVydHldO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU3RhcnQgdGhlIHR3ZWVuIHJ1bm5pbmdcclxuICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xyXG4gICAgICB0d2Vlbi5lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgIHR3ZWVuLnByb2dyZXNzID0gMDtcclxuICAgICAgdHdlZW4ucmV2ZXJzaW5nID0gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgYFRyaWVkIHRvIHBsYXkgdHdlZW4gXCIke2tleX1cIiBvbiBub2RlIHdpdGggaWQgJHt0aGlzLm93bmVyLmlkfSwgYnV0IG5vIHN1Y2ggdHdlZW4gZXhpc3RzYCxcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlcyBhIHBsYXlpbmcgdHdlZW4uIERvZXMgbm90IGFmZmVjdCB0d2VlbnMgdGhhdCBhcmUgc3RvcHBlZC5cclxuICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlbiB0byBwYXVzZS5cclxuICAgKi9cclxuICBwYXVzZShrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMudHdlZW5zLmhhcyhrZXkpKSB7XHJcbiAgICAgIHRoaXMudHdlZW5zLmdldChrZXkpLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuUEFVU0VEO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzdW1lcyBhIHBhdXNlZCB0d2Vlbi5cclxuICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlbiB0byByZXN1bWVcclxuICAgKi9cclxuICByZXN1bWUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnR3ZWVucy5oYXMoa2V5KSkge1xyXG4gICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcclxuICAgICAgaWYgKHR3ZWVuLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QQVVTRUQpXHJcbiAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcHMgYSBjdXJyZW50bHkgcGxheWluZyB0d2VlblxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdHdlZW5cclxuICAgKi9cclxuICBzdG9wKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy50d2VlbnMuaGFzKGtleSkpIHtcclxuICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XHJcbiAgICAgIHR3ZWVuLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcclxuXHJcbiAgICAgIC8vIFJldHVybiB0byB0aGUgaW5pdGlhbCB2YWx1ZXNcclxuICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHR3ZWVuLmVmZmVjdHMpIHtcclxuICAgICAgICBpZiAoZWZmZWN0LnJlc2V0T25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgdGhpcy5vd25lcltlZmZlY3QucHJvcGVydHldID0gZWZmZWN0LmluaXRpYWxWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBuYXR1cmFsIHN0b3Agb2YgYSBjdXJyZW50bHkgcGxheWluZyB0d2VlblxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdHdlZW5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZW5kKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLnN0b3Aoa2V5KTtcclxuICAgIGlmICh0aGlzLnR3ZWVucy5oYXMoa2V5KSkge1xyXG4gICAgICAvLyBHZXQgdGhlIHR3ZWVuXHJcbiAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xyXG5cclxuICAgICAgLy8gSWYgaXQgaGFzIGFuIG9uRW5kLCBzZW5kIGFuIGV2ZW50XHJcbiAgICAgIGlmICh0d2Vlbi5vbkVuZCkge1xyXG4gICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodHdlZW4ub25FbmQsIHsga2V5OiBrZXksIG5vZGU6IHRoaXMub3duZXIuaWQgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3BzIGFsbCBjdXJyZW50bHkgcGxheWluZyB0d2VlbnNcclxuICAgKi9cclxuICBzdG9wQWxsKCk6IHZvaWQge1xyXG4gICAgdGhpcy50d2VlbnMuZm9yRWFjaChrZXkgPT4gdGhpcy5zdG9wKGtleSkpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLnR3ZWVucy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xyXG4gICAgICBpZiAodHdlZW4uYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBMQVlJTkcpIHtcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIG9mIHRoZSB0d2VlblxyXG4gICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lICs9IGRlbHRhVCAqIDEwMDA7XHJcblxyXG4gICAgICAgIC8vIElmIHdlJ3JlIHBhc3QgdGhlIHN0YXJ0RGVsYXksIGRvIHRoZSB0d2VlblxyXG4gICAgICAgIGlmICh0d2Vlbi5lbGFwc2VkVGltZSA+PSB0d2Vlbi5zdGFydERlbGF5KSB7XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICF0d2Vlbi5yZXZlcnNpbmcgJiZcclxuICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSArIHR3ZWVuLmR1cmF0aW9uXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgLy8gSWYgd2UncmUgb3ZlciB0aW1lLCBzdG9wIHRoZSB0d2VlbiwgbG9vcCwgb3IgcmV2ZXJzZVxyXG4gICAgICAgICAgICBpZiAodHdlZW4ucmV2ZXJzZU9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBvdmVyIHRpbWUgYW5kIGNhbiByZXZlcnNlLCBkbyBzb1xyXG4gICAgICAgICAgICAgIHR3ZWVuLnJldmVyc2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHdlZW4ubG9vcCkge1xyXG4gICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IHJldmVyc2UgYW5kIGNhbiBsb29wLCBkbyBzb1xyXG4gICAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lIC09IHR3ZWVuLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBsb29waW5nIGFuZCBjYW4ndCByZXZlcnNlLCBzbyBzdG9wXHJcbiAgICAgICAgICAgICAgdGhpcy5lbmQoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgZW5kIG9mIHJldmVyc2luZ1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0d2Vlbi5yZXZlcnNpbmcgJiZcclxuICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSArIDIgKiB0d2Vlbi5kdXJhdGlvblxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlmICh0d2Vlbi5sb29wKSB7XHJcbiAgICAgICAgICAgICAgdHdlZW4ucmV2ZXJzaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgLT0gMiAqIHR3ZWVuLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRoaXMuZW5kKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb2dyZXNzLCBtYWtlIHN1cmUgaXQgaXMgYmV0d2VlbiAwIGFuZCAxLiBFcnJvcnMgZnJvbSB0aGlzIHNob3VsZCBuZXZlciBiZSBsYXJnZVxyXG4gICAgICAgICAgaWYgKHR3ZWVuLnJldmVyc2luZykge1xyXG4gICAgICAgICAgICB0d2Vlbi5wcm9ncmVzcyA9IE1hdGhVdGlscy5jbGFtcDAxKFxyXG4gICAgICAgICAgICAgICgyICogdHdlZW4uZHVyYXRpb24gLSAodHdlZW4uZWxhcHNlZFRpbWUgLSB0d2Vlbi5zdGFydERlbGF5KSkgL1xyXG4gICAgICAgICAgICAgICAgdHdlZW4uZHVyYXRpb24sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0d2Vlbi5wcm9ncmVzcyA9IE1hdGhVdGlscy5jbGFtcDAxKFxyXG4gICAgICAgICAgICAgICh0d2Vlbi5lbGFwc2VkVGltZSAtIHR3ZWVuLnN0YXJ0RGVsYXkpIC8gdHdlZW4uZHVyYXRpb24sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHR3ZWVuLmVmZmVjdHMpIHtcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBlYXNlIGZ1bmN0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gb3VyIHByb2dyZXNzXHJcbiAgICAgICAgICAgIGxldCBlYXNlID0gRWFzZUZ1bmN0aW9uc1tlZmZlY3QuZWFzZV0odHdlZW4ucHJvZ3Jlc3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXNlIHRoZSB2YWx1ZSB0byBsZXJwIHRoZSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBNYXRoVXRpbHMubGVycChlZmZlY3Quc3RhcnQsIGVmZmVjdC5lbmQsIGVhc2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gQXNzaWduIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcclxuICAgICAgICAgICAgdGhpcy5vd25lcltlZmZlY3QucHJvcGVydHldID0gdmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IFR3ZWVuQ29udHJvbGxlciBmcm9tIFwiLi9Ud2VlbkNvbnRyb2xsZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR3ZWVuTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBUd2Vlbk1hbmFnZXIgPSBudWxsO1xyXG5cclxuICBwcm90ZWN0ZWQgdHdlZW5Db250cm9sbGVyczogQXJyYXk8VHdlZW5Db250cm9sbGVyPjtcclxuXHJcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMudHdlZW5Db250cm9sbGVycyA9IG5ldyBBcnJheSgpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IFR3ZWVuTWFuYWdlciB7XHJcbiAgICBpZiAoVHdlZW5NYW5hZ2VyLmluc3RhbmNlID09PSBudWxsKSB7XHJcbiAgICAgIFR3ZWVuTWFuYWdlci5pbnN0YW5jZSA9IG5ldyBUd2Vlbk1hbmFnZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gVHdlZW5NYW5hZ2VyLmluc3RhbmNlO1xyXG4gIH1cclxuXHJcbiAgcmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIoY29udHJvbGxlcjogVHdlZW5Db250cm9sbGVyKSB7XHJcbiAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcclxuICB9XHJcblxyXG4gIGRlcmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIoY29udHJvbGxlcjogVHdlZW5Db250cm9sbGVyKSB7XHJcbiAgICBsZXQgaW5kZXggPSB0aGlzLnR3ZWVuQ29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKTtcclxuICAgIHRoaXMudHdlZW5Db250cm9sbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gIH1cclxuXHJcbiAgY2xlYXJUd2VlbkNvbnRyb2xsZXJzKCkge1xyXG4gICAgdGhpcy50d2VlbkNvbnRyb2xsZXJzID0gbmV3IEFycmF5KCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGZvciAobGV0IHR3ZWVuQ29udHJvbGxlciBvZiB0aGlzLnR3ZWVuQ29udHJvbGxlcnMpIHtcclxuICAgICAgdHdlZW5Db250cm9sbGVyLnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljXCI7XHJcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcclxuaW1wb3J0IFJlY3QgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcclxuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcclxuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcclxuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xyXG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcclxuaW1wb3J0IFVJTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9VSUxheWVyXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IEdyYXBoaWNSZW5kZXJlciBmcm9tIFwiLi9DYW52YXNSZW5kZXJpbmcvR3JhcGhpY1JlbmRlcmVyXCI7XHJcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuL1JlbmRlcmluZ01hbmFnZXJcIjtcclxuaW1wb3J0IFRpbGVtYXBSZW5kZXJlciBmcm9tIFwiLi9DYW52YXNSZW5kZXJpbmcvVGlsZW1hcFJlbmRlcmVyXCI7XHJcbmltcG9ydCBVSUVsZW1lbnRSZW5kZXJlciBmcm9tIFwiLi9DYW52YXNSZW5kZXJpbmcvVUlFbGVtZW50UmVuZGVyZXJcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XHJcbmltcG9ydCBTbGlkZXIgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyXCI7XHJcbmltcG9ydCBUZXh0SW5wdXQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0XCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcblxyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIFJlbmRlcmluZ01hbmFnZXIgY2xhc3MgdXNpbmcgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJpbmdNYW5hZ2VyIHtcclxuICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcbiAgcHJvdGVjdGVkIGdyYXBoaWNSZW5kZXJlcjogR3JhcGhpY1JlbmRlcmVyO1xyXG4gIHByb3RlY3RlZCB0aWxlbWFwUmVuZGVyZXI6IFRpbGVtYXBSZW5kZXJlcjtcclxuICBwcm90ZWN0ZWQgdWlFbGVtZW50UmVuZGVyZXI6IFVJRWxlbWVudFJlbmRlcmVyO1xyXG5cclxuICBwcm90ZWN0ZWQgb3JpZ2luOiBWZWMyO1xyXG4gIHByb3RlY3RlZCB6b29tOiBudW1iZXI7XHJcblxyXG4gIHByb3RlY3RlZCB3b3JsZFNpemU6IFZlYzI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICB9XHJcblxyXG4gIC8vIEBvdmVycmlkZVxyXG4gIHNldFNjZW5lKHNjZW5lOiBTY2VuZSkge1xyXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgdGhpcy5ncmFwaGljUmVuZGVyZXIuc2V0U2NlbmUoc2NlbmUpO1xyXG4gICAgdGhpcy50aWxlbWFwUmVuZGVyZXIuc2V0U2NlbmUoc2NlbmUpO1xyXG4gICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5zZXRTY2VuZShzY2VuZSk7XHJcbiAgfVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICBpbml0aWFsaXplQ2FudmFzKFxyXG4gICAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcclxuICAgIHdpZHRoOiBudW1iZXIsXHJcbiAgICBoZWlnaHQ6IG51bWJlcixcclxuICApOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQge1xyXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMud29ybGRTaXplID0gbmV3IFZlYzIod2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgdGhpcy5jdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyID0gbmV3IEdyYXBoaWNSZW5kZXJlcih0aGlzLmN0eCk7XHJcbiAgICB0aGlzLnRpbGVtYXBSZW5kZXJlciA9IG5ldyBUaWxlbWFwUmVuZGVyZXIodGhpcy5jdHgpO1xyXG4gICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlciA9IG5ldyBVSUVsZW1lbnRSZW5kZXJlcih0aGlzLmN0eCk7XHJcblxyXG4gICAgLy8gRm9yIGNyaXNwIHBpeGVsIGFydFxyXG4gICAgdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuY3R4O1xyXG4gIH1cclxuXHJcbiAgLy8gQG92ZXJyaWRlXHJcbiAgcmVuZGVyKFxyXG4gICAgdmlzaWJsZVNldDogQ2FudmFzTm9kZVtdLFxyXG4gICAgdGlsZW1hcHM6IFRpbGVtYXBbXSxcclxuICAgIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj4sXHJcbiAgKTogdm9pZCB7XHJcbiAgICAvLyBTb3J0IGJ5IGRlcHRoLCB0aGVuIGJ5IHZpc2libGUgc2V0IGJ5IHktdmFsdWVcclxuICAgIHZpc2libGVTZXQuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICBpZiAoYS5nZXRMYXllcigpLmdldERlcHRoKCkgPT09IGIuZ2V0TGF5ZXIoKS5nZXREZXB0aCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGEuYm91bmRhcnkuYm90dG9tIC0gYi5ib3VuZGFyeS5ib3R0b207XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGEuZ2V0TGF5ZXIoKS5nZXREZXB0aCgpIC0gYi5nZXRMYXllcigpLmdldERlcHRoKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGxldCB0aWxlbWFwSW5kZXggPSAwO1xyXG4gICAgbGV0IHRpbGVtYXBMZW5ndGggPSB0aWxlbWFwcy5sZW5ndGg7XHJcblxyXG4gICAgbGV0IHZpc2libGVTZXRJbmRleCA9IDA7XHJcbiAgICBsZXQgdmlzaWJsZVNldExlbmd0aCA9IHZpc2libGVTZXQubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlICh0aWxlbWFwSW5kZXggPCB0aWxlbWFwTGVuZ3RoIHx8IHZpc2libGVTZXRJbmRleCA8IHZpc2libGVTZXRMZW5ndGgpIHtcclxuICAgICAgLy8gQ2hlY2sgY29uZGl0aW9ucyB3aGVyZSB3ZSd2ZSBhbHJlYWR5IHJlYWNoZWQgdGhlIGVkZ2Ugb2Ygb25lIGxpc3RcclxuICAgICAgaWYgKHRpbGVtYXBJbmRleCA+PSB0aWxlbWFwTGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gT25seSByZW5kZXIgdGhlIHJlbWFpbmluZyB2aXNpYmxlIHNldFxyXG4gICAgICAgIGxldCBub2RlID0gdmlzaWJsZVNldFt2aXNpYmxlU2V0SW5kZXgrK107XHJcbiAgICAgICAgaWYgKG5vZGUudmlzaWJsZSkge1xyXG4gICAgICAgICAgdGhpcy5yZW5kZXJOb2RlKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHZpc2libGVTZXRJbmRleCA+PSB2aXNpYmxlU2V0TGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gT25seSByZW5kZXIgdGlsZW1hcHNcclxuICAgICAgICB0aGlzLnJlbmRlclRpbGVtYXAodGlsZW1hcHNbdGlsZW1hcEluZGV4KytdKTtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVuZGVyIHdoaWNoZXZlciBpcyBmdXJ0aGVyIGRvd25cclxuICAgICAgaWYgKFxyXG4gICAgICAgIHRpbGVtYXBzW3RpbGVtYXBJbmRleF0uZ2V0TGF5ZXIoKS5nZXREZXB0aCgpIDw9XHJcbiAgICAgICAgdmlzaWJsZVNldFt2aXNpYmxlU2V0SW5kZXhdLmdldExheWVyKCkuZ2V0RGVwdGgoKVxyXG4gICAgICApIHtcclxuICAgICAgICB0aGlzLnJlbmRlclRpbGVtYXAodGlsZW1hcHNbdGlsZW1hcEluZGV4KytdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHZpc2libGVTZXRbdmlzaWJsZVNldEluZGV4KytdO1xyXG4gICAgICAgIGlmIChub2RlLnZpc2libGUpIHtcclxuICAgICAgICAgIHRoaXMucmVuZGVyTm9kZShub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW5kZXIgdGhlIHVpTGF5ZXJzIG9uIHRvcCBvZiBldmVyeXRoaW5nIGVsc2VcclxuICAgIGxldCBzb3J0ZWRVSUxheWVycyA9IG5ldyBBcnJheTxVSUxheWVyPigpO1xyXG5cclxuICAgIHVpTGF5ZXJzLmZvckVhY2goa2V5ID0+IHNvcnRlZFVJTGF5ZXJzLnB1c2godWlMYXllcnMuZ2V0KGtleSkpKTtcclxuXHJcbiAgICBzb3J0ZWRVSUxheWVycyA9IHNvcnRlZFVJTGF5ZXJzLnNvcnQoXHJcbiAgICAgICh1aTEsIHVpMikgPT4gdWkxLmdldERlcHRoKCkgLSB1aTIuZ2V0RGVwdGgoKSxcclxuICAgICk7XHJcblxyXG4gICAgc29ydGVkVUlMYXllcnMuZm9yRWFjaCh1aUxheWVyID0+IHtcclxuICAgICAgaWYgKCF1aUxheWVyLmlzSGlkZGVuKCkpXHJcbiAgICAgICAgdWlMYXllci5nZXRJdGVtcygpLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICBpZiAoKDxDYW52YXNOb2RlPm5vZGUpLnZpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlKDxDYW52YXNOb2RlPm5vZGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW5kZXJzIGEgc3BlY2lmaWVkIENhbnZhc05vZGVcclxuICAgKiBAcGFyYW0gbm9kZSBUaGUgQ2FudmFzTm9kZSB0byByZW5kZXJcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgcmVuZGVyTm9kZShub2RlOiBDYW52YXNOb2RlKTogdm9pZCB7XHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnQgYWNjb3JkaW5nIHRvIHRoaXMgc3ByaXRlXHJcbiAgICB0aGlzLm9yaWdpbiA9IHRoaXMuc2NlbmUuZ2V0Vmlld1RyYW5zbGF0aW9uKG5vZGUpO1xyXG5cclxuICAgIC8vIEdldCB0aGUgem9vbSBsZXZlbCBvZiB0aGUgc2NlbmVcclxuICAgIHRoaXMuem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XHJcblxyXG4gICAgLy8gTW92ZSB0aGUgY2FudmFzIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBhbmQgcm90YXRlXHJcbiAgICBsZXQgeFNjYWxlID0gMTtcclxuICAgIGxldCB5U2NhbGUgPSAxO1xyXG5cclxuICAgIGlmIChub2RlIGluc3RhbmNlb2YgU3ByaXRlKSB7XHJcbiAgICAgIHhTY2FsZSA9IG5vZGUuaW52ZXJ0WCA/IC0xIDogMTtcclxuICAgICAgeVNjYWxlID0gbm9kZS5pbnZlcnRZID8gLTEgOiAxO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShcclxuICAgICAgeFNjYWxlLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICB5U2NhbGUsXHJcbiAgICAgIChub2RlLnBvc2l0aW9uLnggLSB0aGlzLm9yaWdpbi54KSAqIHRoaXMuem9vbSxcclxuICAgICAgKG5vZGUucG9zaXRpb24ueSAtIHRoaXMub3JpZ2luLnkpICogdGhpcy56b29tLFxyXG4gICAgKTtcclxuICAgIHRoaXMuY3R4LnJvdGF0ZSgtbm9kZS5yb3RhdGlvbik7XHJcbiAgICBsZXQgZ2xvYmFsQWxwaGEgPSB0aGlzLmN0eC5nbG9iYWxBbHBoYTtcclxuICAgIGlmIChub2RlIGluc3RhbmNlb2YgUmVjdCkge1xyXG4gICAgICBEZWJ1Zy5sb2coXCJub2RlXCIgKyBub2RlLmlkLCBcIk5vZGVcIiArIG5vZGUuaWQgKyBcIiBBbHBoYTogXCIgKyBub2RlLmFscGhhKTtcclxuICAgIH1cclxuICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbm9kZS5hbHBoYTtcclxuXHJcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFuaW1hdGVkU3ByaXRlKSB7XHJcbiAgICAgIHRoaXMucmVuZGVyQW5pbWF0ZWRTcHJpdGUoPEFuaW1hdGVkU3ByaXRlPm5vZGUpO1xyXG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgU3ByaXRlKSB7XHJcbiAgICAgIHRoaXMucmVuZGVyU3ByaXRlKDxTcHJpdGU+bm9kZSk7XHJcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBHcmFwaGljKSB7XHJcbiAgICAgIHRoaXMucmVuZGVyR3JhcGhpYyg8R3JhcGhpYz5ub2RlKTtcclxuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFVJRWxlbWVudCkge1xyXG4gICAgICB0aGlzLnJlbmRlclVJRWxlbWVudCg8VUlFbGVtZW50Pm5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGE7XHJcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcbiAgfVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICBwcm90ZWN0ZWQgcmVuZGVyU3ByaXRlKHNwcml0ZTogU3ByaXRlKTogdm9pZCB7XHJcbiAgICAvLyBHZXQgdGhlIGltYWdlIGZyb20gdGhlIHJlc291cmNlIG1hbmFnZXJcclxuICAgIGxldCBpbWFnZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEltYWdlKHNwcml0ZS5pbWFnZUlkKTtcclxuXHJcbiAgICAvKlxyXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIGltYWdlOlxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzdGFydCAtPiB4LCB5XHJcbiAgICAgICAgICAgICAgICBpbWFnZSBjcm9wIHNpemUgIC0+IHcsIGhcclxuICAgICAgICAgICAgQ29vcmRpbmF0ZXMgaW4gdGhlIHNwYWNlIG9mIHRoZSB3b3JsZFxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgZHJhdyBzdGFydCAtPiB4LCB5XHJcbiAgICAgICAgICAgICAgICBpbWFnZSBkcmF3IHNpemUgIC0+IHcsIGhcclxuICAgICAgICAqL1xyXG4gICAgdGhpcy5jdHguZHJhd0ltYWdlKFxyXG4gICAgICBpbWFnZSxcclxuICAgICAgc3ByaXRlLmltYWdlT2Zmc2V0LngsXHJcbiAgICAgIHNwcml0ZS5pbWFnZU9mZnNldC55LFxyXG4gICAgICBzcHJpdGUuc2l6ZS54LFxyXG4gICAgICBzcHJpdGUuc2l6ZS55LFxyXG4gICAgICAoKC1zcHJpdGUuc2l6ZS54ICogc3ByaXRlLnNjYWxlLngpIC8gMikgKiB0aGlzLnpvb20sXHJcbiAgICAgICgoLXNwcml0ZS5zaXplLnkgKiBzcHJpdGUuc2NhbGUueSkgLyAyKSAqIHRoaXMuem9vbSxcclxuICAgICAgc3ByaXRlLnNpemUueCAqIHNwcml0ZS5zY2FsZS54ICogdGhpcy56b29tLFxyXG4gICAgICBzcHJpdGUuc2l6ZS55ICogc3ByaXRlLnNjYWxlLnkgKiB0aGlzLnpvb20sXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gQG92ZXJyaWRlXHJcbiAgcHJvdGVjdGVkIHJlbmRlckFuaW1hdGVkU3ByaXRlKHNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkIHtcclxuICAgIC8vIEdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgcmVzb3VyY2UgbWFuYWdlclxyXG4gICAgbGV0IGltYWdlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0SW1hZ2Uoc3ByaXRlLmltYWdlSWQpO1xyXG5cclxuICAgIGxldCBhbmltYXRpb25JbmRleCA9IHNwcml0ZS5hbmltYXRpb24uZ2V0SW5kZXhBbmRBZHZhbmNlQW5pbWF0aW9uKCk7XHJcblxyXG4gICAgbGV0IGFuaW1hdGlvbk9mZnNldCA9IHNwcml0ZS5nZXRBbmltYXRpb25PZmZzZXQoYW5pbWF0aW9uSW5kZXgpO1xyXG5cclxuICAgIC8qXHJcbiAgICAgICAgICAgIENvb3JkaW5hdGVzIGluIHRoZSBzcGFjZSBvZiB0aGUgaW1hZ2U6XHJcbiAgICAgICAgICAgICAgICBpbWFnZSBjcm9wIHN0YXJ0IC0+IHgsIHlcclxuICAgICAgICAgICAgICAgIGltYWdlIGNyb3Agc2l6ZSAgLT4gdywgaFxyXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIHdvcmxkIChnaXZlbiB3ZSBtb3ZlZClcclxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc3RhcnQgLT4gLXcvMiwgLWgvMlxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgZHJhdyBzaXplICAtPiB3LCBoXHJcbiAgICAgICAgKi9cclxuICAgIHRoaXMuY3R4LmRyYXdJbWFnZShcclxuICAgICAgaW1hZ2UsXHJcbiAgICAgIHNwcml0ZS5pbWFnZU9mZnNldC54ICsgYW5pbWF0aW9uT2Zmc2V0LngsXHJcbiAgICAgIHNwcml0ZS5pbWFnZU9mZnNldC55ICsgYW5pbWF0aW9uT2Zmc2V0LnksXHJcbiAgICAgIHNwcml0ZS5zaXplLngsXHJcbiAgICAgIHNwcml0ZS5zaXplLnksXHJcbiAgICAgICgoLXNwcml0ZS5zaXplLnggKiBzcHJpdGUuc2NhbGUueCkgLyAyKSAqIHRoaXMuem9vbSxcclxuICAgICAgKCgtc3ByaXRlLnNpemUueSAqIHNwcml0ZS5zY2FsZS55KSAvIDIpICogdGhpcy56b29tLFxyXG4gICAgICBzcHJpdGUuc2l6ZS54ICogc3ByaXRlLnNjYWxlLnggKiB0aGlzLnpvb20sXHJcbiAgICAgIHNwcml0ZS5zaXplLnkgKiBzcHJpdGUuc2NhbGUueSAqIHRoaXMuem9vbSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICBwcm90ZWN0ZWQgcmVuZGVyR3JhcGhpYyhncmFwaGljOiBHcmFwaGljKTogdm9pZCB7XHJcbiAgICBpZiAoZ3JhcGhpYyBpbnN0YW5jZW9mIFBvaW50KSB7XHJcbiAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyLnJlbmRlclBvaW50KDxQb2ludD5ncmFwaGljLCB0aGlzLnpvb20pO1xyXG4gICAgfSBlbHNlIGlmIChncmFwaGljIGluc3RhbmNlb2YgTGluZSkge1xyXG4gICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5yZW5kZXJMaW5lKDxMaW5lPmdyYXBoaWMsIHRoaXMub3JpZ2luLCB0aGlzLnpvb20pO1xyXG4gICAgfSBlbHNlIGlmIChncmFwaGljIGluc3RhbmNlb2YgUmVjdCkge1xyXG4gICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5yZW5kZXJSZWN0KDxSZWN0PmdyYXBoaWMsIHRoaXMuem9vbSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICBwcm90ZWN0ZWQgcmVuZGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XHJcbiAgICBpZiAodGlsZW1hcCBpbnN0YW5jZW9mIE9ydGhvZ29uYWxUaWxlbWFwKSB7XHJcbiAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyLnJlbmRlck9ydGhvZ29uYWxUaWxlbWFwKDxPcnRob2dvbmFsVGlsZW1hcD50aWxlbWFwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEBvdmVycmlkZVxyXG4gIHByb3RlY3RlZCByZW5kZXJVSUVsZW1lbnQodWlFbGVtZW50OiBVSUVsZW1lbnQpOiB2b2lkIHtcclxuICAgIGlmICh1aUVsZW1lbnQgaW5zdGFuY2VvZiBMYWJlbCkge1xyXG4gICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnJlbmRlckxhYmVsKHVpRWxlbWVudCk7XHJcbiAgICB9IGVsc2UgaWYgKHVpRWxlbWVudCBpbnN0YW5jZW9mIEJ1dHRvbikge1xyXG4gICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnJlbmRlckJ1dHRvbih1aUVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIGlmICh1aUVsZW1lbnQgaW5zdGFuY2VvZiBTbGlkZXIpIHtcclxuICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJTbGlkZXIodWlFbGVtZW50KTtcclxuICAgIH0gZWxzZSBpZiAodWlFbGVtZW50IGluc3RhbmNlb2YgVGV4dElucHV0KSB7XHJcbiAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyVGV4dElucHV0KHVpRWxlbWVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjbGVhcihjbGVhckNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG4gICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud29ybGRTaXplLngsIHRoaXMud29ybGRTaXplLnkpO1xyXG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY2xlYXJDb2xvci50b1N0cmluZygpO1xyXG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53b3JsZFNpemUueCwgdGhpcy53b3JsZFNpemUueSk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9TY2VuZS9TY2VuZVwiO1xyXG5cclxuLyoqXHJcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBoZWxwIHRoZSBAcmVmZXJlbmNlW0NhbnZhc1JlbmRlcmVyXSByZW5kZXIgQHJlZmVyZW5jZVtHcmFwaGljXXNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoaWNSZW5kZXJlciB7XHJcbiAgLyoqIFRoZSByZXNvdXJjZSBtYW5hZ2VyIG9mIHRoZSBnYW1lIGVuZ2luZSAqL1xyXG4gIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuICAvKiogVGhlIGN1cnJlbnQgc2NlbmUgKi9cclxuICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xyXG4gIC8qKiBUaGUgcmVuZGVyaW5nIGNvbnRleHQgKi9cclxuICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgdGhpcy5jdHggPSBjdHg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBzY2VuZSBvZiB0aGlzIEdyYXBoaWNSZW5kZXJlclxyXG4gICAqIEBwYXJhbSBzY2VuZSBUaGUgY3VycmVudCBzY2VuZVxyXG4gICAqL1xyXG4gIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xyXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVycyBhIHBvaW50XHJcbiAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byByZW5kZXJcclxuICAgKiBAcGFyYW0gem9vbSBUaGUgem9vbSBsZXZlbFxyXG4gICAqL1xyXG4gIHJlbmRlclBvaW50KHBvaW50OiBQb2ludCwgem9vbTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBwb2ludC5jb2xvci50b1N0cmluZ1JHQkEoKTtcclxuICAgIHRoaXMuY3R4LmZpbGxSZWN0KFxyXG4gICAgICAoLXBvaW50LnNpemUueCAvIDIpICogem9vbSxcclxuICAgICAgKC1wb2ludC5zaXplLnkgLyAyKSAqIHpvb20sXHJcbiAgICAgIHBvaW50LnNpemUueCAqIHpvb20sXHJcbiAgICAgIHBvaW50LnNpemUueSAqIHpvb20sXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyTGluZShsaW5lOiBMaW5lLCBvcmlnaW46IFZlYzIsIHpvb206IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBsaW5lLmNvbG9yLnRvU3RyaW5nUkdCQSgpO1xyXG4gICAgdGhpcy5jdHgubGluZVdpZHRoID0gbGluZS50aGlja25lc3M7XHJcbiAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcclxuICAgIHRoaXMuY3R4Lm1vdmVUbygwLCAwKTtcclxuICAgIHRoaXMuY3R4LmxpbmVUbyhcclxuICAgICAgKGxpbmUuZW5kLnggLSBsaW5lLnN0YXJ0LngpICogem9vbSxcclxuICAgICAgKGxpbmUuZW5kLnkgLSBsaW5lLnN0YXJ0LnkpICogem9vbSxcclxuICAgICk7XHJcbiAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcclxuICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVycyBhIHJlY3RcclxuICAgKiBAcGFyYW0gcmVjdCBUaGUgcmVjdCB0byByZW5kZXJcclxuICAgKiBAcGFyYW0gem9vbSBUaGUgem9vbSBsZXZlbFxyXG4gICAqL1xyXG4gIHJlbmRlclJlY3QocmVjdDogUmVjdCwgem9vbTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAvLyBEcmF3IHRoZSBpbnRlcmlvciBvZiB0aGUgcmVjdFxyXG4gICAgaWYgKHJlY3QuY29sb3IuYSAhPT0gMCkge1xyXG4gICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSByZWN0LmNvbG9yLnRvU3RyaW5nUkdCKCk7XHJcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KFxyXG4gICAgICAgICgtcmVjdC5zaXplLnggLyAyKSAqIHpvb20sXHJcbiAgICAgICAgKC1yZWN0LnNpemUueSAvIDIpICogem9vbSxcclxuICAgICAgICByZWN0LnNpemUueCAqIHpvb20sXHJcbiAgICAgICAgcmVjdC5zaXplLnkgKiB6b29tLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERyYXcgdGhlIGJvcmRlciBvZiB0aGUgcmVjdCBpZiBpdCBpc24ndCB0cmFuc3BhcmVudFxyXG4gICAgaWYgKHJlY3QuYm9yZGVyQ29sb3IuYSAhPT0gMCkge1xyXG4gICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHJlY3QuZ2V0Qm9yZGVyQ29sb3IoKS50b1N0cmluZ1JHQigpO1xyXG4gICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSByZWN0LmdldEJvcmRlcldpZHRoKCk7XHJcbiAgICAgIHRoaXMuY3R4LnN0cm9rZVJlY3QoXHJcbiAgICAgICAgKC1yZWN0LnNpemUueCAvIDIpICogem9vbSxcclxuICAgICAgICAoLXJlY3Quc2l6ZS55IC8gMikgKiB6b29tLFxyXG4gICAgICAgIHJlY3Quc2l6ZS54ICogem9vbSxcclxuICAgICAgICByZWN0LnNpemUueSAqIHpvb20sXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgVGlsZXNldCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVzZXRcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHV0aWxpdHkgY2xhc3MgZm9yIHRoZSBAcmVmZXJlbmNlW0NhbnZhc1JlbmRlcmVyXSB0byByZW5kZXIgQHJlZmVyZW5jZVtUaWxlbWFwXXNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVtYXBSZW5kZXJlciB7XHJcbiAgcHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG4gIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcbiAgcHJvdGVjdGVkIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG5cclxuICBjb25zdHJ1Y3RvcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIHRoaXMuY3R4ID0gY3R4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgc2NlbmUgb2YgdGhpcyBUaWxlbWFwUmVuZGVyZXJcclxuICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgc2NlbmVcclxuICAgKi9cclxuICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcclxuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlcnMgYW4gb3J0aG9nb25hbCB0aWxlbWFwXHJcbiAgICogQHBhcmFtIHRpbGVtYXAgVGhlIHRpbGVtYXAgdG8gcmVuZGVyXHJcbiAgICovXHJcbiAgcmVuZGVyT3J0aG9nb25hbFRpbGVtYXAodGlsZW1hcDogT3J0aG9nb25hbFRpbGVtYXApOiB2b2lkIHtcclxuICAgIGxldCBwcmV2aW91c0FscGhhID0gdGhpcy5jdHguZ2xvYmFsQWxwaGE7XHJcbiAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHRpbGVtYXAuZ2V0TGF5ZXIoKS5nZXRBbHBoYSgpO1xyXG5cclxuICAgIGxldCBvcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbih0aWxlbWFwKTtcclxuICAgIGxldCBzaXplID0gdGhpcy5zY2VuZS5nZXRWaWV3cG9ydCgpLmdldEhhbGZTaXplKCk7XHJcbiAgICBsZXQgem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XHJcbiAgICBsZXQgYm90dG9tUmlnaHQgPSBvcmlnaW4uY2xvbmUoKS5hZGQoc2l6ZS5zY2FsZWQoMiAqIHpvb20pKTtcclxuXHJcbiAgICBpZiAodGlsZW1hcC52aXNpYmxlKSB7XHJcbiAgICAgIGxldCBtaW5Db2xSb3cgPSB0aWxlbWFwLmdldENvbFJvd0F0KG9yaWdpbik7XHJcbiAgICAgIGxldCBtYXhDb2xSb3cgPSB0aWxlbWFwLmdldENvbFJvd0F0KGJvdHRvbVJpZ2h0KTtcclxuXHJcbiAgICAgIGZvciAobGV0IHggPSBtaW5Db2xSb3cueDsgeCA8PSBtYXhDb2xSb3cueDsgeCsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeSA9IG1pbkNvbFJvdy55OyB5IDw9IG1heENvbFJvdy55OyB5KyspIHtcclxuICAgICAgICAgIC8vIEdldCB0aGUgdGlsZSBhdCB0aGlzIHBvc2l0aW9uXHJcbiAgICAgICAgICBsZXQgdGlsZSA9IHRpbGVtYXAuZ2V0VGlsZUF0Um93Q29sKG5ldyBWZWMyKHgsIHkpKTtcclxuXHJcbiAgICAgICAgICAvLyBFeHRyYWN0IHRoZSByb3QvZmxpcCBwYXJhbWV0ZXJzIGlmIHRoZXJlIGFyZSBhbnlcclxuICAgICAgICAgIGNvbnN0IG1hc2sgPSAweGUgPDwgMjg7XHJcbiAgICAgICAgICBjb25zdCByb3RGbGlwID0gKChtYXNrICYgdGlsZSkgPj4gMjgpICYgMHhmO1xyXG4gICAgICAgICAgdGlsZSA9IHRpbGUgJiB+bWFzaztcclxuXHJcbiAgICAgICAgICAvLyBGaW5kIHRoZSB0aWxlc2V0IHRoYXQgb3ducyB0aGlzIHRpbGUgaW5kZXggYW5kIHJlbmRlclxyXG4gICAgICAgICAgZm9yIChsZXQgdGlsZXNldCBvZiB0aWxlbWFwLmdldFRpbGVzZXRzKCkpIHtcclxuICAgICAgICAgICAgaWYgKHRpbGVzZXQuaGFzVGlsZSh0aWxlKSkge1xyXG4gICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZShcclxuICAgICAgICAgICAgICAgIHRpbGVzZXQsXHJcbiAgICAgICAgICAgICAgICB0aWxlLFxyXG4gICAgICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgICAgICBvcmlnaW4sXHJcbiAgICAgICAgICAgICAgICB0aWxlbWFwLnNjYWxlLFxyXG4gICAgICAgICAgICAgICAgem9vbSxcclxuICAgICAgICAgICAgICAgIHJvdEZsaXAsXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlcnMgYSB0aWxlXHJcbiAgICogQHBhcmFtIHRpbGVzZXQgVGhlIHRpbGVzZXQgdGhpcyB0aWxlIGJlbG9uZ3MgdG9cclxuICAgKiBAcGFyYW0gdGlsZUluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZVxyXG4gICAqIEBwYXJhbSB0aWxlbWFwUm93IFRoZSByb3cgb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVtYXBcclxuICAgKiBAcGFyYW0gdGlsZW1hcENvbCBUaGUgY29sdW1uIG9mIHRoZSB0aWxlIGluIHRoZSB0aWxlbWFwXHJcbiAgICogQHBhcmFtIG9yaWdpbiBUaGUgb3JpZ2luIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAqIEBwYXJhbSBzY2FsZSBUaGUgc2NhbGUgb2YgdGhlIHRpbGVtYXBcclxuICAgKiBAcGFyYW0gem9vbSBUaGUgem9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgcmVuZGVyVGlsZShcclxuICAgIHRpbGVzZXQ6IFRpbGVzZXQsXHJcbiAgICB0aWxlSW5kZXg6IG51bWJlcixcclxuICAgIHRpbGVtYXBSb3c6IG51bWJlcixcclxuICAgIHRpbGVtYXBDb2w6IG51bWJlcixcclxuICAgIG9yaWdpbjogVmVjMixcclxuICAgIHNjYWxlOiBWZWMyLFxyXG4gICAgem9vbTogbnVtYmVyLFxyXG4gICAgcm90RmxpcDogbnVtYmVyLFxyXG4gICk6IHZvaWQge1xyXG4gICAgbGV0IGltYWdlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0SW1hZ2UodGlsZXNldC5nZXRJbWFnZUtleSgpKTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIHRydWUgaW5kZXhcclxuICAgIGxldCBpbmRleCA9IHRpbGVJbmRleCAtIHRpbGVzZXQuZ2V0U3RhcnRJbmRleCgpO1xyXG5cclxuICAgIC8vIEdldCB0aGUgcm93IGFuZCBjb2wgb2YgdGhlIHRpbGUgaW4gaW1hZ2Ugc3BhY2VcclxuICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGlsZXNldC5nZXROdW1Db2xzKCkpO1xyXG4gICAgbGV0IGNvbCA9IGluZGV4ICUgdGlsZXNldC5nZXROdW1Db2xzKCk7XHJcbiAgICBsZXQgd2lkdGggPSB0aWxlc2V0LmdldFRpbGVTaXplKCkueDtcclxuICAgIGxldCBoZWlnaHQgPSB0aWxlc2V0LmdldFRpbGVTaXplKCkueTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIHRvIHN0YXJ0IGEgY3JvcCBpbiB0aGUgdGlsZXNldCBpbWFnZVxyXG4gICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcclxuICAgIGxldCB0b3AgPSByb3cgKiBoZWlnaHQ7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBpbiB0aGUgd29ybGQgdG8gcmVuZGVyIHRoZSB0aWxlXHJcbiAgICBsZXQgeCA9IE1hdGguZmxvb3IodGlsZW1hcFJvdyAqIHdpZHRoICogc2NhbGUueCk7XHJcbiAgICBsZXQgeSA9IE1hdGguZmxvb3IodGlsZW1hcENvbCAqIGhlaWdodCAqIHNjYWxlLnkpO1xyXG5cclxuICAgIGxldCB3b3JsZFggPSBNYXRoLmZsb29yKCh4IC0gb3JpZ2luLngpICogem9vbSk7XHJcbiAgICBsZXQgd29ybGRZID0gTWF0aC5mbG9vcigoeSAtIG9yaWdpbi55KSAqIHpvb20pO1xyXG4gICAgbGV0IHdvcmxkV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBzY2FsZS54ICogem9vbSk7XHJcbiAgICBsZXQgd29ybGRIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogc2NhbGUueSAqIHpvb20pO1xyXG5cclxuICAgIGlmIChyb3RGbGlwICE9PSAwKSB7XHJcbiAgICAgIGxldCBzY2FsZVggPSAxO1xyXG4gICAgICBsZXQgc2NhbGVZID0gMTtcclxuICAgICAgbGV0IHNoZWFyWCA9IDA7XHJcbiAgICAgIGxldCBzaGVhclkgPSAwO1xyXG5cclxuICAgICAgLy8gRmxpcCBvbiB0aGUgeC1heGlzXHJcbiAgICAgIGlmIChyb3RGbGlwICYgOCkge1xyXG4gICAgICAgIHNjYWxlWCA9IC0xO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGbGlwIG9uIHRoZSB5LWF4aXNcclxuICAgICAgaWYgKHJvdEZsaXAgJiA0KSB7XHJcbiAgICAgICAgc2NhbGVZID0gLTE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZsaXAgb3ZlciB0aGUgbGluZSB5PXhcclxuICAgICAgaWYgKHJvdEZsaXAgJiAyKSB7XHJcbiAgICAgICAgc2hlYXJYID0gc2NhbGVZO1xyXG4gICAgICAgIHNoZWFyWSA9IHNjYWxlWDtcclxuICAgICAgICBzY2FsZVggPSAwO1xyXG4gICAgICAgIHNjYWxlWSA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShcclxuICAgICAgICBzY2FsZVgsXHJcbiAgICAgICAgc2hlYXJYLFxyXG4gICAgICAgIHNoZWFyWSxcclxuICAgICAgICBzY2FsZVksXHJcbiAgICAgICAgd29ybGRYICsgd29ybGRXaWR0aCAvIDIsXHJcbiAgICAgICAgd29ybGRZICsgd29ybGRIZWlnaHQgLyAyLFxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gUmVuZGVyIHRoZSB0aWxlXHJcbiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShcclxuICAgICAgICBpbWFnZSxcclxuICAgICAgICBsZWZ0LFxyXG4gICAgICAgIHRvcCxcclxuICAgICAgICB3aWR0aCxcclxuICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgLXdvcmxkV2lkdGggLyAyLFxyXG4gICAgICAgIC13b3JsZEhlaWdodCAvIDIsXHJcbiAgICAgICAgd29ybGRXaWR0aCxcclxuICAgICAgICB3b3JsZEhlaWdodCxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmIChyb3RGbGlwICE9PSAwKSB7XHJcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBObyByb3RhdGlvbnMsIGRvbid0IGRvIHRoZSBjYWxjdWxhdGlvbnMsIGp1c3QgcmVuZGVyIHRoZSB0aWxlXHJcbiAgICAgIC8vIFJlbmRlciB0aGUgdGlsZVxyXG4gICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgaW1hZ2UsXHJcbiAgICAgICAgbGVmdCxcclxuICAgICAgICB0b3AsXHJcbiAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgIHdvcmxkWCxcclxuICAgICAgICB3b3JsZFksXHJcbiAgICAgICAgd29ybGRXaWR0aCxcclxuICAgICAgICB3b3JsZEhlaWdodCxcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgU2xpZGVyIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1NsaWRlclwiO1xyXG5pbXBvcnQgVGV4dElucHV0IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XHJcblxyXG4vKipcclxuICogQSB1dGlsaXR5IGNsYXNzIHRvIGhlbHAgdGhlIEByZWZlcmVuY2VbQ2FudmFzUmVuZGVyZXJdIHJlbmRlciBAcmVmZXJlbmNlW1VJRWxlbWVudF1zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVSUVsZW1lbnRSZW5kZXJlciB7XHJcbiAgcHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG4gIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcbiAgcHJvdGVjdGVkIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG5cclxuICBjb25zdHJ1Y3RvcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIHRoaXMuY3R4ID0gY3R4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgc2NlbmUgb2YgdGhpcyBVSUVsZW1lbnRSZW5kZXJlclxyXG4gICAqIEBwYXJhbSBzY2VuZSBUaGUgY3VycmVudCBzY2VuZVxyXG4gICAqL1xyXG4gIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xyXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVycyBhIGxhYmVsXHJcbiAgICogQHBhcmFtIGxhYmVsIFRoZSBsYWJlbCB0byByZW5kZXJcclxuICAgKi9cclxuICByZW5kZXJMYWJlbChsYWJlbDogTGFiZWwpOiB2b2lkIHtcclxuICAgIC8vIElmIHRoZSBzaXplIGlzIHVuYXNzaWduZWQgKGJ5IHRoZSB1c2VyIG9yIGF1dG9tYXRpY2FsbHkpIGFzc2lnbiBpdFxyXG4gICAgbGFiZWwuaGFuZGxlSW5pdGlhbFNpemluZyh0aGlzLmN0eCk7XHJcblxyXG4gICAgLy8gR3JhYiB0aGUgZ2xvYmFsIGFscGhhIHNvIHdlIGNhbiBhZGp1c3QgaXQgZm9yIHRoaXMgcmVuZGVyXHJcbiAgICBsZXQgcHJldmlvdXNBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xyXG5cclxuICAgIC8vIEdldCB0aGUgZm9udCBhbmQgdGV4dCBwb3NpdGlvbiBpbiBsYWJlbFxyXG4gICAgdGhpcy5jdHguZm9udCA9IGxhYmVsLmdldEZvbnRTdHJpbmcoKTtcclxuICAgIGxldCBvZmZzZXQgPSBsYWJlbC5jYWxjdWxhdGVUZXh0T2Zmc2V0KHRoaXMuY3R4KTtcclxuXHJcbiAgICAvLyBTdHJva2UgYW5kIGZpbGwgYSByb3VuZGVkIHJlY3QgYW5kIGdpdmUgaXQgdGV4dFxyXG4gICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBsYWJlbC5iYWNrZ3JvdW5kQ29sb3IuYTtcclxuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGxhYmVsLmNhbGN1bGF0ZUJhY2tncm91bmRDb2xvcigpLnRvU3RyaW5nUkdCQSgpO1xyXG4gICAgdGhpcy5jdHguZmlsbFJvdW5kZWRSZWN0KFxyXG4gICAgICAtbGFiZWwuc2l6ZS54IC8gMixcclxuICAgICAgLWxhYmVsLnNpemUueSAvIDIsXHJcbiAgICAgIGxhYmVsLnNpemUueCxcclxuICAgICAgbGFiZWwuc2l6ZS55LFxyXG4gICAgICBsYWJlbC5ib3JkZXJSYWRpdXMsXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gbGFiZWwuY2FsY3VsYXRlQm9yZGVyQ29sb3IoKS50b1N0cmluZ1JHQkEoKTtcclxuICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbGFiZWwuYm9yZGVyQ29sb3IuYTtcclxuICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IGxhYmVsLmJvcmRlcldpZHRoO1xyXG4gICAgdGhpcy5jdHguc3Ryb2tlUm91bmRlZFJlY3QoXHJcbiAgICAgIC1sYWJlbC5zaXplLnggLyAyLFxyXG4gICAgICAtbGFiZWwuc2l6ZS55IC8gMixcclxuICAgICAgbGFiZWwuc2l6ZS54LFxyXG4gICAgICBsYWJlbC5zaXplLnksXHJcbiAgICAgIGxhYmVsLmJvcmRlclJhZGl1cyxcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gbGFiZWwuY2FsY3VsYXRlVGV4dENvbG9yKCk7XHJcbiAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IGxhYmVsLnRleHRDb2xvci5hO1xyXG4gICAgdGhpcy5jdHguZmlsbFRleHQoXHJcbiAgICAgIGxhYmVsLnRleHQsXHJcbiAgICAgIG9mZnNldC54IC0gbGFiZWwuc2l6ZS54IC8gMixcclxuICAgICAgb2Zmc2V0LnkgLSBsYWJlbC5zaXplLnkgLyAyLFxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHByZXZpb3VzQWxwaGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW5kZXJzIGEgYnV0dG9uXHJcbiAgICogQHBhcmFtIGJ1dHRvbiBUaGUgYnV0dG9uIHRvIHJlbmRlclxyXG4gICAqL1xyXG4gIHJlbmRlckJ1dHRvbihidXR0b246IEJ1dHRvbik6IHZvaWQge1xyXG4gICAgdGhpcy5yZW5kZXJMYWJlbChidXR0b24pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVycyBhIHNsaWRlclxyXG4gICAqIEBwYXJhbSBzbGlkZXIgVGhlIHNsaWRlciB0byByZW5kZXJcclxuICAgKi9cclxuICByZW5kZXJTbGlkZXIoc2xpZGVyOiBTbGlkZXIpOiB2b2lkIHtcclxuICAgIC8vIEdyYWIgdGhlIGdsb2JhbCBhbHBoYSBzbyB3ZSBjYW4gYWRqdXN0IGl0IGZvciB0aGlzIHJlbmRlclxyXG4gICAgbGV0IHByZXZpb3VzQWxwaGEgPSB0aGlzLmN0eC5nbG9iYWxBbHBoYTtcclxuICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gc2xpZGVyLmdldExheWVyKCkuZ2V0QWxwaGEoKTtcclxuXHJcbiAgICAvLyBDYWxjdWFsYXRlIHRoZSBzbGlkZXIgc2l6ZVxyXG4gICAgbGV0IHNsaWRlclNpemUgPSBuZXcgVmVjMihzbGlkZXIuc2l6ZS54LCAyKTtcclxuXHJcbiAgICAvLyBEcmF3IHRoZSBzbGlkZXJcclxuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHNsaWRlci5zbGlkZXJDb2xvci50b1N0cmluZygpO1xyXG4gICAgdGhpcy5jdHguZmlsbFJvdW5kZWRSZWN0KFxyXG4gICAgICAtc2xpZGVyU2l6ZS54IC8gMixcclxuICAgICAgLXNsaWRlclNpemUueSAvIDIsXHJcbiAgICAgIHNsaWRlclNpemUueCxcclxuICAgICAgc2xpZGVyU2l6ZS55LFxyXG4gICAgICBzbGlkZXIuYm9yZGVyUmFkaXVzLFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG5pYiBzaXplIGFuZCBwb3NpdGlvblxyXG4gICAgbGV0IHggPSBNYXRoVXRpbHMubGVycChcclxuICAgICAgLXNsaWRlci5zaXplLnggLyAyLFxyXG4gICAgICBzbGlkZXIuc2l6ZS54IC8gMixcclxuICAgICAgc2xpZGVyLmdldFZhbHVlKCksXHJcbiAgICApO1xyXG5cclxuICAgIC8vIERyYXcgdGhlIG5pYlxyXG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gc2xpZGVyLm5pYkNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICB0aGlzLmN0eC5maWxsUm91bmRlZFJlY3QoXHJcbiAgICAgIHggLSBzbGlkZXIubmliU2l6ZS54IC8gMixcclxuICAgICAgLXNsaWRlci5uaWJTaXplLnkgLyAyLFxyXG4gICAgICBzbGlkZXIubmliU2l6ZS54LFxyXG4gICAgICBzbGlkZXIubmliU2l6ZS55LFxyXG4gICAgICBzbGlkZXIuYm9yZGVyUmFkaXVzLFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBSZXNldCB0aGUgYWxwaGFcclxuICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlcnMgYSB0ZXh0SW5wdXRcclxuICAgKiBAcGFyYW0gdGV4dElucHV0IFRoZSB0ZXh0SW5wdXQgdG8gcmVuZGVyXHJcbiAgICovXHJcbiAgcmVuZGVyVGV4dElucHV0KHRleHRJbnB1dDogVGV4dElucHV0KTogdm9pZCB7XHJcbiAgICAvLyBTaG93IGEgY3Vyc29yIHNvbWV0aW1lc1xyXG4gICAgaWYgKHRleHRJbnB1dC5mb2N1c2VkICYmIHRleHRJbnB1dC5jdXJzb3JDb3VudGVyICUgNjAgPiAzMCkge1xyXG4gICAgICB0ZXh0SW5wdXQudGV4dCArPSBcInxcIjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJlbmRlckxhYmVsKHRleHRJbnB1dCk7XHJcblxyXG4gICAgaWYgKHRleHRJbnB1dC5mb2N1c2VkKSB7XHJcbiAgICAgIGlmICh0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciAlIDYwID4gMzApIHtcclxuICAgICAgICB0ZXh0SW5wdXQudGV4dCA9IHRleHRJbnB1dC50ZXh0LnN1YnN0cmluZygwLCB0ZXh0SW5wdXQudGV4dC5sZW5ndGggLSAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGV4dElucHV0LmN1cnNvckNvdW50ZXIgKz0gMTtcclxuICAgICAgaWYgKHRleHRJbnB1dC5jdXJzb3JDb3VudGVyID49IDYwKSB7XHJcbiAgICAgICAgdGV4dElucHV0LmN1cnNvckNvdW50ZXIgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBmcmFtZXdvcmsgdG8gcHV0IGFsbCByZW5kZXJpbmcgaW4gb25jZSBwbGFjZSBpbiB0aGUgYXBwbGljYXRpb25cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFJlbmRlcmluZ01hbmFnZXIge1xyXG4gIC8qKiBUaGUgUmVzb3VyY2VNYW5hZ2VyICovXHJcbiAgcHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG5cclxuICAvKiogVGhlIHNjZW5lIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZCAqL1xyXG4gIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHNjZW5lIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZFxyXG4gICAqIEBwYXJhbSBzY2VuZSBUaGUgY3VycmVudCBTY2VuZVxyXG4gICAqL1xyXG4gIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xyXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSB0aGUgY2FudmFzIGZvciB0aGUgZ2FtZVxyXG4gICAqIEBwYXJhbSBjYW52YXMgVGhlIGNhbnZhcyBlbGVtZW50XHJcbiAgICogQHBhcmFtIHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBjYW52YXNcclxuICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgY2FudmFzXHJcbiAgICogQHJldHVybnMgVGhlIHJlbmRlcmluZyBjb250ZXh0IG9mIHRoZSBjYW52YXNcclxuICAgKi9cclxuICBhYnN0cmFjdCBpbml0aWFsaXplQ2FudmFzKFxyXG4gICAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcclxuICAgIHdpZHRoOiBudW1iZXIsXHJcbiAgICBoZWlnaHQ6IG51bWJlcixcclxuICApOiBhbnk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlcnMgdGhlIHZpc2libGUgc2V0IG9mIENhbnZhc05vZGVzIGFuZCB2aXNpYmxlIHBvcnRpb25zIG9mIHRpbGVtYXBzLCBhcyB3ZWxsIGFzIGFueSBVSUVsZW1lbnQgaW4gVUlMYXllcnNcclxuICAgKiBAcGFyYW0gdmlzaWJsZVNldCBUaGUgdmlzaWJsZSBzZXQgb2YgQ2FudmFzTm9kZXNcclxuICAgKiBAcGFyYW0gdGlsZW1hcHMgVGhlIHRpbGVtYXBzIHVzZWQgaW4gdGhlIGFwcGxpY2F0aW9uXHJcbiAgICogQHBhcmFtIHVpTGF5ZXJzIFRoZSB1c2VyIGludGVyZmFjZSBsYXllcnNcclxuICAgKi9cclxuICBhYnN0cmFjdCByZW5kZXIoXHJcbiAgICB2aXNpYmxlU2V0OiBBcnJheTxDYW52YXNOb2RlPixcclxuICAgIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPixcclxuICAgIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj4sXHJcbiAgKTogdm9pZDtcclxuXHJcbiAgLyoqIENsZWFycyB0aGUgY2FudmFzICovXHJcbiAgYWJzdHJhY3QgY2xlYXIoY29sb3I6IENvbG9yKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVycyBhIHNwcml0ZVxyXG4gICAqIEBwYXJhbSBzcHJpdGUgVGhlIHNwcml0ZSB0byByZW5kZXJcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyU3ByaXRlKHNwcml0ZTogU3ByaXRlKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVycyBhbiBhbmltYXRlZCBzcHJpdGVcclxuICAgKiBAcGFyYW0gc3ByaXRlIFRoZSBhbmltYXRlZCBzcHJpdGUgdG8gcmVuZGVyXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlckFuaW1hdGVkU3ByaXRlKHNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBSZW5kZXJzIGEgZ3JhcGhpY1xyXG4gICAqIEBwYXJhbSBncmFwaGljIFRoZSBncmFwaGljIHRvIHJlbmRlclxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJHcmFwaGljKGdyYXBoaWM6IEdyYXBoaWMpOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBSZW5kZXJzIGEgdGlsZW1hcFxyXG4gICAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRvIHJlbmRlclxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBSZW5kZXJzIGEgVUlFbGVtZW50XHJcbiAgICogQHBhcmFtIHVpRWxlbWVudCBUaGUgVUlFbGVtZW50IHRvIHJlbmRlclxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJVSUVsZW1lbnQodWlFbGVtZW50OiBVSUVsZW1lbnQpOiB2b2lkO1xyXG59XHJcbiIsImltcG9ydCBHcmFwaCBmcm9tIFwiLi4vRGF0YVR5cGVzL0dyYXBocy9HcmFwaFwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljXCI7XHJcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBSZWN0IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBTaGFkZXJSZWdpc3RyeSBmcm9tIFwiLi4vUmVnaXN0cnkvUmVnaXN0cmllcy9TaGFkZXJSZWdpc3RyeVwiO1xyXG5pbXBvcnQgUmVnaXN0cnlNYW5hZ2VyIGZyb20gXCIuLi9SZWdpc3RyeS9SZWdpc3RyeU1hbmFnZXJcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgUGFyYWxsYXhMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1BhcmFsbGF4TGF5ZXJcIjtcclxuaW1wb3J0IFVJTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9VSUxheWVyXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IFJlbmRlcmluZ1V0aWxzIGZyb20gXCIuLi9VdGlscy9SZW5kZXJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi9SZW5kZXJpbmdNYW5hZ2VyXCI7XHJcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJpbmdNYW5hZ2VyIHtcclxuICBwcm90ZWN0ZWQgb3JpZ2luOiBWZWMyO1xyXG4gIHByb3RlY3RlZCB6b29tOiBudW1iZXI7XHJcbiAgcHJvdGVjdGVkIHdvcmxkU2l6ZTogVmVjMjtcclxuXHJcbiAgcHJvdGVjdGVkIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgcHJvdGVjdGVkIHRleHRDdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuXHJcbiAgaW5pdGlhbGl6ZUNhbnZhcyhcclxuICAgIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXHJcbiAgICB3aWR0aDogbnVtYmVyLFxyXG4gICAgaGVpZ2h0OiBudW1iZXIsXHJcbiAgKTogV2ViR0xSZW5kZXJpbmdDb250ZXh0IHtcclxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICB0aGlzLndvcmxkU2l6ZSA9IFZlYzIuWkVSTztcclxuICAgIHRoaXMud29ybGRTaXplLnggPSB3aWR0aDtcclxuICAgIHRoaXMud29ybGRTaXplLnkgPSBoZWlnaHQ7XHJcblxyXG4gICAgLy8gR2V0IHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgICB0aGlzLmdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKTtcclxuXHJcbiAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG4gICAgdGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuREVQVEhfVEVTVCk7XHJcbiAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkJMRU5EKTtcclxuICAgIHRoaXMuZ2wuYmxlbmRGdW5jKHRoaXMuZ2wuU1JDX0FMUEhBLCB0aGlzLmdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgdGhpcy5nbC5lbmFibGUodGhpcy5nbC5DVUxMX0ZBQ0UpO1xyXG5cclxuICAgIC8vIFRlbGwgdGhlIHJlc291cmNlIG1hbmFnZXIgd2UncmUgdXNpbmcgV2ViR0xcclxuICAgIFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVzZVdlYkdMKHRydWUsIHRoaXMuZ2wpO1xyXG5cclxuICAgIC8vIFNob3cgdGhlIHRleHQgY2FudmFzIGFuZCBnZXQgaXRzIGNvbnRleHRcclxuICAgIGxldCB0ZXh0Q2FudmFzID0gPEhUTUxDYW52YXNFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGV4dC1jYW52YXNcIik7XHJcbiAgICB0ZXh0Q2FudmFzLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgdGhpcy50ZXh0Q3R4ID0gdGV4dENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgLy8gU2l6ZSB0aGUgdGV4dCBjYW52YXMgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIGdhbWUgY2FudmFzXHJcbiAgICB0ZXh0Q2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIHRleHRDYW52YXMud2lkdGggPSB3aWR0aDtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5nbDtcclxuICB9XHJcblxyXG4gIHJlbmRlcihcclxuICAgIHZpc2libGVTZXQ6IENhbnZhc05vZGVbXSxcclxuICAgIHRpbGVtYXBzOiBUaWxlbWFwW10sXHJcbiAgICB1aUxheWVyczogTWFwPFVJTGF5ZXI+LFxyXG4gICk6IHZvaWQge1xyXG4gICAgZm9yIChsZXQgbm9kZSBvZiB2aXNpYmxlU2V0KSB7XHJcbiAgICAgIHRoaXMucmVuZGVyTm9kZShub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICB1aUxheWVycy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGlmICghdWlMYXllcnMuZ2V0KGtleSkuaXNIaWRkZW4oKSlcclxuICAgICAgICB1aUxheWVyc1xyXG4gICAgICAgICAgLmdldChrZXkpXHJcbiAgICAgICAgICAuZ2V0SXRlbXMoKVxyXG4gICAgICAgICAgLmZvckVhY2gobm9kZSA9PiB0aGlzLnJlbmRlck5vZGUoPENhbnZhc05vZGU+bm9kZSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBjbGVhcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuICAgIHRoaXMuZ2wuY2xlYXJDb2xvcihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hKTtcclxuICAgIHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUIHwgdGhpcy5nbC5ERVBUSF9CVUZGRVJfQklUKTtcclxuXHJcbiAgICB0aGlzLnRleHRDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud29ybGRTaXplLngsIHRoaXMud29ybGRTaXplLnkpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHJlbmRlck5vZGUobm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0IGFjY29yZGluZyB0byB0aGlzIHNwcml0ZVxyXG4gICAgdGhpcy5vcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbihub2RlKTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHNjZW5lXHJcbiAgICB0aGlzLnpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xyXG5cclxuICAgIGlmIChub2RlLmhhc0N1c3RvbVNoYWRlcikge1xyXG4gICAgICAvLyBJZiB0aGUgbm9kZSBoYXMgYSBjdXN0b20gc2hhZGVyLCByZW5kZXIgdXNpbmcgdGhhdFxyXG4gICAgICB0aGlzLnJlbmRlckN1c3RvbShub2RlKTtcclxuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEdyYXBoaWMpIHtcclxuICAgICAgdGhpcy5yZW5kZXJHcmFwaGljKG5vZGUpO1xyXG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgU3ByaXRlKSB7XHJcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQW5pbWF0ZWRTcHJpdGUpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckFuaW1hdGVkU3ByaXRlKG5vZGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMucmVuZGVyU3ByaXRlKG5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBVSUVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5yZW5kZXJVSUVsZW1lbnQobm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgcmVuZGVyU3ByaXRlKHNwcml0ZTogU3ByaXRlKTogdm9pZCB7XHJcbiAgICBsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LlNQUklURV9TSEFERVIpO1xyXG4gICAgbGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMoc3ByaXRlKSwgc3ByaXRlKTtcclxuICAgIHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgcmVuZGVyQW5pbWF0ZWRTcHJpdGUoc3ByaXRlOiBBbmltYXRlZFNwcml0ZSk6IHZvaWQge1xyXG4gICAgbGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5TUFJJVEVfU0hBREVSKTtcclxuICAgIGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKHNwcml0ZSksIHNwcml0ZSk7XHJcbiAgICBzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHJlbmRlckdyYXBoaWMoZ3JhcGhpYzogR3JhcGhpYyk6IHZvaWQge1xyXG4gICAgaWYgKGdyYXBoaWMgaW5zdGFuY2VvZiBQb2ludCkge1xyXG4gICAgICBsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LlBPSU5UX1NIQURFUik7XHJcbiAgICAgIGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKGdyYXBoaWMpLCBncmFwaGljKTtcclxuICAgICAgc2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcclxuICAgIH0gZWxzZSBpZiAoZ3JhcGhpYyBpbnN0YW5jZW9mIFJlY3QpIHtcclxuICAgICAgbGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5SRUNUX1NIQURFUik7XHJcbiAgICAgIGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKGdyYXBoaWMpLCBncmFwaGljKTtcclxuICAgICAgc2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCByZW5kZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHJlbmRlclVJRWxlbWVudCh1aUVsZW1lbnQ6IFVJRWxlbWVudCk6IHZvaWQge1xyXG4gICAgaWYgKHVpRWxlbWVudCBpbnN0YW5jZW9mIExhYmVsKSB7XHJcbiAgICAgIGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuTEFCRUxfU0hBREVSKTtcclxuICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnModWlFbGVtZW50KSwgdWlFbGVtZW50KTtcclxuICAgICAgc2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcclxuXHJcbiAgICAgIHRoaXMudGV4dEN0eC5zZXRUcmFuc2Zvcm0oXHJcbiAgICAgICAgMSxcclxuICAgICAgICAwLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMSxcclxuICAgICAgICAodWlFbGVtZW50LnBvc2l0aW9uLnggLSB0aGlzLm9yaWdpbi54KSAqIHRoaXMuem9vbSxcclxuICAgICAgICAodWlFbGVtZW50LnBvc2l0aW9uLnkgLSB0aGlzLm9yaWdpbi55KSAqIHRoaXMuem9vbSxcclxuICAgICAgKTtcclxuICAgICAgdGhpcy50ZXh0Q3R4LnJvdGF0ZSgtdWlFbGVtZW50LnJvdGF0aW9uKTtcclxuICAgICAgbGV0IGdsb2JhbEFscGhhID0gdGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhO1xyXG4gICAgICB0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGEgPSB1aUVsZW1lbnQuYWxwaGE7XHJcblxyXG4gICAgICAvLyBSZW5kZXIgdGV4dFxyXG4gICAgICB0aGlzLnRleHRDdHguZm9udCA9IHVpRWxlbWVudC5nZXRGb250U3RyaW5nKCk7XHJcbiAgICAgIGxldCBvZmZzZXQgPSB1aUVsZW1lbnQuY2FsY3VsYXRlVGV4dE9mZnNldCh0aGlzLnRleHRDdHgpO1xyXG4gICAgICB0aGlzLnRleHRDdHguZmlsbFN0eWxlID0gdWlFbGVtZW50LmNhbGN1bGF0ZVRleHRDb2xvcigpO1xyXG4gICAgICB0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGEgPSB1aUVsZW1lbnQudGV4dENvbG9yLmE7XHJcbiAgICAgIHRoaXMudGV4dEN0eC5maWxsVGV4dChcclxuICAgICAgICB1aUVsZW1lbnQudGV4dCxcclxuICAgICAgICBvZmZzZXQueCAtIHVpRWxlbWVudC5zaXplLnggLyAyLFxyXG4gICAgICAgIG9mZnNldC55IC0gdWlFbGVtZW50LnNpemUueSAvIDIsXHJcbiAgICAgICk7XHJcblxyXG4gICAgICB0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcclxuICAgICAgdGhpcy50ZXh0Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCByZW5kZXJDdXN0b20obm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xyXG4gICAgbGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChub2RlLmN1c3RvbVNoYWRlcktleSk7XHJcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhub2RlKSwgbm9kZSk7XHJcbiAgICBzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGFkZE9wdGlvbnMoXHJcbiAgICBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxyXG4gICAgbm9kZTogQ2FudmFzTm9kZSxcclxuICApOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuICAgIC8vIEdpdmUgdGhlIHNoYWRlciBhY2Nlc3MgdG8gdGhlIHdvcmxkIHNpemVcclxuICAgIG9wdGlvbnMud29ybGRTaXplID0gdGhpcy53b3JsZFNpemU7XHJcblxyXG4gICAgLy8gQWRqdXN0IHRoZSBvcmlnaW4gcG9zaXRpb24gdG8gdGhlIHBhcmFsbGF4XHJcbiAgICBsZXQgbGF5ZXIgPSBub2RlLmdldExheWVyKCk7XHJcbiAgICBsZXQgcGFyYWxsYXggPSBuZXcgVmVjMigxLCAxKTtcclxuICAgIGlmIChsYXllciBpbnN0YW5jZW9mIFBhcmFsbGF4TGF5ZXIpIHtcclxuICAgICAgcGFyYWxsYXggPSAoPFBhcmFsbGF4TGF5ZXI+bGF5ZXIpLnBhcmFsbGF4O1xyXG4gICAgfVxyXG5cclxuICAgIG9wdGlvbnMub3JpZ2luID0gdGhpcy5vcmlnaW4uY2xvbmUoKS5tdWx0KHBhcmFsbGF4KTtcclxuXHJcbiAgICByZXR1cm4gb3B0aW9ucztcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcblxyXG4vKipcclxuICogQSB3cmFwcGVyIGNsYXNzIGZvciBXZWJHTCBzaGFkZXJzLlxyXG4gKiBUaGlzIGNsYXNzIGlzIGEgc2luZ2xldG9uLCBhbmQgdGhlcmUgaXMgb25seSBvbmUgZm9yIGVhY2ggc2hhZGVyIHR5cGUuXHJcbiAqIEFsbCBvYmplY3RzIHRoYXQgdXNlIHRoaXMgc2hhZGVyIHR5cGUgd2lsbCByZWZlciB0byBhbmQgbW9kaWZ5IHRoaXMgc2FtZSB0eXBlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyVHlwZSB7XHJcbiAgLyoqIFRoZSBuYW1lIG9mIHRoaXMgc2hhZGVyICovXHJcbiAgcHJvdGVjdGVkIG5hbWU6IHN0cmluZztcclxuXHJcbiAgLyoqIFRoZSBrZXkgdG8gdGhlIFdlYkdMUHJvZ3JhbSBpbiB0aGUgUmVzb3VyY2VNYW5hZ2VyICovXHJcbiAgcHJvdGVjdGVkIHByb2dyYW1LZXk6IHN0cmluZztcclxuXHJcbiAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSByZXNvdXJjZSBtYW5hZ2VyICovXHJcbiAgcHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpIHtcclxuICAgIHRoaXMucHJvZ3JhbUtleSA9IHByb2dyYW1LZXk7XHJcbiAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgYW55IGJ1ZmZlciBvYmplY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNoYWRlciB0eXBlLlxyXG4gICAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgKi9cclxuICBhYnN0cmFjdCBpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWRzIGFueSB1bmlmb3Jtc1xyXG4gICAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgKiBAcGFyYW0gb3B0aW9ucyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmdcclxuICAgKi9cclxuICBhYnN0cmFjdCByZW5kZXIoXHJcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxyXG4gICAgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PixcclxuICApOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBFeHRyYWN0cyB0aGUgb3B0aW9ucyBmcm9tIHRoZSBDYW52YXNOb2RlIGFuZCBnaXZlcyB0aGVtIHRvIHRoZSByZW5kZXIgZnVuY3Rpb25cclxuICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBnZXQgb3B0aW9ucyBmcm9tXHJcbiAgICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSByZW5kZXIgZnVuY3Rpb25cclxuICAgKi9cclxuICBnZXRPcHRpb25zKG5vZGU6IENhbnZhc05vZGUpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uLy4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgUXVhZFNoYWRlclR5cGUgZnJvbSBcIi4vUXVhZFNoYWRlclR5cGVcIjtcclxuXHJcbi8qKiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbFNoYWRlclR5cGUgZXh0ZW5kcyBRdWFkU2hhZGVyVHlwZSB7XHJcbiAgY29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKSB7XHJcbiAgICBzdXBlcihwcm9ncmFtS2V5KTtcclxuICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgfVxyXG5cclxuICBpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQge1xyXG4gICAgdGhpcy5idWZmZXJPYmplY3RLZXkgPSBcImxhYmVsXCI7XHJcbiAgICB0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLnRvV2ViR0woKTtcclxuICAgIGNvbnN0IGJvcmRlckNvbG9yID0gb3B0aW9ucy5ib3JkZXJDb2xvci50b1dlYkdMKCk7XHJcblxyXG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNoYWRlclByb2dyYW0odGhpcy5wcm9ncmFtS2V5KTtcclxuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XHJcblxyXG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcbiAgICBjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy5nZXRWZXJ0aWNlcyhvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnkpO1xyXG5cclxuICAgIGNvbnN0IEZTSVpFID0gdmVydGV4RGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcclxuXHJcbiAgICAvLyBCaW5kIHRoZSBidWZmZXJcclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGEsIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAvLyBBdHRyaWJ1dGVzXHJcbiAgICBjb25zdCBhX1Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1Bvc2l0aW9uXCIpO1xyXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcclxuICAgICAgYV9Qb3NpdGlvbixcclxuICAgICAgMixcclxuICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgIGZhbHNlLFxyXG4gICAgICAyICogRlNJWkUsXHJcbiAgICAgIDAgKiBGU0laRSxcclxuICAgICk7XHJcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1Bvc2l0aW9uKTtcclxuXHJcbiAgICAvLyBVbmlmb3Jtc1xyXG4gICAgY29uc3QgdV9CYWNrZ3JvdW5kQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oXHJcbiAgICAgIHByb2dyYW0sXHJcbiAgICAgIFwidV9CYWNrZ3JvdW5kQ29sb3JcIixcclxuICAgICk7XHJcbiAgICBnbC51bmlmb3JtNGZ2KHVfQmFja2dyb3VuZENvbG9yLCBiYWNrZ3JvdW5kQ29sb3IpO1xyXG5cclxuICAgIGNvbnN0IHVfQm9yZGVyQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlckNvbG9yXCIpO1xyXG4gICAgZ2wudW5pZm9ybTRmdih1X0JvcmRlckNvbG9yLCBib3JkZXJDb2xvcik7XHJcblxyXG4gICAgY29uc3QgdV9NYXhTaXplID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9NYXhTaXplXCIpO1xyXG4gICAgZ2wudW5pZm9ybTJmKHVfTWF4U2l6ZSwgLXZlcnRleERhdGFbMF0sIHZlcnRleERhdGFbMV0pO1xyXG5cclxuICAgIC8vIEdldCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuICAgIC8vIFdlIHdhbnQgYSBzcXVhcmUgZm9yIG91ciByZW5kZXJpbmcgc3BhY2UsIHNvIGdldCB0aGUgbWF4aW11bSBkaW1lbnNpb24gb2Ygb3VyIHF1YWRcclxuICAgIGxldCBtYXhEaW1lbnNpb24gPSBNYXRoLm1heChvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnkpO1xyXG5cclxuICAgIGNvbnN0IHVfQm9yZGVyV2lkdGggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlcldpZHRoXCIpO1xyXG4gICAgZ2wudW5pZm9ybTFmKHVfQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGggLyBtYXhEaW1lbnNpb24pO1xyXG5cclxuICAgIGNvbnN0IHVfQm9yZGVyUmFkaXVzID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Cb3JkZXJSYWRpdXNcIik7XHJcbiAgICBnbC51bmlmb3JtMWYodV9Cb3JkZXJSYWRpdXMsIG9wdGlvbnMuYm9yZGVyUmFkaXVzIC8gbWF4RGltZW5zaW9uKTtcclxuXHJcbiAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgcmVuZGVyaW5nIHNwYWNlIHdpbGwgYmUgYSBzcXVhcmUgd2l0aCB0aGlzIG1heGltdW0gZGltZW5zaW9uXHJcbiAgICBsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZShcclxuICAgICAgMiAvIG9wdGlvbnMud29ybGRTaXplLngsXHJcbiAgICAgIDIgLyBvcHRpb25zLndvcmxkU2l6ZS55LFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDZW50ZXIgb3VyIHRyYW5zbGF0aW9ucyBhcm91bmQgKDAsIDApXHJcbiAgICBjb25zdCB0cmFuc2xhdGVYID1cclxuICAgICAgKG9wdGlvbnMucG9zaXRpb24ueCAtIG9wdGlvbnMub3JpZ2luLnggLSBvcHRpb25zLndvcmxkU2l6ZS54IC8gMikgL1xyXG4gICAgICBtYXhEaW1lbnNpb247XHJcbiAgICBjb25zdCB0cmFuc2xhdGVZID1cclxuICAgICAgLShvcHRpb25zLnBvc2l0aW9uLnkgLSBvcHRpb25zLm9yaWdpbi55IC0gb3B0aW9ucy53b3JsZFNpemUueSAvIDIpIC9cclxuICAgICAgbWF4RGltZW5zaW9uO1xyXG5cclxuICAgIC8vIENyZWF0ZSBvdXIgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcbiAgICB0aGlzLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZShuZXcgRmxvYXQzMkFycmF5KFt0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSkpO1xyXG4gICAgdGhpcy5zY2FsZS5zY2FsZShzaXplKTtcclxuICAgIHRoaXMucm90YXRpb24ucm90YXRlKG9wdGlvbnMucm90YXRpb24pO1xyXG4gICAgbGV0IHRyYW5zZm9ybWF0aW9uID0gTWF0NHg0Lk1VTFQoXHJcbiAgICAgIHRoaXMudHJhbnNsYXRpb24sXHJcbiAgICAgIHRoaXMuc2NhbGUsXHJcbiAgICAgIHRoaXMucm90YXRpb24sXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFBhc3MgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeCB0byBvdXIgc2hhZGVyXHJcbiAgICBjb25zdCB1X1RyYW5zZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfVHJhbnNmb3JtXCIpO1xyXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdih1X1RyYW5zZm9ybSwgZmFsc2UsIHRyYW5zZm9ybWF0aW9uLnRvQXJyYXkoKSk7XHJcblxyXG4gICAgLy8gRHJhdyB0aGUgcXVhZFxyXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgcmVuZGVyaW5nIHNwYWNlIGFsd2F5cyBoYXMgdG8gYmUgYSBzcXVhcmUsIHNvIG1ha2Ugc3VyZSBpdHMgc3F1YXJlIHcuci50IHRvIHRoZSBsYXJnZXN0IGRpbWVuc2lvblxyXG4gICAqIEBwYXJhbSB3IFRoZSB3aWR0aCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcclxuICAgKiBAcGFyYW0gaCBUaGUgaGVpZ2h0IG9mIHRoZSBxdWFkIGluIHBpeGVsc1xyXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgcXVhZFxyXG4gICAqL1xyXG4gIGdldFZlcnRpY2VzKHc6IG51bWJlciwgaDogbnVtYmVyKTogRmxvYXQzMkFycmF5IHtcclxuICAgIGxldCB4LCB5O1xyXG5cclxuICAgIGlmIChoID4gdykge1xyXG4gICAgICB5ID0gMC41O1xyXG4gICAgICB4ID0gdyAvICgyICogaCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4ID0gMC41O1xyXG4gICAgICB5ID0gaCAvICgyICogdyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWy14LCB5LCAteCwgLXksIHgsIHksIHgsIC15XSk7XHJcbiAgfVxyXG5cclxuICBnZXRPcHRpb25zKHJlY3Q6IExhYmVsKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICBsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcclxuICAgICAgcG9zaXRpb246IHJlY3QucG9zaXRpb24sXHJcbiAgICAgIGJhY2tncm91bmRDb2xvcjogcmVjdC5jYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3IoKSxcclxuICAgICAgYm9yZGVyQ29sb3I6IHJlY3QuY2FsY3VsYXRlQm9yZGVyQ29sb3IoKSxcclxuICAgICAgYm9yZGVyV2lkdGg6IHJlY3QuYm9yZGVyV2lkdGgsXHJcbiAgICAgIGJvcmRlclJhZGl1czogcmVjdC5ib3JkZXJSYWRpdXMsXHJcbiAgICAgIHNpemU6IHJlY3Quc2l6ZSxcclxuICAgICAgcm90YXRpb246IHJlY3Qucm90YXRpb24sXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBvcHRpb25zO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uLy4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgUmVuZGVyaW5nVXRpbHMgZnJvbSBcIi4uLy4uLy4uL1V0aWxzL1JlbmRlcmluZ1V0aWxzXCI7XHJcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuLi9TaGFkZXJUeXBlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludFNoYWRlclR5cGUgZXh0ZW5kcyBTaGFkZXJUeXBlIHtcclxuICBwcm90ZWN0ZWQgYnVmZmVyT2JqZWN0S2V5OiBzdHJpbmc7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZykge1xyXG4gICAgc3VwZXIocHJvZ3JhbUtleSk7XHJcbiAgfVxyXG5cclxuICBpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQge1xyXG4gICAgdGhpcy5idWZmZXJPYmplY3RLZXkgPSBcInBvaW50XCI7XHJcbiAgICB0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgIGxldCBwb3NpdGlvbiA9IFJlbmRlcmluZ1V0aWxzLnRvV2ViR0xDb29yZHMoXHJcbiAgICAgIG9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgIG9wdGlvbnMub3JpZ2luLFxyXG4gICAgICBvcHRpb25zLndvcmxkU2l6ZSxcclxuICAgICk7XHJcbiAgICBsZXQgY29sb3IgPSBSZW5kZXJpbmdVdGlscy50b1dlYkdMQ29sb3Iob3B0aW9ucy5jb2xvcik7XHJcblxyXG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNoYWRlclByb2dyYW0odGhpcy5wcm9ncmFtS2V5KTtcclxuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XHJcblxyXG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcbiAgICBjb25zdCB2ZXJ0ZXhEYXRhID0gcG9zaXRpb247XHJcblxyXG4gICAgY29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xyXG5cclxuICAgIC8vIEJpbmQgdGhlIGJ1ZmZlclxyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgIC8vIEF0dHJpYnV0ZXNcclxuICAgIGNvbnN0IGFfUG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfUG9zaXRpb25cIik7XHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxyXG4gICAgICBhX1Bvc2l0aW9uLFxyXG4gICAgICAyLFxyXG4gICAgICBnbC5GTE9BVCxcclxuICAgICAgZmFsc2UsXHJcbiAgICAgIDIgKiBGU0laRSxcclxuICAgICAgMCAqIEZTSVpFLFxyXG4gICAgKTtcclxuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfUG9zaXRpb24pO1xyXG5cclxuICAgIC8vIFVuaWZvcm1zXHJcbiAgICBjb25zdCB1X0NvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Db2xvclwiKTtcclxuICAgIGdsLnVuaWZvcm00ZnYodV9Db2xvciwgY29sb3IpO1xyXG5cclxuICAgIGNvbnN0IHVfUG9pbnRTaXplID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Qb2ludFNpemVcIik7XHJcbiAgICBnbC51bmlmb3JtMWYodV9Qb2ludFNpemUsIG9wdGlvbnMucG9pbnRTaXplKTtcclxuXHJcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgMSk7XHJcbiAgfVxyXG5cclxuICBnZXRPcHRpb25zKHBvaW50OiBQb2ludCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG4gICAgbGV0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XHJcbiAgICAgIHBvc2l0aW9uOiBwb2ludC5wb3NpdGlvbixcclxuICAgICAgY29sb3I6IHBvaW50LmNvbG9yLFxyXG4gICAgICBwb2ludFNpemU6IHBvaW50LnNpemUsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBvcHRpb25zO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XHJcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuLi9TaGFkZXJUeXBlXCI7XHJcblxyXG4vKiogUmVwcmVzZW50cyBhbnkgV2ViR0wgb2JqZWN0cyB0aGF0IGhhdmUgYSBxdWFkIG1lc2ggKGkuZS4gYSByZWN0YW5ndWxhciBnYW1lIG9iamVjdCBjb21wb3NlZCBvZiBvbmx5IHR3byB0cmlhbmdsZXMpICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFF1YWRTaGFkZXJUeXBlIGV4dGVuZHMgU2hhZGVyVHlwZSB7XHJcbiAgLyoqIFRoZSBrZXkgdG8gdGhlIGJ1ZmZlciBvYmplY3QgZm9yIHRoaXMgc2hhZGVyICovXHJcbiAgcHJvdGVjdGVkIGJ1ZmZlck9iamVjdEtleTogc3RyaW5nO1xyXG5cclxuICAvKiogVGhlIHNjYWxlIG1hdHJpYyAqL1xyXG4gIHByb3RlY3RlZCBzY2FsZTogTWF0NHg0O1xyXG5cclxuICAvKiogVGhlIHJvdGF0aW9uIG1hdHJpeCAqL1xyXG4gIHByb3RlY3RlZCByb3RhdGlvbjogTWF0NHg0O1xyXG5cclxuICAvKiogVGhlIHRyYW5zbGF0aW9uIG1hdHJpeCAqL1xyXG4gIHByb3RlY3RlZCB0cmFuc2xhdGlvbjogTWF0NHg0O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpIHtcclxuICAgIHN1cGVyKHByb2dyYW1LZXkpO1xyXG5cclxuICAgIHRoaXMuc2NhbGUgPSBNYXQ0eDQuSURFTlRJVFk7XHJcbiAgICB0aGlzLnJvdGF0aW9uID0gTWF0NHg0LklERU5USVRZO1xyXG4gICAgdGhpcy50cmFuc2xhdGlvbiA9IE1hdDR4NC5JREVOVElUWTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgUXVhZFNoYWRlclR5cGUgZnJvbSBcIi4vUXVhZFNoYWRlclR5cGVcIjtcclxuXHJcbi8qKiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0U2hhZGVyVHlwZSBleHRlbmRzIFF1YWRTaGFkZXJUeXBlIHtcclxuICBjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpIHtcclxuICAgIHN1cGVyKHByb2dyYW1LZXkpO1xyXG4gICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICB9XHJcblxyXG4gIGluaXRCdWZmZXJPYmplY3QoKTogdm9pZCB7XHJcbiAgICB0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwicmVjdFwiO1xyXG4gICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuICB9XHJcblxyXG4gIHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcbiAgICBjb25zdCBjb2xvciA9IG9wdGlvbnMuY29sb3IudG9XZWJHTCgpO1xyXG5cclxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XHJcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG5cclxuICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XHJcblxyXG4gICAgY29uc3QgdmVydGV4RGF0YSA9IHRoaXMuZ2V0VmVydGljZXMob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcclxuXHJcbiAgICBjb25zdCBGU0laRSA9IHZlcnRleERhdGEuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG4gICAgLy8gQmluZCB0aGUgYnVmZmVyXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgLy8gQXR0cmlidXRlc1xyXG4gICAgY29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgIGFfUG9zaXRpb24sXHJcbiAgICAgIDIsXHJcbiAgICAgIGdsLkZMT0FULFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgMiAqIEZTSVpFLFxyXG4gICAgICAwICogRlNJWkUsXHJcbiAgICApO1xyXG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XHJcblxyXG4gICAgLy8gVW5pZm9ybXNcclxuICAgIGNvbnN0IHVfQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0NvbG9yXCIpO1xyXG4gICAgZ2wudW5pZm9ybTRmdih1X0NvbG9yLCBjb2xvcik7XHJcblxyXG4gICAgLy8gR2V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG4gICAgLy8gV2Ugd2FudCBhIHNxdWFyZSBmb3Igb3VyIHJlbmRlcmluZyBzcGFjZSwgc28gZ2V0IHRoZSBtYXhpbXVtIGRpbWVuc2lvbiBvZiBvdXIgcXVhZFxyXG4gICAgbGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XHJcblxyXG4gICAgLy8gVGhlIHNpemUgb2YgdGhlIHJlbmRlcmluZyBzcGFjZSB3aWxsIGJlIGEgc3F1YXJlIHdpdGggdGhpcyBtYXhpbXVtIGRpbWVuc2lvblxyXG4gICAgbGV0IHNpemUgPSBuZXcgVmVjMihtYXhEaW1lbnNpb24sIG1heERpbWVuc2lvbikuc2NhbGUoXHJcbiAgICAgIDIgLyBvcHRpb25zLndvcmxkU2l6ZS54LFxyXG4gICAgICAyIC8gb3B0aW9ucy53b3JsZFNpemUueSxcclxuICAgICk7XHJcblxyXG4gICAgLy8gQ2VudGVyIG91ciB0cmFuc2xhdGlvbnMgYXJvdW5kICgwLCAwKVxyXG4gICAgY29uc3QgdHJhbnNsYXRlWCA9XHJcbiAgICAgIChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueCAvIDIpIC9cclxuICAgICAgbWF4RGltZW5zaW9uO1xyXG4gICAgY29uc3QgdHJhbnNsYXRlWSA9XHJcbiAgICAgIC0ob3B0aW9ucy5wb3NpdGlvbi55IC0gb3B0aW9ucy5vcmlnaW4ueSAtIG9wdGlvbnMud29ybGRTaXplLnkgLyAyKSAvXHJcbiAgICAgIG1heERpbWVuc2lvbjtcclxuXHJcbiAgICAvLyBDcmVhdGUgb3VyIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG4gICAgdGhpcy50cmFuc2xhdGlvbi50cmFuc2xhdGUobmV3IEZsb2F0MzJBcnJheShbdHJhbnNsYXRlWCwgdHJhbnNsYXRlWV0pKTtcclxuICAgIHRoaXMuc2NhbGUuc2NhbGUoc2l6ZSk7XHJcbiAgICB0aGlzLnJvdGF0aW9uLnJvdGF0ZShvcHRpb25zLnJvdGF0aW9uKTtcclxuICAgIGxldCB0cmFuc2Zvcm1hdGlvbiA9IE1hdDR4NC5NVUxUKFxyXG4gICAgICB0aGlzLnRyYW5zbGF0aW9uLFxyXG4gICAgICB0aGlzLnNjYWxlLFxyXG4gICAgICB0aGlzLnJvdGF0aW9uLFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxyXG4gICAgY29uc3QgdV9UcmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1RyYW5zZm9ybVwiKTtcclxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9UcmFuc2Zvcm0sIGZhbHNlLCB0cmFuc2Zvcm1hdGlvbi50b0FycmF5KCkpO1xyXG5cclxuICAgIC8vIERyYXcgdGhlIHF1YWRcclxuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xyXG4gIH1cclxuXHJcbiAgLypcclxuXHRcdFNvIGFzIGl0IHR1cm5zIG91dCwgV2ViR0wgaGFzIGFuIGlzc3VlIHdpdGggbm9uLXNxdWFyZSBxdWFkcy5cclxuXHRcdEl0IGRvZXNuJ3QgbGlrZSB3aGVuIHlvdSBkb24ndCBoYXZlIGEgMS0xIHNjYWxlLCBhbmQgcm90YXRpb25zIGFyZSBlbnRpcmVseSBtZXNzZWQgdXAgaWYgdGhpcyBpcyBub3QgdGhlIGNhc2UuXHJcblx0XHRUbyBzb2x2ZSB0aGlzLCBJIHVzZWQgdGhlIHNjYWxlIG9mIHRoZSBMQVJHRVNUIGRpbWVuc2lvbiBvZiB0aGUgcXVhZCB0byBtYWtlIGEgc3F1YXJlLCB0aGVuIGFkanVzdGVkIHRoZSB2ZXJ0ZXggY29vcmRpbmF0ZXMgaW5zaWRlIG9mIHRoYXQuXHJcblx0XHRBIGRpYWdyYW0gb2YgdGhlIHNvbHV0aW9uIGZvbGxvd3MuXHJcblxyXG5cdFx0VGhlcmUgaXMgYSBib3VuZGluZyBzcXVhcmUgZm9yIHRoZSBxdWFkIHdpdGggZGltZW5zaW9ucyBoeGggKGluIHRoaXMgY2FzZSwgc2luY2UgaGVpZ2h0IGlzIHRoZSBsYXJnZXN0IGRpbWVuc2lvbikuXHJcblx0XHRUaGUgb2Zmc2V0IGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24gaXMgdGhlcmVmb3JlIDAuNSwgYXMgaXQgaXMgbm9ybWFsbHkuXHJcblx0XHRIb3dldmVyLCB0aGUgb2Zmc2V0IGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbiBpcyBub3Qgc28gc3RyYWlnaHRmb3J3YXJkLCBidXQgaXNuJ3QgY29uY2VwdHVhbGx5IGhhcmQuXHJcblx0XHRBbGwgd2UgcmVhbGx5IGhhdmUgdG8gZG8gaXMgYSByYW5nZSBjaGFuZ2UgZnJvbSBbMCwgaGVpZ2h0LzJdIHRvIFswLCAwLjVdLCB3aGVyZSBvdXIgdmFsdWUgaXMgdCA9IHdpZHRoLzIsIGFuZCAwIDw9IHQgPD0gaGVpZ2h0LzIuXHJcblxyXG5cdFx0U28gbm93IHdlIGhhdmUgb3VyIHJlY3QsIGluIGEgc3BhY2Ugc2NhbGVkIHdpdGggcmVzcGVjdCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb24uXHJcblx0XHRSb3RhdGlvbnMgd29yayBhcyB5b3Ugd291bGQgZXhwZWN0LCBldmVuIGZvciBsb25nIHJlY3RhbmdsZXMuXHJcblxyXG5cdFx0XHRcdFx0MC41XHJcblx0XHRcdF9fIF9fIF9fIF9fIF9fIF9fIF9fXHJcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcclxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxyXG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XHJcblx0XHQtMC41fF8gX3w4ODg4ODg4ODg4OHxfIF98MC41XHJcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcclxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxyXG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XHJcblx0ICBcdFx0fF9fX3w4ODg4ODg4ODg4OHxfX198XHJcblx0XHRcdCAgXHRcdC0wLjVcclxuXHJcblx0XHRUaGUgZ2V0VmVydGljZXMgZnVuY3Rpb24gYmVsb3cgZG9lcyBhcyBkZXNjcmliZWQsIGFuZCBjb252ZXJ0cyB0aGUgcmFuZ2VcclxuXHQqL1xyXG4gIC8qKlxyXG4gICAqIFRoZSByZW5kZXJpbmcgc3BhY2UgYWx3YXlzIGhhcyB0byBiZSBhIHNxdWFyZSwgc28gbWFrZSBzdXJlIGl0cyBzcXVhcmUgdy5yLnQgdG8gdGhlIGxhcmdlc3QgZGltZW5zaW9uXHJcbiAgICogQHBhcmFtIHcgVGhlIHdpZHRoIG9mIHRoZSBxdWFkIGluIHBpeGVsc1xyXG4gICAqIEBwYXJhbSBoIFRoZSBoZWlnaHQgb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXHJcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIHZlcnRpY2VzIG9mIHRoZSBxdWFkXHJcbiAgICovXHJcbiAgZ2V0VmVydGljZXModzogbnVtYmVyLCBoOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgbGV0IHgsIHk7XHJcblxyXG4gICAgaWYgKGggPiB3KSB7XHJcbiAgICAgIHkgPSAwLjU7XHJcbiAgICAgIHggPSB3IC8gKDIgKiBoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHggPSAwLjU7XHJcbiAgICAgIHkgPSBoIC8gKDIgKiB3KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbLXgsIHksIC14LCAteSwgeCwgeSwgeCwgLXldKTtcclxuICB9XHJcblxyXG4gIGdldE9wdGlvbnMocmVjdDogUmVjdCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG4gICAgbGV0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XHJcbiAgICAgIHBvc2l0aW9uOiByZWN0LnBvc2l0aW9uLFxyXG4gICAgICBjb2xvcjogcmVjdC5jb2xvcixcclxuICAgICAgc2l6ZTogcmVjdC5zaXplLFxyXG4gICAgICByb3RhdGlvbjogcmVjdC5yb3RhdGlvbixcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBNYXQ0eDQgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9NYXQ0eDRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vLi4vRGVidWcvRGVidWdcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFF1YWRTaGFkZXJUeXBlIGZyb20gXCIuL1F1YWRTaGFkZXJUeXBlXCI7XHJcblxyXG4vKiogQSBzaGFkZXIgZm9yIHNwcml0ZXMgYW5kIGFuaW1hdGVkIHNwcml0ZXMgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByaXRlU2hhZGVyVHlwZSBleHRlbmRzIFF1YWRTaGFkZXJUeXBlIHtcclxuICBjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpIHtcclxuICAgIHN1cGVyKHByb2dyYW1LZXkpO1xyXG4gICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICB9XHJcblxyXG4gIGluaXRCdWZmZXJPYmplY3QoKTogdm9pZCB7XHJcbiAgICB0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwic3ByaXRlXCI7XHJcbiAgICB0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XHJcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFRleHR1cmUob3B0aW9ucy5pbWFnZUtleSk7XHJcblxyXG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcbiAgICBjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy5nZXRWZXJ0aWNlcyhcclxuICAgICAgb3B0aW9ucy5zaXplLngsXHJcbiAgICAgIG9wdGlvbnMuc2l6ZS55LFxyXG4gICAgICBvcHRpb25zLnNjYWxlLFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBGU0laRSA9IHZlcnRleERhdGEuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG4gICAgLy8gQmluZCB0aGUgYnVmZmVyXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgLy8gQXR0cmlidXRlc1xyXG4gICAgY29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgIGFfUG9zaXRpb24sXHJcbiAgICAgIDIsXHJcbiAgICAgIGdsLkZMT0FULFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgNCAqIEZTSVpFLFxyXG4gICAgICAwICogRlNJWkUsXHJcbiAgICApO1xyXG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XHJcblxyXG4gICAgY29uc3QgYV9UZXhDb29yZCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9UZXhDb29yZFwiKTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgIGFfVGV4Q29vcmQsXHJcbiAgICAgIDIsXHJcbiAgICAgIGdsLkZMT0FULFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgNCAqIEZTSVpFLFxyXG4gICAgICAyICogRlNJWkUsXHJcbiAgICApO1xyXG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9UZXhDb29yZCk7XHJcblxyXG4gICAgLy8gVW5pZm9ybXNcclxuICAgIC8vIEdldCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuICAgIC8vIFdlIHdhbnQgYSBzcXVhcmUgZm9yIG91ciByZW5kZXJpbmcgc3BhY2UsIHNvIGdldCB0aGUgbWF4aW11bSBkaW1lbnNpb24gb2Ygb3VyIHF1YWRcclxuICAgIGxldCBtYXhEaW1lbnNpb24gPSBNYXRoLm1heChvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnkpO1xyXG5cclxuICAgIC8vIFRoZSBzaXplIG9mIHRoZSByZW5kZXJpbmcgc3BhY2Ugd2lsbCBiZSBhIHNxdWFyZSB3aXRoIHRoaXMgbWF4aW11bSBkaW1lbnNpb25cclxuICAgIGxldCBzaXplID0gbmV3IFZlYzIobWF4RGltZW5zaW9uLCBtYXhEaW1lbnNpb24pLnNjYWxlKFxyXG4gICAgICAyIC8gb3B0aW9ucy53b3JsZFNpemUueCxcclxuICAgICAgMiAvIG9wdGlvbnMud29ybGRTaXplLnksXHJcbiAgICApO1xyXG5cclxuICAgIC8vIENlbnRlciBvdXIgdHJhbnNsYXRpb25zIGFyb3VuZCAoMCwgMClcclxuICAgIGNvbnN0IHRyYW5zbGF0ZVggPVxyXG4gICAgICAob3B0aW9ucy5wb3NpdGlvbi54IC0gb3B0aW9ucy5vcmlnaW4ueCAtIG9wdGlvbnMud29ybGRTaXplLnggLyAyKSAvXHJcbiAgICAgIG1heERpbWVuc2lvbjtcclxuICAgIGNvbnN0IHRyYW5zbGF0ZVkgPVxyXG4gICAgICAtKG9wdGlvbnMucG9zaXRpb24ueSAtIG9wdGlvbnMub3JpZ2luLnkgLSBvcHRpb25zLndvcmxkU2l6ZS55IC8gMikgL1xyXG4gICAgICBtYXhEaW1lbnNpb247XHJcblxyXG4gICAgLy8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuICAgIHRoaXMudHJhbnNsYXRpb24udHJhbnNsYXRlKG5ldyBGbG9hdDMyQXJyYXkoW3RyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldKSk7XHJcbiAgICB0aGlzLnNjYWxlLnNjYWxlKHNpemUpO1xyXG4gICAgdGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XHJcbiAgICBsZXQgdHJhbnNmb3JtYXRpb24gPSBNYXQ0eDQuTVVMVChcclxuICAgICAgdGhpcy50cmFuc2xhdGlvbixcclxuICAgICAgdGhpcy5zY2FsZSxcclxuICAgICAgdGhpcy5yb3RhdGlvbixcclxuICAgICk7XHJcblxyXG4gICAgLy8gUGFzcyB0aGUgdHJhbnNsYXRpb24gbWF0cml4IHRvIG91ciBzaGFkZXJcclxuICAgIGNvbnN0IHVfVHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9UcmFuc2Zvcm1cIik7XHJcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVfVHJhbnNmb3JtLCBmYWxzZSwgdHJhbnNmb3JtYXRpb24udG9BcnJheSgpKTtcclxuXHJcbiAgICAvLyBTZXQgdXAgb3VyIHNhbXBsZXIgd2l0aCBvdXIgYXNzaWduZWQgdGV4dHVyZSB1bml0XHJcbiAgICBjb25zdCB1X1NhbXBsZXIgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1NhbXBsZXJcIik7XHJcbiAgICBnbC51bmlmb3JtMWkodV9TYW1wbGVyLCB0ZXh0dXJlKTtcclxuXHJcbiAgICAvLyBQYXNzIGluIHRleFNoaWZ0XHJcbiAgICBjb25zdCB1X3RleFNoaWZ0ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV90ZXhTaGlmdFwiKTtcclxuICAgIGdsLnVuaWZvcm0yZnYodV90ZXhTaGlmdCwgb3B0aW9ucy50ZXhTaGlmdCk7XHJcblxyXG4gICAgLy8gUGFzcyBpbiB0ZXhTY2FsZVxyXG4gICAgY29uc3QgdV90ZXhTY2FsZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfdGV4U2NhbGVcIik7XHJcbiAgICBnbC51bmlmb3JtMmZ2KHVfdGV4U2NhbGUsIG9wdGlvbnMudGV4U2NhbGUpO1xyXG5cclxuICAgIC8vIERyYXcgdGhlIHF1YWRcclxuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHJlbmRlcmluZyBzcGFjZSBhbHdheXMgaGFzIHRvIGJlIGEgc3F1YXJlLCBzbyBtYWtlIHN1cmUgaXRzIHNxdWFyZSB3LnIudCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb25cclxuICAgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXHJcbiAgICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcclxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgdmVydGljZXMgb2YgdGhlIHF1YWRcclxuICAgKi9cclxuICBnZXRWZXJ0aWNlcyh3OiBudW1iZXIsIGg6IG51bWJlciwgc2NhbGU6IEZsb2F0MzJBcnJheSk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICBsZXQgeCwgeTtcclxuXHJcbiAgICBpZiAoaCA+IHcpIHtcclxuICAgICAgeSA9IDAuNTtcclxuICAgICAgeCA9IHcgLyAoMiAqIGgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeCA9IDAuNTtcclxuICAgICAgeSA9IGggLyAoMiAqIHcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNjYWxlIHRoZSByZW5kZXJpbmcgc3BhY2UgaWYgbmVlZGVkXHJcbiAgICB4ICo9IHNjYWxlWzBdO1xyXG4gICAgeSAqPSBzY2FsZVsxXTtcclxuXHJcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgIC14LFxyXG4gICAgICB5LFxyXG4gICAgICAwLjAsXHJcbiAgICAgIDAuMCxcclxuICAgICAgLXgsXHJcbiAgICAgIC15LFxyXG4gICAgICAwLjAsXHJcbiAgICAgIDEuMCxcclxuICAgICAgeCxcclxuICAgICAgeSxcclxuICAgICAgMS4wLFxyXG4gICAgICAwLjAsXHJcbiAgICAgIHgsXHJcbiAgICAgIC15LFxyXG4gICAgICAxLjAsXHJcbiAgICAgIDEuMCxcclxuICAgIF0pO1xyXG4gIH1cclxuXHJcbiAgZ2V0T3B0aW9ucyhzcHJpdGU6IFNwcml0ZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG4gICAgbGV0IHRleFNoaWZ0O1xyXG4gICAgbGV0IHRleFNjYWxlO1xyXG5cclxuICAgIGlmIChzcHJpdGUgaW5zdGFuY2VvZiBBbmltYXRlZFNwcml0ZSkge1xyXG4gICAgICBsZXQgYW5pbWF0aW9uSW5kZXggPSBzcHJpdGUuYW5pbWF0aW9uLmdldEluZGV4QW5kQWR2YW5jZUFuaW1hdGlvbigpO1xyXG4gICAgICBsZXQgb2Zmc2V0ID0gc3ByaXRlLmdldEFuaW1hdGlvbk9mZnNldChhbmltYXRpb25JbmRleCk7XHJcbiAgICAgIHRleFNoaWZ0ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgb2Zmc2V0LnggLyAoc3ByaXRlLmNvbHMgKiBzcHJpdGUuc2l6ZS54KSxcclxuICAgICAgICBvZmZzZXQueSAvIChzcHJpdGUucm93cyAqIHNwcml0ZS5zaXplLnkpLFxyXG4gICAgICBdKTtcclxuICAgICAgdGV4U2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KFsxIC8gc3ByaXRlLmNvbHMsIDEgLyBzcHJpdGUucm93c10pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGV4U2hpZnQgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwXSk7XHJcbiAgICAgIHRleFNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMV0pO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xyXG4gICAgICBwb3NpdGlvbjogc3ByaXRlLnBvc2l0aW9uLFxyXG4gICAgICByb3RhdGlvbjogc3ByaXRlLnJvdGF0aW9uLFxyXG4gICAgICBzaXplOiBzcHJpdGUuc2l6ZSxcclxuICAgICAgc2NhbGU6IHNwcml0ZS5zY2FsZS50b0FycmF5KCksXHJcbiAgICAgIGltYWdlS2V5OiBzcHJpdGUuaW1hZ2VJZCxcclxuICAgICAgdGV4U2hpZnQsXHJcbiAgICAgIHRleFNjYWxlLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gb3B0aW9ucztcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xyXG5pbXBvcnQgeyBUaWxlZFRpbGVtYXBEYXRhIH0gZnJvbSBcIi4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcclxuaW1wb3J0IFN0cmluZ1V0aWxzIGZyb20gXCIuLi9VdGlscy9TdHJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgQXVkaW9NYW5hZ2VyIGZyb20gXCIuLi9Tb3VuZC9BdWRpb01hbmFnZXJcIjtcclxuaW1wb3J0IFNwcml0ZXNoZWV0IGZyb20gXCIuLi9EYXRhVHlwZXMvU3ByaXRlc2hlZXRcIjtcclxuaW1wb3J0IFdlYkdMUHJvZ3JhbVR5cGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9SZW5kZXJpbmcvV2ViR0xQcm9ncmFtVHlwZVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSByZXNvdXJjZSBtYW5hZ2VyIGZvciB0aGUgZ2FtZSBlbmdpbmUuXHJcbiAqIFRoZSByZXNvdXJjZSBtYW5hZ2VyIGludGVyZmFjZXMgd2l0aCB0aGUgbG9hZGFibGUgYXNzZXRzIG9mIGEgZ2FtZSBzdWNoIGFzIGltYWdlcywgZGF0YSBmaWxlcyxcclxuICogYW5kIHNvdW5kcywgd2hpY2ggYXJlIGFsbCBmb3VuZCBpbiB0aGUgZGlzdCBmb2xkZXIuXHJcbiAqIFRoaXMgY2xhc3MgY29udHJvbHMgbG9hZGluZyBhbmQgdXBkYXRlcyB0aGUgQHJlZmVyZW5jZVtTY2VuZV0gd2l0aCB0aGUgbG9hZGluZyBwcm9ncmVzcywgc28gdGhhdCB0aGUgc2NlbmUgZG9lc1xyXG4gKiBub3Qgc3RhcnQgYmVmb3JlIGFsbCBuZWNlc3NhcnkgYXNzZXRzIGFyZSBsb2FkZWQuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNvdXJjZU1hbmFnZXIge1xyXG4gIC8vIEluc3RhbmNlIGZvciB0aGUgc2luZ2xldG9uIGNsYXNzXHJcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFJlc291cmNlTWFuYWdlcjtcclxuXHJcbiAgLy8gQm9vbGVhbnMgdG8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgUmVzb3VyY2VNYW5hZ2VyIGlzIGN1cnJlbnRseSBsb2FkaW5nIHNvbWV0aGluZ1xyXG4gIC8qKiBXaGV0aGVyIG9yIG5vdCBhbnkgcmVzb3VyY2VzIGFyZSBsb2FkaW5nICovXHJcbiAgcHJpdmF0ZSBsb2FkaW5nOiBib29sZWFuO1xyXG4gIC8qKiBBIGJvb2xlYW4gdG8gaW5kaWNhdGUgdGhhdCB0aGUgYXNzZXRzIGp1c3QgZmluaXNoZWQgbG9hZGluZyAqL1xyXG4gIHByaXZhdGUganVzdExvYWRlZDogYm9vbGVhbjtcclxuXHJcbiAgLy8gRnVuY3Rpb25zIHRvIGRvIHNvbWV0aGluZyB3aGVuIGxvYWRpbmcgcHJvZ3Jlc3NlcyBvciBpcyBjb21wbGV0ZWQgc3VjaCBhcyByZW5kZXIgYSBsb2FkaW5nIHNjcmVlblxyXG4gIC8qKiBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gbG9hZGluZyBwcm9ncmVzc2VzICovXHJcbiAgcHVibGljIG9uTG9hZFByb2dyZXNzOiBGdW5jdGlvbjtcclxuICAvKiogQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIGxvYWRpbmcgY29tcGxldGVzICovXHJcbiAgcHVibGljIG9uTG9hZENvbXBsZXRlOiBGdW5jdGlvbjtcclxuXHJcbiAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGltYWdlcyBuZWVkIHRvIGJlIGxvYWRlZCovXHJcbiAgcHJpdmF0ZSBsb2Fkb25seV9pbWFnZXNMb2FkZWQ6IG51bWJlcjtcclxuICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgaW1hZ2VzIGFyZSBsb2FkZWQgKi9cclxuICBwcml2YXRlIGxvYWRvbmx5X2ltYWdlc1RvTG9hZDogbnVtYmVyO1xyXG4gIC8qKiBUaGUgcXVldWUgb2YgaW1hZ2VzIHdlIG11c3QgbG9hZCAqL1xyXG4gIHByaXZhdGUgbG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcclxuICAvKiogQSBtYXAgb2YgdGhlIGltYWdlcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCBiZWluZyB1c2VkIGJ5IHRoZSBzY2VuZS4gVGhlIHJlZmVyZW5jZSB0byB0aGVzZSBpbWFnZXMgb25seSBleGlzdCBoZXJlIGZvciBlYXN5IGNsZWFudXAuICovXHJcbiAgcHJpdmF0ZSBpbWFnZXM6IE1hcDxIVE1MSW1hZ2VFbGVtZW50PjtcclxuXHJcbiAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRpbGVtYXBzIG5lZWQgdG8gYmUgbG9hZGVkICovXHJcbiAgcHJpdmF0ZSBsb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQ6IG51bWJlcjtcclxuICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgYXJlIGxvYWRlZCAqL1xyXG4gIHByaXZhdGUgbG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkOiBudW1iZXI7XHJcbiAgLyoqIFRoZSBxdWV1ZSBvZiB0aWxlbWFwcyB3ZSBtdXN0IGxvYWQgKi9cclxuICBwcml2YXRlIGxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XHJcbiAgLyoqIEEgbWFwIG9mIHRoZSB0aWxlbWFwcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCAocHJlc3VtYWJseSkgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUgKi9cclxuICBwcml2YXRlIHNwcml0ZXNoZWV0czogTWFwPFNwcml0ZXNoZWV0PjtcclxuXHJcbiAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRpbGVtYXBzIG5lZWQgdG8gYmUgbG9hZGVkICovXHJcbiAgcHJpdmF0ZSBsb2Fkb25seV90aWxlbWFwc0xvYWRlZDogbnVtYmVyO1xyXG4gIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBhcmUgbG9hZGVkICovXHJcbiAgcHJpdmF0ZSBsb2Fkb25seV90aWxlbWFwc1RvTG9hZDogbnVtYmVyO1xyXG4gIC8qKiBUaGUgcXVldWUgb2YgdGlsZW1hcHMgd2UgbXVzdCBsb2FkICovXHJcbiAgcHJpdmF0ZSBsb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XHJcbiAgLyoqIEEgbWFwIG9mIHRoZSB0aWxlbWFwcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCAocHJlc3VtYWJseSkgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUgKi9cclxuICBwcml2YXRlIHRpbGVtYXBzOiBNYXA8VGlsZWRUaWxlbWFwRGF0YT47XHJcblxyXG4gIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBzb3VuZHMgbmVlZCB0byBiZSBsb2FkZWQgKi9cclxuICBwcml2YXRlIGxvYWRvbmx5X2F1ZGlvTG9hZGVkOiBudW1iZXI7XHJcbiAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHNvdW5kcyBhcmUgbG9hZGVkICovXHJcbiAgcHJpdmF0ZSBsb2Fkb25seV9hdWRpb1RvTG9hZDogbnVtYmVyO1xyXG4gIC8qKiBUaGUgcXVldWUgb2Ygc291bmRzIHdlIG11c3QgbG9hZCAqL1xyXG4gIHByaXZhdGUgbG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcclxuICAvKiogQSBtYXAgb2YgdGhlIHNvdW5kcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCAocHJlc3VtYWJseSkgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUgKi9cclxuICBwcml2YXRlIGF1ZGlvQnVmZmVyczogTWFwPEF1ZGlvQnVmZmVyPjtcclxuXHJcbiAgLyoqIFRoZSB0b3RhbCBudW1iZXIgb2YgXCJ0eXBlc1wiIG9mIHRoaW5ncyB0aGF0IG5lZWQgdG8gYmUgbG9hZGVkIChpLmUuIGltYWdlcyBhbmQgdGlsZW1hcHMpICovXHJcbiAgcHJpdmF0ZSBsb2Fkb25seV90eXBlc1RvTG9hZDogbnVtYmVyO1xyXG5cclxuICBwcml2YXRlIGxvYWRvbmx5X2pzb25Mb2FkZWQ6IG51bWJlcjtcclxuICBwcml2YXRlIGxvYWRvbmx5X2pzb25Ub0xvYWQ6IG51bWJlcjtcclxuICBwcml2YXRlIGxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcclxuICBwcml2YXRlIGpzb25PYmplY3RzOiBNYXA8UmVjb3JkPHN0cmluZywgYW55Pj47XHJcblxyXG4gIC8qICMjIyMjIyMjIyMgSU5GT1JNQVRJT04gU1BFQ0lBTCBUTyBXRUJHTCAjIyMjIyMjIyMjICovXHJcbiAgcHJpdmF0ZSBnbF9XZWJHTEFjdGl2ZTogYm9vbGVhbjtcclxuXHJcbiAgcHJpdmF0ZSBsb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZDogbnVtYmVyO1xyXG4gIHByaXZhdGUgbG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQ6IG51bWJlcjtcclxuICBwcml2YXRlIGxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aF9TaGFkZXI+O1xyXG5cclxuICBwcml2YXRlIGdsX1NoYWRlclByb2dyYW1zOiBNYXA8V2ViR0xQcm9ncmFtVHlwZT47XHJcblxyXG4gIHByaXZhdGUgZ2xfVGV4dHVyZXM6IE1hcDxudW1iZXI+O1xyXG4gIHByaXZhdGUgZ2xfTmV4dFRleHR1cmVJRDogbnVtYmVyO1xyXG4gIHByaXZhdGUgZ2xfQnVmZmVyczogTWFwPFdlYkdMQnVmZmVyPjtcclxuXHJcbiAgcHJpdmF0ZSBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xyXG5cclxuICAvKiAjIyMjIyMjIyMjIFVOTE9BRElORyBBTkQgRVhDTFVTSU9OIExJU1QgIyMjIyMjIyMjIyAqL1xyXG4gIC8qKiBBIGxpc3Qgb2YgcmVzb3VyY2VzIHRoYXQgd2lsbCBiZSB1bmxvYWRlZCBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHNjZW5lICovXHJcbiAgcHJpdmF0ZSByZXNvdXJjZXNUb1VubG9hZDogQXJyYXk8UmVzb3VyY2VSZWZlcmVuY2U+O1xyXG5cclxuICAvKiogQSBsaXN0IG9mIHJlc291cmNlcyB0byBrZWVwIHVudGlsIGZ1cnRoZXIgbm90aWNlICovXHJcbiAgcHJpdmF0ZSByZXNvdXJjZXNUb0tlZXA6IEFycmF5PFJlc291cmNlUmVmZXJlbmNlPjtcclxuXHJcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5qdXN0TG9hZGVkID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgPSAwO1xyXG4gICAgdGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQgPSAwO1xyXG4gICAgdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgdGhpcy5pbWFnZXMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgPSAwO1xyXG4gICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPSAwO1xyXG4gICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgdGhpcy5zcHJpdGVzaGVldHMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9IDA7XHJcbiAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkID0gMDtcclxuICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgdGhpcy50aWxlbWFwcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkID0gMDtcclxuICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQgPSAwO1xyXG4gICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgdGhpcy5hdWRpb0J1ZmZlcnMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkID0gMDtcclxuICAgIHRoaXMubG9hZG9ubHlfanNvblRvTG9hZCA9IDA7XHJcbiAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgIHRoaXMuanNvbk9iamVjdHMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCA9IDA7XHJcbiAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zVG9Mb2FkID0gMDtcclxuICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcblxyXG4gICAgdGhpcy5nbF9TaGFkZXJQcm9ncmFtcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICB0aGlzLmdsX1RleHR1cmVzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5nbF9OZXh0VGV4dHVyZUlEID0gMDtcclxuICAgIHRoaXMuZ2xfQnVmZmVycyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkID0gbmV3IEFycmF5KCk7XHJcbiAgICB0aGlzLnJlc291cmNlc1RvS2VlcCA9IG5ldyBBcnJheSgpO1xyXG4gIH1cclxuXHJcbiAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBTSU5HTEVUT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIG9yIGEgbmV3IGluc3RhbmNlIGlmIG5vbmUgZXhpc3RcclxuICAgKiBAcmV0dXJucyBUaGUgcmVzb3VyY2UgbWFuYWdlclxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBSZXNvdXJjZU1hbmFnZXIge1xyXG4gICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XHJcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgUmVzb3VyY2VNYW5hZ2VyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XHJcbiAgfVxyXG5cclxuICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFBVQkxJQyBGVU5DVElPTiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cclxuICAvKipcclxuICAgKiBBY3RpdmF0ZXMgb3IgZGVhY3RpdmF0ZXMgdGhlIHVzZSBvZiBXZWJHTFxyXG4gICAqIEBwYXJhbSBmbGFnIFRydWUgaWYgV2ViR0wgc2hvdWxkIGJlIHVzZWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAqIEBwYXJhbSBnbCBUaGUgaW5zdGFuY2Ugb2YgdGhlIGdyYXBoaWNzIGNvbnRleHQsIGlmIGFwcGxpY2FibGVcclxuICAgKi9cclxuICBwdWJsaWMgdXNlV2ViR0woZmxhZzogYm9vbGVhbiwgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCk6IHZvaWQge1xyXG4gICAgdGhpcy5nbF9XZWJHTEFjdGl2ZSA9IGZsYWc7XHJcblxyXG4gICAgaWYgKHRoaXMuZ2xfV2ViR0xBY3RpdmUpIHtcclxuICAgICAgdGhpcy5nbCA9IGdsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZHMgYW4gaW1hZ2UgZnJvbSBmaWxlXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB0aGUgbG9hZGVkIGltYWdlIHdpdGhcclxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgaW1hZ2UgdG8gbG9hZFxyXG4gICAqL1xyXG4gIHB1YmxpYyBpbWFnZShrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoeyBrZXk6IGtleSwgcGF0aDogcGF0aCB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcclxuICAgKi9cclxuICBwdWJsaWMga2VlcEltYWdlKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZXMgYSBsb2FkZWQgaW1hZ2VcclxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCBpbWFnZVxyXG4gICAqIEByZXR1cm5zIFRoZSBpbWFnZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleVxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRJbWFnZShrZXk6IHN0cmluZyk6IEhUTUxJbWFnZUVsZW1lbnQge1xyXG4gICAgbGV0IGltYWdlID0gdGhpcy5pbWFnZXMuZ2V0KGtleSk7XHJcbiAgICBpZiAoaW1hZ2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBgVGhlcmUgaXMgbm8gaW1hZ2UgYXNzb2NpYXRlZCB3aXRoIGtleSBcIiR7a2V5fVwiYDtcclxuICAgIH1cclxuICAgIHJldHVybiBpbWFnZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWRzIGEgc3ByaXRlc2hlZXQgZnJvbSBmaWxlXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB0aGUgbG9hZGVkIHNwcml0ZXNoZWV0IHdpdGhcclxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgc3ByaXRlc2hlZXQgdG8gbG9hZFxyXG4gICAqL1xyXG4gIHB1YmxpYyBzcHJpdGVzaGVldChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmVucXVldWUoeyBrZXk6IGtleSwgcGF0aDogcGF0aCB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcclxuICAgKi9cclxuICBwdWJsaWMga2VlcFNwcml0ZXNoZWV0KGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5TUFJJVEVTSEVFVCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZXMgYSBsb2FkZWQgc3ByaXRlc2hlZXRcclxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNwcml0ZXNoZWV0IHRvIGxvYWRcclxuICAgKiBAcmV0dXJucyBUaGUgbG9hZGVkIFNwcml0ZXNoZWV0XHJcbiAgICovXHJcbiAgcHVibGljIGdldFNwcml0ZXNoZWV0KGtleTogc3RyaW5nKTogU3ByaXRlc2hlZXQge1xyXG4gICAgcmV0dXJuIHRoaXMuc3ByaXRlc2hlZXRzLmdldChrZXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZHMgYW4gYXVkaW8gZmlsZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbG9hZGVkIGF1ZGlvIGZpbGVcclxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXHJcbiAgICovXHJcbiAgcHVibGljIGF1ZGlvKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUuZW5xdWV1ZSh7IGtleToga2V5LCBwYXRoOiBwYXRoIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBrZWVwQXVkaW8oa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLkFVRElPKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlcyBhIGxvYWRlZCBhdWRpbyBmaWxlXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBhdWRpbyBmaWxlIHRvIGxvYWRcclxuICAgKiBAcmV0dXJucyBUaGUgQXVkaW9CdWZmZXIgY3JlYXRlZCBmcm9tIHRoZSBsb2FkZWQgYXVkaW8gZmxlXHJcbiAgICovXHJcbiAgcHVibGljIGdldEF1ZGlvKGtleTogc3RyaW5nKTogQXVkaW9CdWZmZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuYXVkaW9CdWZmZXJzLmdldChrZXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZCBhIHRpbGVtYXAgZnJvbSBhIGpzb24gZmlsZS4gQXV0b21hdGljYWxseSBsb2FkcyByZWxhdGVkIGltYWdlc1xyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbG9hZGVkIHRpbGVtYXBcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgdGlsZW1hcCB0byBsb2FkXHJcbiAgICovXHJcbiAgcHVibGljIHRpbGVtYXAoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmVucXVldWUoeyBrZXk6IGtleSwgcGF0aDogcGF0aCB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcclxuICAgKi9cclxuICBwdWJsaWMga2VlcFRpbGVtYXAoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLlRJTEVNQVApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmVpdmVzIGEgbG9hZGVkIHRpbGVtYXBcclxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwXHJcbiAgICogQHJldHVybnMgVGhlIHRpbGVtYXAgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleVxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRUaWxlbWFwKGtleTogc3RyaW5nKTogVGlsZWRUaWxlbWFwRGF0YSB7XHJcbiAgICByZXR1cm4gdGhpcy50aWxlbWFwcy5nZXQoa2V5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWRzIGFuIG9iamVjdCBmcm9tIGEganNvbiBmaWxlLlxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbG9hZGVkIG9iamVjdFxyXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBqc29uIGZpbGUgdG8gbG9hZFxyXG4gICAqL1xyXG4gIHB1YmxpYyBvYmplY3Qoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZykge1xyXG4gICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmVucXVldWUoeyBrZXk6IGtleSwgcGF0aDogcGF0aCB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcclxuICAgKi9cclxuICBwdWJsaWMga2VlcE9iamVjdChrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSlNPTik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyZWl2ZXMgYSBsb2FkZWQgb2JqZWN0XHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgb2JqZWN0XHJcbiAgICogQHJldHVybnMgVGhlIG9iamVjdCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XHJcbiAgICovXHJcbiAgcHVibGljIGdldE9iamVjdChrZXk6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIHRoaXMuanNvbk9iamVjdHMuZ2V0KGtleSk7XHJcbiAgfVxyXG5cclxuICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIExPQUQgRlVOQ1RJT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXHJcbiAgLyoqXHJcbiAgICogTG9hZHMgYWxsIHJlc291cmNlcyBjdXJyZW50bHkgaW4gdGhlIHF1ZXVlXHJcbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWwgd2hlbiB0aGUgcmVzb3VyY2VzIGFyZSBmaW5pc2hlZCBsb2FkaW5nXHJcbiAgICovXHJcbiAgbG9hZFJlc291cmNlc0Zyb21RdWV1ZShjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgIHRoaXMubG9hZG9ubHlfdHlwZXNUb0xvYWQgPSA1O1xyXG5cclxuICAgIHRoaXMubG9hZGluZyA9IHRydWU7XHJcblxyXG4gICAgLy8gTG9hZCBldmVyeXRoaW5nIGluIHRoZSBxdWV1ZXMuIFRpbGVtYXBzIGhhdmUgdG8gY29tZSBiZWZvcmUgaW1hZ2VzIGJlY2F1c2UgdGhleSB3aWxsIGFkZCBuZXcgaW1hZ2VzIHRvIHRoZSBxdWV1ZVxyXG4gICAgdGhpcy5sb2FkVGlsZW1hcHNGcm9tUXVldWUoKCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBUaWxlbWFwc1wiKTtcclxuICAgICAgdGhpcy5sb2FkU3ByaXRlc2hlZXRzRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBTcHJpdGVzaGVldHNcIik7XHJcbiAgICAgICAgdGhpcy5sb2FkSW1hZ2VzRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIEltYWdlc1wiKTtcclxuICAgICAgICAgIHRoaXMubG9hZEF1ZGlvRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgQXVkaW9cIik7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZE9iamVjdHNGcm9tUXVldWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIE9iamVjdHNcIik7XHJcblxyXG4gICAgICAgICAgICAgIGlmICh0aGlzLmdsX1dlYkdMQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdsX0xvYWRTaGFkZXJzRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgU2hhZGVyc1wiKTtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmcoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZmluaXNoTG9hZGluZyhjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgIC8vIERvbmUgbG9hZGluZ1xyXG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLmp1c3RMb2FkZWQgPSB0cnVlO1xyXG4gICAgY2FsbGJhY2soKTtcclxuICB9XHJcblxyXG4gIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgVU5MT0FEIEZVTkNUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xyXG5cclxuICBwcml2YXRlIGtlZXBSZXNvdXJjZShrZXk6IHN0cmluZywgdHlwZTogUmVzb3VyY2VUeXBlKTogdm9pZCB7XHJcbiAgICBjb25zb2xlLmxvZyhcIktlZXAgcmVzb3VyY2UuLi5cIik7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmVzb3VyY2VzVG9VbmxvYWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IHJlc291cmNlID0gdGhpcy5yZXNvdXJjZXNUb1VubG9hZFtpXTtcclxuICAgICAgaWYgKHJlc291cmNlLmtleSA9PT0ga2V5ICYmIHJlc291cmNlLnJlc291cmNlVHlwZSA9PT0gdHlwZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgXCJGb3VuZCByZXNvdXJjZSBcIiArIGtleSArIFwiIG9mIHR5cGUgXCIgKyB0eXBlICsgXCIuIEtlZXBpbmcuXCIsXHJcbiAgICAgICAgKTtcclxuICAgICAgICBsZXQgcmVzb3VyY2VUb01vdmUgPSB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnNwbGljZShpLCAxKTtcclxuICAgICAgICB0aGlzLnJlc291cmNlc1RvS2VlcC5wdXNoKC4uLnJlc291cmNlVG9Nb3ZlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZXMgcmVmZXJlbmNlcyB0byBhbGwgcmVzb3VyY2VzIGluIHRoZSByZXNvdXJjZSBtYW5hZ2VyXHJcbiAgICovXHJcbiAgdW5sb2FkQWxsUmVzb3VyY2VzKCk6IHZvaWQge1xyXG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLmp1c3RMb2FkZWQgPSBmYWxzZTtcclxuXHJcbiAgICBmb3IgKGxldCByZXNvdXJjZSBvZiB0aGlzLnJlc291cmNlc1RvVW5sb2FkKSB7XHJcbiAgICAgIC8vIFVubG9hZCB0aGUgcmVzb3VyY2VcclxuICAgICAgdGhpcy51bmxvYWRSZXNvdXJjZShyZXNvdXJjZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVubG9hZFJlc291cmNlKHJlc291cmNlOiBSZXNvdXJjZVJlZmVyZW5jZSk6IHZvaWQge1xyXG4gICAgLy8gRGVsZXRlIHRoZSByZXNvdXJjZSBpdHNlbGZcclxuICAgIHN3aXRjaCAocmVzb3VyY2UucmVzb3VyY2VUeXBlKSB7XHJcbiAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLklNQUdFOlxyXG4gICAgICAgIHRoaXMuaW1hZ2VzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xyXG4gICAgICAgIGlmICh0aGlzLmdsX1dlYkdMQWN0aXZlKSB7XHJcbiAgICAgICAgICB0aGlzLmdsX1RleHR1cmVzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuVElMRU1BUDpcclxuICAgICAgICB0aGlzLnRpbGVtYXBzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFJlc291cmNlVHlwZS5TUFJJVEVTSEVFVDpcclxuICAgICAgICB0aGlzLnNwcml0ZXNoZWV0cy5kZWxldGUocmVzb3VyY2Uua2V5KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuQVVESU86XHJcbiAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcnMuZGVsZXRlKHJlc291cmNlLmtleSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLkpTT046XHJcbiAgICAgICAgdGhpcy5qc29uT2JqZWN0cy5kZWxldGUocmVzb3VyY2Uua2V5KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgLypjYXNlIFJlc291cmNlVHlwZS5TSEFERVI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdsX1NoYWRlclByb2dyYW1zLmdldChyZXNvdXJjZS5rZXkpLmRlbGV0ZSh0aGlzLmdsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuZGVsZXRlKHJlc291cmNlLmtleSk7XHJcbiAgICAgICAgICAgICAgICBicmVhazsqL1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlbGV0ZSBhbnkgZGVwZW5kZW5jaWVzXHJcbiAgICBmb3IgKGxldCBkZXBlbmRlbmN5IG9mIHJlc291cmNlLmRlcGVuZGVuY2llcykge1xyXG4gICAgICB0aGlzLnVubG9hZFJlc291cmNlKGRlcGVuZGVuY3kpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBXT1JLIEZVTkNUSU9OUyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cclxuICAvKipcclxuICAgKiBMb2FkcyBhbGwgdGlsZW1hcHMgY3VycmVudGx5IGluIHRoZSB0aWxlbWFwIGxvYWRpbmcgcXVldWVcclxuICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gbG9hZGluZyBpcyBjb21wbGV0ZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgbG9hZFRpbGVtYXBzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWQgPSB0aGlzLmxvYWRvbmx5X3RpbGVtYXBMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xyXG4gICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9IDA7XHJcblxyXG4gICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcclxuICAgIGlmICh0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkID09PSAwKSB7XHJcbiAgICAgIG9uRmluaXNoTG9hZGluZygpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKSB7XHJcbiAgICAgIGxldCB0aWxlbWFwID0gdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgdGhpcy5sb2FkVGlsZW1hcCh0aWxlbWFwLmtleSwgdGlsZW1hcC5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZHMgYSBzaW5ndWxhciB0aWxlbWFwXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSB0aWxlbWFwXHJcbiAgICogQHBhcmFtIHBhdGhUb1RpbGVtYXBKU09OIFRoZSBwYXRoIHRvIHRoZSB0aWxlbWFwIEpTT04gZmlsZVxyXG4gICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHRpbGVtYXAgdG8gbG9hZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgbG9hZFRpbGVtYXAoXHJcbiAgICBrZXk6IHN0cmluZyxcclxuICAgIHBhdGhUb1RpbGVtYXBKU09OOiBzdHJpbmcsXHJcbiAgICBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24sXHJcbiAgKTogdm9pZCB7XHJcbiAgICB0aGlzLmxvYWRUZXh0RmlsZShwYXRoVG9UaWxlbWFwSlNPTiwgKGZpbGVUZXh0OiBzdHJpbmcpID0+IHtcclxuICAgICAgbGV0IHRpbGVtYXBPYmplY3QgPSA8VGlsZWRUaWxlbWFwRGF0YT5KU09OLnBhcnNlKGZpbGVUZXh0KTtcclxuXHJcbiAgICAgIC8vIFdlIGNhbiBwYXJzZSB0aGUgb2JqZWN0IGxhdGVyIC0gaXQncyBtdWNoIGZhc3RlciB0aGFuIGxvYWRpbmdcclxuICAgICAgdGhpcy50aWxlbWFwcy5hZGQoa2V5LCB0aWxlbWFwT2JqZWN0KTtcclxuICAgICAgbGV0IHJlc291cmNlID0gbmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLlRJTEVNQVApO1xyXG5cclxuICAgICAgLy8gR3JhYiB0aGUgdGlsZXNldCBpbWFnZXMgd2UgbmVlZCB0byBsb2FkIGFuZCBhZGQgdGhlbSB0byB0aGUgaW1hZ2Vsb2FkaW5nIHF1ZXVlXHJcbiAgICAgIGZvciAobGV0IHRpbGVzZXQgb2YgdGlsZW1hcE9iamVjdC50aWxlc2V0cykge1xyXG4gICAgICAgIGlmICh0aWxlc2V0LmltYWdlKSB7XHJcbiAgICAgICAgICBsZXQga2V5ID0gdGlsZXNldC5pbWFnZTtcclxuICAgICAgICAgIGxldCBwYXRoID0gU3RyaW5nVXRpbHMuZ2V0UGF0aEZyb21GaWxlUGF0aChwYXRoVG9UaWxlbWFwSlNPTikgKyBrZXk7XHJcbiAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe1xyXG4gICAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgICAgaXNEZXBlbmRlbmN5OiB0cnVlLFxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHRoaXMgaW1hZ2UgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSB0aWxlbWFwXHJcbiAgICAgICAgICByZXNvdXJjZS5hZGREZXBlbmRlbmN5KFxyXG4gICAgICAgICAgICBuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRpbGVzZXQudGlsZXMpIHtcclxuICAgICAgICAgIGZvciAobGV0IHRpbGUgb2YgdGlsZXNldC50aWxlcykge1xyXG4gICAgICAgICAgICBsZXQga2V5ID0gdGlsZS5pbWFnZTtcclxuICAgICAgICAgICAgbGV0IHBhdGggPSBTdHJpbmdVdGlscy5nZXRQYXRoRnJvbUZpbGVQYXRoKHBhdGhUb1RpbGVtYXBKU09OKSArIGtleTtcclxuICAgICAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtcclxuICAgICAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxyXG4gICAgICAgICAgICAgIGlzRGVwZW5kZW5jeTogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhpcyBpbWFnZSBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRpbGVtYXBcclxuICAgICAgICAgICAgcmVzb3VyY2UuYWRkRGVwZW5kZW5jeShcclxuICAgICAgICAgICAgICBuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRkIHRoZSByZXNvdXJjZSByZWZlcmVuY2UgdG8gdGhlIGxpc3Qgb2YgcmVzb3VyY2UgdG8gdW5sb2FkXHJcbiAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChyZXNvdXJjZSk7XHJcblxyXG4gICAgICAvLyBGaW5pc2ggbG9hZGluZ1xyXG4gICAgICB0aGlzLmZpbmlzaExvYWRpbmdUaWxlbWFwKGNhbGxiYWNrSWZMYXN0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluaXNoIGxvYWRpbmcgYSB0aWxlbWFwLiBDYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaWYgdGhpcyBpcyB0aGUgbGFzdCB0aWxlbWFwIGJlaW5nIGxvYWRlZFxyXG4gICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHRpbGVtYXAgdG8gbG9hZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgZmluaXNoTG9hZGluZ1RpbGVtYXAoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkICs9IDE7XHJcblxyXG4gICAgaWYgKHRoaXMubG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWQpIHtcclxuICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHRpbGVtYXBzXHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkcyBhbGwgc3ByaXRlc2hlZXRzIGN1cnJlbnRseSBpbiB0aGUgc3ByaXRlc2hlZXQgbG9hZGluZyBxdWV1ZVxyXG4gICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgc3ByaXRlc2hlZXRzIGFyZSBkb25lIGxvYWRpbmdcclxuICAgKi9cclxuICBwcml2YXRlIGxvYWRTcHJpdGVzaGVldHNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPVxyXG4gICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcclxuICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkID0gMDtcclxuXHJcbiAgICAvLyBJZiBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxyXG4gICAgaWYgKHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkID09PSAwKSB7XHJcbiAgICAgIG9uRmluaXNoTG9hZGluZygpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUuaGFzSXRlbXMoKSkge1xyXG4gICAgICBsZXQgc3ByaXRlc2hlZXQgPSB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgdGhpcy5sb2FkU3ByaXRlc2hlZXQoc3ByaXRlc2hlZXQua2V5LCBzcHJpdGVzaGVldC5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZHMgYSBzaW5ndWxhciBzcHJpdGVzaGVldFxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgc3ByaXRlc2hlZXQgdG8gbG9hZFxyXG4gICAqIEBwYXJhbSBwYXRoVG9TcHJpdGVzaGVldEpTT04gVGhlIHBhdGggdG8gdGhlIHNwcml0ZXNoZWV0IEpTT04gZmlsZVxyXG4gICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHNwcml0ZXNoZWV0XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBsb2FkU3ByaXRlc2hlZXQoXHJcbiAgICBrZXk6IHN0cmluZyxcclxuICAgIHBhdGhUb1Nwcml0ZXNoZWV0SlNPTjogc3RyaW5nLFxyXG4gICAgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uLFxyXG4gICk6IHZvaWQge1xyXG4gICAgdGhpcy5sb2FkVGV4dEZpbGUocGF0aFRvU3ByaXRlc2hlZXRKU09OLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xyXG4gICAgICBsZXQgc3ByaXRlc2hlZXQgPSA8U3ByaXRlc2hlZXQ+SlNPTi5wYXJzZShmaWxlVGV4dCk7XHJcblxyXG4gICAgICAvLyBXZSBjYW4gcGFyc2UgdGhlIG9iamVjdCBsYXRlciAtIGl0J3MgbXVjaCBmYXN0ZXIgdGhhbiBsb2FkaW5nXHJcbiAgICAgIHRoaXMuc3ByaXRlc2hlZXRzLmFkZChrZXksIHNwcml0ZXNoZWV0KTtcclxuXHJcbiAgICAgIGxldCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5TUFJJVEVTSEVFVCk7XHJcblxyXG4gICAgICAvLyBHcmFiIHRoZSBpbWFnZSB3ZSBuZWVkIHRvIGxvYWQgYW5kIGFkZCBpdCB0byB0aGUgaW1hZ2Vsb2FkaW5nIHF1ZXVlXHJcbiAgICAgIGxldCBwYXRoID1cclxuICAgICAgICBTdHJpbmdVdGlscy5nZXRQYXRoRnJvbUZpbGVQYXRoKHBhdGhUb1Nwcml0ZXNoZWV0SlNPTikgK1xyXG4gICAgICAgIHNwcml0ZXNoZWV0LnNwcml0ZVNoZWV0SW1hZ2U7XHJcbiAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7XHJcbiAgICAgICAga2V5OiBzcHJpdGVzaGVldC5uYW1lLFxyXG4gICAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgICAgaXNEZXBlbmRlbmN5OiB0cnVlLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJlc291cmNlLmFkZERlcGVuZGVuY3koXHJcbiAgICAgICAgbmV3IFJlc291cmNlUmVmZXJlbmNlKHNwcml0ZXNoZWV0Lm5hbWUsIFJlc291cmNlVHlwZS5JTUFHRSksXHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChyZXNvdXJjZSk7XHJcblxyXG4gICAgICAvLyBGaW5pc2ggbG9hZGluZ1xyXG4gICAgICB0aGlzLmZpbmlzaExvYWRpbmdTcHJpdGVzaGVldChjYWxsYmFja0lmTGFzdCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmlzaCBsb2FkaW5nIGEgc3ByaXRlc2hlZXQuIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpZiB0aGlzIGlzIHRoZSBsYXN0IHNwcml0ZXNoZWV0IGJlaW5nIGxvYWRlZFxyXG4gICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHNwcml0ZXNoZWV0IHRvIGxvYWRcclxuICAgKi9cclxuICBwcml2YXRlIGZpbmlzaExvYWRpbmdTcHJpdGVzaGVldChjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkICs9IDE7XHJcblxyXG4gICAgaWYgKHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZCkge1xyXG4gICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgc3ByaXRlc2hlZXRzXHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkcyBhbGwgaW1hZ2VzIGN1cnJlbnRseSBpbiB0aGUgaW1hZ2UgbG9hZGluZyBxdWV1ZVxyXG4gICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBpbWFnZXMgdG8gbG9hZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgbG9hZEltYWdlc0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xyXG4gICAgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgPSAwO1xyXG5cclxuICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXHJcbiAgICBpZiAodGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQgPT09IDApIHtcclxuICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAodGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKSB7XHJcbiAgICAgIGxldCBpbWFnZSA9IHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xyXG4gICAgICB0aGlzLmxvYWRJbWFnZShcclxuICAgICAgICBpbWFnZS5rZXksXHJcbiAgICAgICAgaW1hZ2UucGF0aCxcclxuICAgICAgICBpbWFnZS5pc0RlcGVuZGVuY3ksXHJcbiAgICAgICAgb25GaW5pc2hMb2FkaW5nLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZHMgYSBzaW5ndWxhciBpbWFnZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdG8gbG9hZFxyXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBpbWFnZSB0byBsb2FkXHJcbiAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgaW1hZ2VcclxuICAgKi9cclxuICBwdWJsaWMgbG9hZEltYWdlKFxyXG4gICAga2V5OiBzdHJpbmcsXHJcbiAgICBwYXRoOiBzdHJpbmcsXHJcbiAgICBpc0RlcGVuZGVuY3k6IGJvb2xlYW4sXHJcbiAgICBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24sXHJcbiAgKTogdm9pZCB7XHJcbiAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgIC8vIEFkZCB0byBsb2FkZWQgaW1hZ2VzXHJcbiAgICAgIHRoaXMuaW1hZ2VzLmFkZChrZXksIGltYWdlKTtcclxuXHJcbiAgICAgIC8vIElmIG5vdCBhIGRlcGVuZGVuY3ksIHB1c2ggaXQgdG8gdGhlIHVubG9hZCBsaXN0LiBPdGhlcndpc2UgaXQncyBtYW5hZ2VkIGJ5IHNvbWV0aGluZyBlbHNlXHJcbiAgICAgIGlmICghaXNEZXBlbmRlbmN5KSB7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKFxyXG4gICAgICAgICAgbmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKSxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiBXZWJHTCBpcyBhY3RpdmUsIGNyZWF0ZSBhIHRleHR1cmVcclxuICAgICAgaWYgKHRoaXMuZ2xfV2ViR0xBY3RpdmUpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZVdlYkdMVGV4dHVyZShrZXksIGltYWdlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmluaXNoIGltYWdlIGxvYWRcclxuICAgICAgdGhpcy5maW5pc2hMb2FkaW5nSW1hZ2UoY2FsbGJhY2tJZkxhc3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpbWFnZS5zcmMgPSBwYXRoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluaXNoIGxvYWRpbmcgYW4gaW1hZ2UuIElmIHRoaXMgaXMgdGhlIGxhc3QgaW1hZ2UsIGl0IGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGltYWdlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nSW1hZ2UoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZCArPSAxO1xyXG5cclxuICAgIGlmICh0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQpIHtcclxuICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIGltYWdlc1xyXG4gICAgICBjYWxsYmFjaygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZHMgYWxsIGF1ZGlvIGN1cnJlbnRseSBpbiB0aGUgdGlsZW1hcCBsb2FkaW5nIHF1ZXVlXHJcbiAgICogQHBhcmFtIG9uRmluaXNoTG9hZGluZyBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRpbGVtYXBzIGFyZSBkb25lIGxvYWRpbmdcclxuICAgKi9cclxuICBwcml2YXRlIGxvYWRBdWRpb0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKSB7XHJcbiAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XHJcbiAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkID0gMDtcclxuXHJcbiAgICAvLyBJZiBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxyXG4gICAgaWYgKHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQgPT09IDApIHtcclxuICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAodGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKSB7XHJcbiAgICAgIGxldCBhdWRpbyA9IHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xyXG4gICAgICB0aGlzLmxvYWRBdWRpbyhhdWRpby5rZXksIGF1ZGlvLnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIGEgc2luZ3VsYXIgYXVkaW8gZmlsZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXHJcbiAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxyXG4gICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGF1ZGlvIGZpbGUgdG8gbG9hZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgbG9hZEF1ZGlvKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgbGV0IGF1ZGlvQ3R4ID0gQXVkaW9NYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0QXVkaW9Db250ZXh0KCk7XHJcblxyXG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCBwYXRoLCB0cnVlKTtcclxuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG5cclxuICAgIHJlcXVlc3Qub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICBhdWRpb0N0eC5kZWNvZGVBdWRpb0RhdGEoXHJcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZSxcclxuICAgICAgICBidWZmZXIgPT4ge1xyXG4gICAgICAgICAgLy8gQWRkIHRvIGxpc3Qgb2YgYXVkaW8gYnVmZmVyc1xyXG4gICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcnMuYWRkKGtleSwgYnVmZmVyKTtcclxuICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChcclxuICAgICAgICAgICAgbmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLkFVRElPKSxcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmcgc291bmRcclxuICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ0F1ZGlvKGNhbGxiYWNrSWZMYXN0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yID0+IHtcclxuICAgICAgICAgIHRocm93IFwiRXJyb3IgbG9hZGluZyBzb3VuZFwiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICk7XHJcbiAgICB9O1xyXG4gICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5pc2ggbG9hZGluZyBhbiBhdWRpbyBmaWxlLiBDYWxscyB0aGUgY2FsbGJhY2sgZnVuY3RvbiBpZiB0aGlzIGlzIHRoZSBsYXN0IGF1ZGlvIHNhbXBsZSBiZWluZyBsb2FkZWQuXHJcbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgYXVkaW8gZmlsZSB0byBsb2FkXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nQXVkaW8oY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkICs9IDE7XHJcblxyXG4gICAgaWYgKHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQpIHtcclxuICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIGF1ZGlvXHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkcyBhbGwgb2JqZWN0cyBjdXJyZW50bHkgaW4gdGhlIG9iamVjdCBsb2FkaW5nIHF1ZXVlXHJcbiAgICogQHBhcmFtIG9uRmluaXNoTG9hZGluZyBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIG9iamVjdHMgdG8gbG9hZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgbG9hZE9iamVjdHNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgdGhpcy5sb2Fkb25seV9qc29uVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcclxuICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRlZCA9IDA7XHJcblxyXG4gICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcclxuICAgIGlmICh0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQgPT09IDApIHtcclxuICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAodGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpIHtcclxuICAgICAgbGV0IG9iaiA9IHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XHJcbiAgICAgIHRoaXMubG9hZE9iamVjdChvYmoua2V5LCBvYmoucGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWRzIGEgc2luZ3VsYXIgb2JqZWN0XHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBvYmplY3QgdG8gbG9hZFxyXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBvYmplY3QgdG8gbG9hZFxyXG4gICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IG9iamVjdFxyXG4gICAqL1xyXG4gIHB1YmxpYyBsb2FkT2JqZWN0KGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgdGhpcy5sb2FkVGV4dEZpbGUocGF0aCwgKGZpbGVUZXh0OiBzdHJpbmcpID0+IHtcclxuICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2UoZmlsZVRleHQpO1xyXG4gICAgICB0aGlzLmpzb25PYmplY3RzLmFkZChrZXksIG9iaik7XHJcblxyXG4gICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2goXHJcbiAgICAgICAgbmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLkpTT04pLFxyXG4gICAgICApO1xyXG5cclxuICAgICAgdGhpcy5maW5pc2hMb2FkaW5nT2JqZWN0KGNhbGxiYWNrSWZMYXN0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluaXNoIGxvYWRpbmcgYW4gb2JqZWN0LiBJZiB0aGlzIGlzIHRoZSBsYXN0IG9iamVjdCwgaXQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgb2JqZWN0XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nT2JqZWN0KGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkICs9IDE7XHJcblxyXG4gICAgaWYgKHRoaXMubG9hZG9ubHlfanNvbkxvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV9qc29uVG9Mb2FkKSB7XHJcbiAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyBvYmplY3RzXHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiAjIyMjIyMjIyMjIFdFQkdMIFNQRUNJRklDIEZVTkNUSU9OUyAjIyMjIyMjIyMjICovXHJcblxyXG4gIHB1YmxpYyBnZXRUZXh0dXJlKGtleTogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmdsX1RleHR1cmVzLmdldChrZXkpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldFNoYWRlclByb2dyYW0oa2V5OiBzdHJpbmcpOiBXZWJHTFByb2dyYW0ge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuZ2V0KGtleSkucHJvZ3JhbTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXRCdWZmZXIoa2V5OiBzdHJpbmcpOiBXZWJHTEJ1ZmZlciB7XHJcbiAgICByZXR1cm4gdGhpcy5nbF9CdWZmZXJzLmdldChrZXkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVXZWJHTFRleHR1cmUoaW1hZ2VLZXk6IHN0cmluZywgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQpOiB2b2lkIHtcclxuICAgIC8vIEdldCB0aGUgdGV4dHVyZSBJRFxyXG4gICAgY29uc3QgdGV4dHVyZUlEID0gdGhpcy5nZXRUZXh0dXJlSUQodGhpcy5nbF9OZXh0VGV4dHVyZUlEKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIHRleHR1cmVcclxuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcbiAgICAvLyBTZXQgdXAgdGhlIHRleHR1cmVcclxuICAgIC8vIEVuYWJsZSB0ZXh0dXJlMFxyXG4gICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRleHR1cmVJRCk7XHJcblxyXG4gICAgLy8gQmluZCBvdXIgdGV4dHVyZSB0byB0ZXh0dXJlIDBcclxuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuXHJcbiAgICAvLyBTZXQgdGhlIHRleHR1cmUgcGFyYW1ldGVyc1xyXG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKFxyXG4gICAgICB0aGlzLmdsLlRFWFRVUkVfMkQsXHJcbiAgICAgIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLFxyXG4gICAgICB0aGlzLmdsLkxJTkVBUixcclxuICAgICk7XHJcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkoXHJcbiAgICAgIHRoaXMuZ2wuVEVYVFVSRV8yRCxcclxuICAgICAgdGhpcy5nbC5URVhUVVJFX1dSQVBfUyxcclxuICAgICAgdGhpcy5nbC5DTEFNUF9UT19FREdFLFxyXG4gICAgKTtcclxuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaShcclxuICAgICAgdGhpcy5nbC5URVhUVVJFXzJELFxyXG4gICAgICB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULFxyXG4gICAgICB0aGlzLmdsLkNMQU1QX1RPX0VER0UsXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFNldCB0aGUgdGV4dHVyZSBpbWFnZVxyXG4gICAgdGhpcy5nbC50ZXhJbWFnZTJEKFxyXG4gICAgICB0aGlzLmdsLlRFWFRVUkVfMkQsXHJcbiAgICAgIDAsXHJcbiAgICAgIHRoaXMuZ2wuUkdCQSxcclxuICAgICAgdGhpcy5nbC5SR0JBLFxyXG4gICAgICB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsXHJcbiAgICAgIGltYWdlLFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBBZGQgdGhlIHRleHR1cmUgdG8gb3VyIG1hcCB3aXRoIHRoZSBzYW1lIGtleSBhcyB0aGUgaW1hZ2VcclxuICAgIHRoaXMuZ2xfVGV4dHVyZXMuYWRkKGltYWdlS2V5LCB0aGlzLmdsX05leHRUZXh0dXJlSUQpO1xyXG5cclxuICAgIC8vIEluY3JlbWVudCB0aGUga2V5XHJcbiAgICB0aGlzLmdsX05leHRUZXh0dXJlSUQgKz0gMTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0VGV4dHVyZUlEKGlkOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgLy8gU3RhcnQgd2l0aCA5IGNhc2VzIC0gdGhpcyBjYW4gYmUgZXhwYW5kZWQgaWYgbmVlZGVkLCBidXQgZm9yIHRoZSBiZXN0IHBlcmZvcm1hbmNlLFxyXG4gICAgLy8gVGV4dHVyZXMgc2hvdWxkIGJlIHN0aXRjaGVkIGludG8gYW4gYXRsYXNcclxuICAgIHN3aXRjaCAoaWQpIHtcclxuICAgICAgY2FzZSAwOlxyXG4gICAgICAgIHJldHVybiB0aGlzLmdsLlRFWFRVUkUwO1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTE7XHJcbiAgICAgIGNhc2UgMjpcclxuICAgICAgICByZXR1cm4gdGhpcy5nbC5URVhUVVJFMjtcclxuICAgICAgY2FzZSAzOlxyXG4gICAgICAgIHJldHVybiB0aGlzLmdsLlRFWFRVUkUzO1xyXG4gICAgICBjYXNlIDQ6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTQ7XHJcbiAgICAgIGNhc2UgNTpcclxuICAgICAgICByZXR1cm4gdGhpcy5nbC5URVhUVVJFNTtcclxuICAgICAgY2FzZSA2OlxyXG4gICAgICAgIHJldHVybiB0aGlzLmdsLlRFWFRVUkU2O1xyXG4gICAgICBjYXNlIDc6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTc7XHJcbiAgICAgIGNhc2UgODpcclxuICAgICAgICByZXR1cm4gdGhpcy5nbC5URVhUVVJFODtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gdGhpcy5nbC5URVhUVVJFOTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBjcmVhdGVCdWZmZXIoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmdsX1dlYkdMQWN0aXZlKSB7XHJcbiAgICAgIGxldCBidWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuICAgICAgdGhpcy5nbF9CdWZmZXJzLmFkZChrZXksIGJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbnF1ZXVlcyBsb2FkaW5nIG9mIGEgbmV3IHNoYWRlciBwcm9ncmFtXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzaGFkZXIgcHJvZ3JhbVxyXG4gICAqIEBwYXJhbSB2U2hhZGVyRmlsZXBhdGhcclxuICAgKiBAcGFyYW0gZlNoYWRlckZpbGVwYXRoXHJcbiAgICovXHJcbiAgcHVibGljIHNoYWRlcihcclxuICAgIGtleTogc3RyaW5nLFxyXG4gICAgdlNoYWRlckZpbGVwYXRoOiBzdHJpbmcsXHJcbiAgICBmU2hhZGVyRmlsZXBhdGg6IHN0cmluZyxcclxuICApOiB2b2lkIHtcclxuICAgIGxldCBzcGxpdFBhdGggPSB2U2hhZGVyRmlsZXBhdGguc3BsaXQoXCIuXCIpO1xyXG4gICAgbGV0IGVuZCA9IHNwbGl0UGF0aFtzcGxpdFBhdGgubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgaWYgKGVuZCAhPT0gXCJ2c2hhZGVyXCIpIHtcclxuICAgICAgdGhyb3cgYCR7dlNoYWRlckZpbGVwYXRofSBpcyBub3QgYSB2YWxpZCB2ZXJ0ZXggc2hhZGVyIC0gbXVzdCBlbmQgaW4gXCIudnNoYWRlcmA7XHJcbiAgICB9XHJcblxyXG4gICAgc3BsaXRQYXRoID0gZlNoYWRlckZpbGVwYXRoLnNwbGl0KFwiLlwiKTtcclxuICAgIGVuZCA9IHNwbGl0UGF0aFtzcGxpdFBhdGgubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgaWYgKGVuZCAhPT0gXCJmc2hhZGVyXCIpIHtcclxuICAgICAgdGhyb3cgYCR7ZlNoYWRlckZpbGVwYXRofSBpcyBub3QgYSB2YWxpZCB2ZXJ0ZXggc2hhZGVyIC0gbXVzdCBlbmQgaW4gXCIuZnNoYWRlcmA7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHBhdGhzID0gbmV3IEtleVBhdGhfU2hhZGVyKCk7XHJcbiAgICBwYXRocy5rZXkgPSBrZXk7XHJcbiAgICBwYXRocy52cGF0aCA9IHZTaGFkZXJGaWxlcGF0aDtcclxuICAgIHBhdGhzLmZwYXRoID0gZlNoYWRlckZpbGVwYXRoO1xyXG5cclxuICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlLmVucXVldWUocGF0aHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBrZWVwU2hhZGVyKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdsX0xvYWRTaGFkZXJzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPVxyXG4gICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XHJcbiAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zTG9hZGVkID0gMDtcclxuXHJcbiAgICAvLyBJZiB3ZWJHTCBpc24nYWN0aXZlIG9yIHRoZXJlIGFyZSBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxyXG4gICAgaWYgKCF0aGlzLmdsX1dlYkdMQWN0aXZlIHx8IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPT09IDApIHtcclxuICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAodGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuaGFzSXRlbXMoKSkge1xyXG4gICAgICBsZXQgc2hhZGVyID0gdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xyXG4gICAgICB0aGlzLmdsX0xvYWRTaGFkZXIoXHJcbiAgICAgICAgc2hhZGVyLmtleSxcclxuICAgICAgICBzaGFkZXIudnBhdGgsXHJcbiAgICAgICAgc2hhZGVyLmZwYXRoLFxyXG4gICAgICAgIG9uRmluaXNoTG9hZGluZyxcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2xfTG9hZFNoYWRlcihcclxuICAgIGtleTogc3RyaW5nLFxyXG4gICAgdnBhdGg6IHN0cmluZyxcclxuICAgIGZwYXRoOiBzdHJpbmcsXHJcbiAgICBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24sXHJcbiAgKTogdm9pZCB7XHJcbiAgICB0aGlzLmxvYWRUZXh0RmlsZSh2cGF0aCwgKHZGaWxlVGV4dDogc3RyaW5nKSA9PiB7XHJcbiAgICAgIGNvbnN0IHZTaGFkZXIgPSB2RmlsZVRleHQ7XHJcblxyXG4gICAgICB0aGlzLmxvYWRUZXh0RmlsZShmcGF0aCwgKGZGaWxlVGV4dDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZlNoYWRlciA9IGZGaWxlVGV4dDtcclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgcHJvZ3JhbSBhbmQgc2hhZGVyc1xyXG4gICAgICAgIGNvbnN0IFtzaGFkZXJQcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSA9XHJcbiAgICAgICAgICB0aGlzLmNyZWF0ZVNoYWRlclByb2dyYW0odlNoYWRlciwgZlNoYWRlcik7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZXIgdHlwZVxyXG4gICAgICAgIGNvbnN0IHByb2dyYW1XcmFwcGVyID0gbmV3IFdlYkdMUHJvZ3JhbVR5cGUoKTtcclxuICAgICAgICBwcm9ncmFtV3JhcHBlci5wcm9ncmFtID0gc2hhZGVyUHJvZ3JhbTtcclxuICAgICAgICBwcm9ncmFtV3JhcHBlci52ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXI7XHJcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIuZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlcjtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRvIG91ciBtYXBcclxuICAgICAgICB0aGlzLmdsX1NoYWRlclByb2dyYW1zLmFkZChrZXksIHByb2dyYW1XcmFwcGVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKFxyXG4gICAgICAgICAgbmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLlNIQURFUiksXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gRmluaXNoIGxvYWRpbmdcclxuICAgICAgICB0aGlzLmdsX0ZpbmlzaExvYWRpbmdTaGFkZXIoY2FsbGJhY2tJZkxhc3QpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnbF9GaW5pc2hMb2FkaW5nU2hhZGVyKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCArPSAxO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCA9PT1cclxuICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc1RvTG9hZFxyXG4gICAgKSB7XHJcbiAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyBzaGFkZXJzXHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZVNoYWRlclByb2dyYW0odlNoYWRlclNvdXJjZTogc3RyaW5nLCBmU2hhZGVyU291cmNlOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IHRoaXMubG9hZFZlcnRleFNoYWRlcih2U2hhZGVyU291cmNlKTtcclxuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5sb2FkRnJhZ21lbnRTaGFkZXIoZlNoYWRlclNvdXJjZSk7XHJcblxyXG4gICAgaWYgKHZlcnRleFNoYWRlciA9PT0gbnVsbCB8fCBmcmFnbWVudFNoYWRlciA9PT0gbnVsbCkge1xyXG4gICAgICAvLyBXZSBoYWQgYSBwcm9ibGVtIGludGlhbGl6aW5nIC0gZXJyb3JcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgc2hhZGVyIHByb2dyYW1cclxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgIGlmICghcHJvZ3JhbSkge1xyXG4gICAgICAvLyBFcnJvciBjcmVhdGluZ1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY3JlYXRlIHByb2dyYW1cIik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEF0dGFjaCBvdXIgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJcclxuICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XHJcbiAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XHJcblxyXG4gICAgLy8gTGlua1xyXG4gICAgdGhpcy5nbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgIGlmICghdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIHRoaXMuZ2wuTElOS19TVEFUVVMpKSB7XHJcbiAgICAgIC8vIEVycm9yIGxpbmtpbmdcclxuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gbGluayBwcm9ncmFtOiBcIiArIGVycm9yKTtcclxuXHJcbiAgICAgIC8vIENsZWFuIHVwXHJcbiAgICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgdGhpcy5nbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcclxuICAgICAgdGhpcy5nbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBXZSBzdWNjZXNzZnVsbHkgY3JlYXRlIGEgcHJvZ3JhbVxyXG4gICAgcmV0dXJuIFtwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgbG9hZFZlcnRleFNoYWRlcihzaGFkZXJTb3VyY2U6IHN0cmluZyk6IFdlYkdMU2hhZGVyIHtcclxuICAgIC8vIENyZWF0ZSBhIG5ldyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICByZXR1cm4gdGhpcy5sb2FkU2hhZGVyKHRoaXMuZ2wuVkVSVEVYX1NIQURFUiwgc2hhZGVyU291cmNlKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgbG9hZEZyYWdtZW50U2hhZGVyKHNoYWRlclNvdXJjZTogc3RyaW5nKTogV2ViR0xTaGFkZXIge1xyXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGZyYWdtZW50IHNoYWRlclxyXG4gICAgcmV0dXJuIHRoaXMubG9hZFNoYWRlcih0aGlzLmdsLkZSQUdNRU5UX1NIQURFUiwgc2hhZGVyU291cmNlKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgbG9hZFNoYWRlcih0eXBlOiBudW1iZXIsIHNoYWRlclNvdXJjZTogc3RyaW5nKTogV2ViR0xTaGFkZXIge1xyXG4gICAgY29uc3Qgc2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcblxyXG4gICAgLy8gSWYgd2UgY291bGRuJ3QgY3JlYXRlIHRoZSBzaGFkZXIsIGVycm9yXHJcbiAgICBpZiAoc2hhZGVyID09PSBudWxsKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcIlVuYWJsZSB0byBjcmVhdGUgc2hhZGVyXCIpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGhlIHNvdXJjZSB0byB0aGUgc2hhZGVyIGFuZCBjb21waWxlXHJcbiAgICB0aGlzLmdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XHJcbiAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgd2VyZSBubyBlcnJvcnMgZHVyaW5nIHRoaXMgcHJvY2Vzc1xyXG4gICAgaWYgKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKSB7XHJcbiAgICAgIC8vIE5vdCBjb21waWxlZCAtIGVycm9yXHJcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XHJcbiAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjb21waWxlIHNoYWRlcjogXCIgKyBlcnJvcik7XHJcblxyXG4gICAgICAvLyBDbGVhbiB1cFxyXG4gICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdWNlc3MsIHNvIHJldHVybiB0aGUgc2hhZGVyXHJcbiAgICByZXR1cm4gc2hhZGVyO1xyXG4gIH1cclxuXHJcbiAgLyogIyMjIyMjIyMjIyBHRU5FUkFMIExPQURJTkcgRlVOQ1RJT05TICMjIyMjIyMjIyMgKi9cclxuXHJcbiAgcHJpdmF0ZSBsb2FkVGV4dEZpbGUodGV4dEZpbGVQYXRoOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgbGV0IHhvYmo6IFhNTEh0dHBSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICB4b2JqLm92ZXJyaWRlTWltZVR5cGUoXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xyXG4gICAgeG9iai5vcGVuKFwiR0VUXCIsIHRleHRGaWxlUGF0aCwgdHJ1ZSk7XHJcbiAgICB4b2JqLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHhvYmoucmVhZHlTdGF0ZSA9PSA0ICYmIHhvYmouc3RhdHVzID09IDIwMCkge1xyXG4gICAgICAgIGNhbGxiYWNrKHhvYmoucmVzcG9uc2VUZXh0KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHhvYmouc2VuZChudWxsKTtcclxuICB9XHJcblxyXG4gIC8qICMjIyMjIyMjIyMgTE9BRElORyBCQVIgSU5GTyAjIyMjIyMjIyMjICovXHJcblxyXG4gIHByaXZhdGUgZ2V0TG9hZFBlcmNlbnQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICh0aGlzLmxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkIC8gdGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCArXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgLyB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZCArXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgLyB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCArXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCAvIHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQpIC9cclxuICAgICAgdGhpcy5sb2Fkb25seV90eXBlc1RvTG9hZFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMubG9hZGluZykge1xyXG4gICAgICBpZiAodGhpcy5vbkxvYWRQcm9ncmVzcykge1xyXG4gICAgICAgIHRoaXMub25Mb2FkUHJvZ3Jlc3ModGhpcy5nZXRMb2FkUGVyY2VudCgpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLmp1c3RMb2FkZWQpIHtcclxuICAgICAgdGhpcy5qdXN0TG9hZGVkID0gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLm9uTG9hZENvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5vbkxvYWRDb21wbGV0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSByZWZlcmVuY2UgdG8gYSByZXNvdXJjZS5cclxuICogVGhpcyBpcyB1c2VkIGZvciB0aGUgZXhlbXB0aW9uIGxpc3QgdG8gYXNzdXJlIGFzc2V0cyBhbmQgdGhlaXIgZGVwZW5kZW5jaWVzIGRvbid0IGdldFxyXG4gKiBkZXN0cm95ZWQgaWYgdGhleSBhcmUgc3RpbGwgbmVlZGVkLlxyXG4gKi9cclxuY2xhc3MgUmVzb3VyY2VSZWZlcmVuY2Uge1xyXG4gIGtleTogc3RyaW5nO1xyXG4gIHJlc291cmNlVHlwZTogUmVzb3VyY2VUeXBlO1xyXG4gIGRlcGVuZGVuY2llczogQXJyYXk8UmVzb3VyY2VSZWZlcmVuY2U+O1xyXG5cclxuICBjb25zdHJ1Y3RvcihrZXk6IHN0cmluZywgcmVzb3VyY2VUeXBlOiBSZXNvdXJjZVR5cGUpIHtcclxuICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgdGhpcy5yZXNvdXJjZVR5cGUgPSByZXNvdXJjZVR5cGU7XHJcbiAgICB0aGlzLmRlcGVuZGVuY2llcyA9IG5ldyBBcnJheSgpO1xyXG4gIH1cclxuXHJcbiAgYWRkRGVwZW5kZW5jeShyZXNvdXJjZTogUmVzb3VyY2VSZWZlcmVuY2UpOiB2b2lkIHtcclxuICAgIHRoaXMuZGVwZW5kZW5jaWVzLnB1c2gocmVzb3VyY2UpO1xyXG4gIH1cclxufVxyXG5cclxuZW51bSBSZXNvdXJjZVR5cGUge1xyXG4gIElNQUdFID0gXCJJTUFHRVwiLFxyXG4gIFRJTEVNQVAgPSBcIlRJTEVNQVBcIixcclxuICBTUFJJVEVTSEVFVCA9IFwiU1BSSVRFU0hFRVRcIixcclxuICBBVURJTyA9IFwiQVVESU9cIixcclxuICBKU09OID0gXCJKU09OXCIsXHJcbiAgU0hBREVSID0gXCJTSEFERVJcIixcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgcGFpciByZXByZXNlbnRpbmcgYSBrZXkgYW5kIHRoZSBwYXRoIG9mIHRoZSByZXNvdXJjZSB0byBsb2FkXHJcbiAqL1xyXG5jbGFzcyBLZXlQYXRoUGFpciB7XHJcbiAga2V5OiBzdHJpbmc7XHJcbiAgcGF0aDogc3RyaW5nO1xyXG4gIGlzRGVwZW5kZW5jeT86IGJvb2xlYW4gPSBmYWxzZTtcclxufVxyXG5cclxuY2xhc3MgS2V5UGF0aF9TaGFkZXIge1xyXG4gIGtleTogc3RyaW5nO1xyXG4gIHZwYXRoOiBzdHJpbmc7XHJcbiAgZnBhdGg6IHN0cmluZztcclxufVxyXG4iLCJpbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4vVmlld3BvcnRcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcblxyXG4vKipcclxuICogQW4gYWJzdHJhY3QgaW50ZXJmYWNlIG9mIGEgU2NlbmVHcmFwaC5cclxuICogRXhwb3NlcyBtZXRob2RzIGZvciB1c2UgYnkgb3RoZXIgY29kZSwgYnV0IGxlYXZlcyB0aGUgaW1wbGVtZW50YXRpb24gdXAgdG8gdGhlIHN1YmNsYXNzZXMuXHJcbiAqIFRoZSBTY2VuZUdyYXBoIG1hbmFnZXMgdGhlIHBvc2l0aW9ucyBvZiBhbGwgR2FtZU5vZGVzLCBhbmQgY2FuIGVhc2lseSBwcnVuZSBhIHZpc2libGUgc2V0IGZvciByZW5kZXJpbmcuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBTY2VuZUdyYXBoIHtcclxuICAvKipcdEEgcmVmZXJlbmNlIHRvIHRoZSB2aWV3cG9ydCAqL1xyXG4gIHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XHJcbiAgLyoqXHRBIG1hcCBvZiBDYW52YXNOb2RlcyBpbiB0aGlzIFNjZW5lR3JhcGggKi9cclxuICBwcm90ZWN0ZWQgbm9kZU1hcDogQXJyYXk8Q2FudmFzTm9kZT47XHJcbiAgLyoqIEEgY291bnRlciBvZiBJRHMgZm9yIG5vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xyXG4gIHByb3RlY3RlZCBpZENvdW50ZXI6IG51bWJlcjtcclxuICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIFNjZW5lIHRoaXMgU2NlbmVHcmFwaCBiZWxvbmdzIHRvICovXHJcbiAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBTY2VuZUdyYXBoXHJcbiAgICogQHBhcmFtIHZpZXdwb3J0IFRoZSB2aWV3cG9ydFxyXG4gICAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG9cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih2aWV3cG9ydDogVmlld3BvcnQsIHNjZW5lOiBTY2VuZSkge1xyXG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xyXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgdGhpcy5ub2RlTWFwID0gbmV3IEFycmF5KCk7XHJcbiAgICB0aGlzLmlkQ291bnRlciA9IDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBub2RlIHRvIHRoZSBTY2VuZUdyYXBoXHJcbiAgICogQHBhcmFtIG5vZGUgVGhlIENhbnZhc05vZGUgdG8gYWRkIHRvIHRoZSBTY2VuZUdyYXBoXHJcbiAgICogQHJldHVybnMgVGhlIFNjZW5lR3JhcGggSUQgb2YgdGhpcyBuZXdseSBhZGRlZCBDYW52YXNOb2RlXHJcbiAgICovXHJcbiAgYWRkTm9kZShub2RlOiBDYW52YXNOb2RlKTogbnVtYmVyIHtcclxuICAgIHRoaXMubm9kZU1hcFtub2RlLmlkXSA9IG5vZGU7XHJcbiAgICB0aGlzLmFkZE5vZGVTcGVjaWZpYyhub2RlLCB0aGlzLmlkQ291bnRlcik7XHJcbiAgICB0aGlzLmlkQ291bnRlciArPSAxO1xyXG4gICAgcmV0dXJuIHRoaXMuaWRDb3VudGVyIC0gMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuIG92ZXJyaWRhYmxlIG1ldGhvZCB0byBhZGQgYSBDYW52YXNOb2RlIHRvIHRoZSBzcGVjaWZpYyBkYXRhIHN0cnVjdHVyZSBvZiB0aGUgU2NlbmVHcmFwaFxyXG4gICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGFkZCB0byB0aGUgZGF0YSBzdHJ1Y3R1cmVcclxuICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBDYW52YXNOb2RlXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGFkZE5vZGVTcGVjaWZpYyhub2RlOiBDYW52YXNOb2RlLCBpZDogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGUgU2NlbmVHcmFwaFxyXG4gICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxyXG4gICAqL1xyXG4gIHJlbW92ZU5vZGUobm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xyXG4gICAgLy8gRmluZCBhbmQgcmVtb3ZlIG5vZGUgaW4gTyhuKVxyXG4gICAgdGhpcy5ub2RlTWFwW25vZGUuaWRdID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5yZW1vdmVOb2RlU3BlY2lmaWMobm9kZSwgbm9kZS5pZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gb2YgcmVtb3ZpbmcgYSBub2RlXHJcbiAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXHJcbiAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgbm9kZSB0byByZW1vdmVcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVtb3ZlTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgYSBzcGVjaWZpYyBub2RlIHVzaW5nIGl0cyBpZFxyXG4gICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIENhbnZhc05vZGUgdG8gcmV0cmlldmVcclxuICAgKiBAcmV0dXJucyBUaGUgbm9kZSB3aXRoIHRoaXMgSURcclxuICAgKi9cclxuICBnZXROb2RlKGlkOiBudW1iZXIpOiBDYW52YXNOb2RlIHtcclxuICAgIHJldHVybiB0aGlzLm5vZGVNYXBbaWRdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbm9kZXMgYXQgc3BlY2lmaWMgY29vcmRpbmF0ZXNcclxuICAgKiBAcGFyYW0gdmVjT3JYIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHBvc2l0aW9uLCBvciB0aGUgY29vcmRpbmF0ZXMgaW4gYSBWZWMyXHJcbiAgICogQHBhcmFtIHkgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgcG9zaXRpb25cclxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyBmb3VuZCBhdCB0aGUgcG9zaXRpb24gcHJvdmlkZWRcclxuICAgKi9cclxuICBnZXROb2Rlc0F0KHZlY09yWDogVmVjMiB8IG51bWJlciwgeTogbnVtYmVyID0gbnVsbCk6IEFycmF5PENhbnZhc05vZGU+IHtcclxuICAgIGlmICh2ZWNPclggaW5zdGFuY2VvZiBWZWMyKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldE5vZGVzQXRDb29yZHModmVjT3JYLngsIHZlY09yWC55KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldE5vZGVzQXRDb29yZHModmVjT3JYLCB5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG5vZGVzIHRoYXQgb3ZlcmxhcCBhIHNwZWNpZmljIGJvdW5kYXJ5XHJcbiAgICogQHBhcmFtIGJvdW5kYXJ5IFRoZSByZWdpb24gdG8gY2hlY2tcclxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyBmb3VuZCBvdmVybGFwcGluZyB0aGUgcHJvdmlkZWQgYm91bmRhcnlcclxuICAgKi9cclxuICBhYnN0cmFjdCBnZXROb2Rlc0luUmVnaW9uKGJvdW5kYXJ5OiBBQUJCKTogQXJyYXk8Q2FudmFzTm9kZT47XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWxsIG5vZGVzIGluIHRoZSBTY2VuZUdyYXBoXHJcbiAgICogQHJldHVybnMgQW4gQXJyYXkgY29udGFpbmluZyBhbGwgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcclxuICAgKi9cclxuICBnZXRBbGxOb2RlcygpOiBBcnJheTxDYW52YXNOb2RlPiB7XHJcbiAgICBsZXQgYXJyID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubm9kZU1hcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAodGhpcy5ub2RlTWFwW2ldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBhcnIucHVzaCh0aGlzLm5vZGVNYXBbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIG9mIGdldHRpbmcgYSBub2RlIGF0IGNlcnRhaW4gY29vcmRpbmF0ZXNcclxuICAgKiBAcGFyYW0geCBUaGUgeC1jb29yZGluYXRlcyBvZiB0aGUgbm9kZVxyXG4gICAqIEBwYXJhbSB5IFRoZSB5LWNvb3JkaW5hdGVzIG9mIHRoZSBub2RlXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldE5vZGVzQXRDb29yZHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBBcnJheTxDYW52YXNOb2RlPjtcclxuXHJcbiAgYWJzdHJhY3QgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgYWJzdHJhY3QgcmVuZGVyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgdmlzaWJsZSBzZXQgb2YgQ2FudmFzTm9kZXMgYmFzZWQgb24gdGhlIEByZWZlcmVuY2VbVmlld3BvcnRdXHJcbiAgICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyBhbGwgdmlzaWJsZSBub2RlcyBpbiB0aGUgU2NlbmVHcmFwaFxyXG4gICAqL1xyXG4gIGFic3RyYWN0IGdldFZpc2libGVTZXQoKTogQXJyYXk8Q2FudmFzTm9kZT47XHJcbn1cclxuIiwiaW1wb3J0IFNjZW5lR3JhcGggZnJvbSBcIi4vU2NlbmVHcmFwaFwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4vVmlld3BvcnRcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBTdGF0cyBmcm9tIFwiLi4vRGVidWcvU3RhdHNcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIFNjZW5lR3JhcGggdGhhdCBzaW1wbHkgc3RvcmVkIENhbnZhc05vZGVzIGluIGFuIGFycmF5LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVHcmFwaEFycmF5IGV4dGVuZHMgU2NlbmVHcmFwaCB7XHJcbiAgLyoqIFRoZSBsaXN0IG9mIENhbnZhc05vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xyXG4gIHByaXZhdGUgbm9kZUxpc3Q6IEFycmF5PENhbnZhc05vZGU+O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IFNjZW5lR3JhcGhBcnJheVxyXG4gICAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgVmlld3BvcnRcclxuICAgKiBAcGFyYW0gc2NlbmUgVGhlIFNjZW5lIHRoaXMgU2NlbmVHcmFwaCBiZWxvbmdzIHRvXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCBzY2VuZTogU2NlbmUpIHtcclxuICAgIHN1cGVyKHZpZXdwb3J0LCBzY2VuZSk7XHJcblxyXG4gICAgdGhpcy5ub2RlTGlzdCA9IG5ldyBBcnJheTxDYW52YXNOb2RlPigpO1xyXG4gIH1cclxuXHJcbiAgLy8gQG92ZXJyaWRlXHJcbiAgcHJvdGVjdGVkIGFkZE5vZGVTcGVjaWZpYyhub2RlOiBDYW52YXNOb2RlLCBpZDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLm5vZGVMaXN0LnB1c2gobm9kZSk7XHJcbiAgfVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICBwcm90ZWN0ZWQgcmVtb3ZlTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGxldCBpbmRleCA9IHRoaXMubm9kZUxpc3QuaW5kZXhPZihub2RlKTtcclxuICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgIHRoaXMubm9kZUxpc3Quc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEBvdmVycmlkZVxyXG4gIGdldE5vZGVzQXRDb29yZHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBBcnJheTxDYW52YXNOb2RlPiB7XHJcbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IG5vZGUgb2YgdGhpcy5ub2RlTGlzdCkge1xyXG4gICAgICBpZiAobm9kZS5jb250YWlucyh4LCB5KSkge1xyXG4gICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH1cclxuXHJcbiAgLy8gQG92ZXJyaWRlXHJcbiAgZ2V0Tm9kZXNJblJlZ2lvbihib3VuZGFyeTogQUFCQik6IEFycmF5PENhbnZhc05vZGU+IHtcclxuICAgIGxldCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgbGV0IHJlc3VsdHMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3QpIHtcclxuICAgICAgaWYgKGJvdW5kYXJ5Lm92ZXJsYXBzKG5vZGUuYm91bmRhcnkpKSB7XHJcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIFN0YXRzLmxvZyhcInNncXVlcnlcIiwgdDEgLSB0MCk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGxldCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KSB7XHJcbiAgICAgIGlmICghbm9kZS5nZXRMYXllcigpLmlzUGF1c2VkKCkpIHtcclxuICAgICAgICBub2RlLnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIFN0YXRzLmxvZyhcInNndXBkYXRlXCIsIHQxIC0gdDApO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZCB7fVxyXG5cclxuICAvLyBAb3ZlcnJpZGVcclxuICBnZXRWaXNpYmxlU2V0KCk6IEFycmF5PENhbnZhc05vZGU+IHtcclxuICAgIGxldCB2aXNpYmxlU2V0ID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XHJcblxyXG4gICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KSB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICAhbm9kZS5nZXRMYXllcigpLmlzSGlkZGVuKCkgJiZcclxuICAgICAgICBub2RlLnZpc2libGUgJiZcclxuICAgICAgICB0aGlzLnZpZXdwb3J0LmluY2x1ZGVzKG5vZGUpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHZpc2libGVTZXQucHVzaChub2RlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2aXNpYmxlU2V0O1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi9VdGlscy9NYXRoVXRpbHNcIjtcclxuaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uL0lucHV0L0lucHV0XCI7XHJcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvUGFyYWxsYXhMYXllclwiO1xyXG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgdmlld3BvcnQgb2YgdGhlIGdhbWUuIENvcnJlc3BvbmRzIHRvIHRoZSB2aXNpYmxlIHdpbmRvdyBkaXNwbGF5ZWQgaW4gdGhlIGJyb3dzZXIuXHJcbiAqIFRoZSB2aWV3cG9ydCBrZWVwcyB0cmFjayBvZiBpdHMgcG9zaXRpb24gaW4gdGhlIGdhbWUgd29ybGQsIGFuZCBjYW4gYWN0IGFzIGEgY2FtZXJhIHRvIGZvbGxvdyBvYmplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQge1xyXG4gIC8qKiBUaGUgQUFCQiB0aGF0IGNvbnRhaW5zIHRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgdmlld3BvcnQgdmlldyAqL1xyXG4gIHByaXZhdGUgdmlldzogQUFCQjtcclxuICAvKiogVGhlIGJvdW5kYXJ5IGZvciB0aGUgdmlld3BvcnQuIFRoaXMgcmVwcmVzZW50cyB0aGUgbGltaXRzIHRvIHdoZXJlIHRoZSB2aWV3cG9ydCBjYW4gZ28gKi9cclxuICBwcml2YXRlIGJvdW5kYXJ5OiBBQUJCO1xyXG4gIC8qKiBUaGUgR2FtZU5vZGUgdGhlIFZpZXdwb3J0IGlzIGZvbGxvd2luZyAqL1xyXG4gIHByaXZhdGUgZm9sbG93aW5nOiBHYW1lTm9kZTtcclxuICAvKiogVGhlIHBvc2l0aW9uIHRoZSBHYW1lTm9kZSBpcyBmb2N1c2luZyBvbi4gVGhpcyBpcyBvdmVycmlkZGVuIGlmIFwiZm9sbG93aW5nXCIgaXMgc2V0LiAqL1xyXG4gIHByaXZhdGUgZm9jdXM6IFZlYzI7XHJcblxyXG4gIC8qKiBBIHF1ZXVlIG9mIHByZXZpb3VzIHBvc2l0aW9ucyBvZiB3aGF0IHRoaXMgdmlld3BvcnQgaXMgZm9sbG93aW5nLiBVc2VkIGZvciBzbW9vdGhpbmcgdmlld3BvcnQgbW92ZW1lbnQgKi9cclxuICBwcml2YXRlIGxhc3RQb3NpdGlvbnM6IFF1ZXVlPFZlYzI+O1xyXG5cclxuICAvKiogVGhlIG51bWJlciBvZiBwcmV2aW91cyBwb3NpdGlvbnMgdGhpcyB2aWV3cG9ydCB0cmFja3MgKi9cclxuICBwcml2YXRlIHNtb290aGluZ0ZhY3RvcjogbnVtYmVyO1xyXG5cclxuICAvKiogQSBib29sZWFuIHRoYSByZXByZXNlbnRzIHdoZXRoZXIgdGhlIHBsYXllciBjYW4gem9vbSBieSBzY3JvbGxpbmcgd2l0aCB0aGUgbW91c2Ugd2hlZWwgKi9cclxuICBwcml2YXRlIHNjcm9sbFpvb21FbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAvKiogVGhlIGFtb3VudCB0aGF0IGlzIHpvb21lZCBpbiBvciBvdXQuICovXHJcbiAgcHJpdmF0ZSBaT09NX0ZBQ1RPUjogbnVtYmVyID0gMS4yO1xyXG5cclxuICAvKiogVGhlIHNpemUgb2YgdGhlIGNhbnZhcyAqL1xyXG4gIHByaXZhdGUgY2FudmFzU2l6ZTogVmVjMjtcclxuXHJcbiAgY29uc3RydWN0b3IoY2FudmFzU2l6ZTogVmVjMiwgem9vbUxldmVsOiBudW1iZXIpIHtcclxuICAgIHRoaXMudmlldyA9IG5ldyBBQUJCKFZlYzIuWkVSTywgVmVjMi5aRVJPKTtcclxuICAgIHRoaXMuYm91bmRhcnkgPSBuZXcgQUFCQihWZWMyLlpFUk8sIFZlYzIuWkVSTyk7XHJcbiAgICB0aGlzLmxhc3RQb3NpdGlvbnMgPSBuZXcgUXVldWUoKTtcclxuICAgIHRoaXMuc21vb3RoaW5nRmFjdG9yID0gMTA7XHJcbiAgICB0aGlzLnNjcm9sbFpvb21FbmFibGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmNhbnZhc1NpemUgPSBWZWMyLlpFUk87XHJcbiAgICB0aGlzLmZvY3VzID0gVmVjMi5aRVJPO1xyXG5cclxuICAgIC8vIFNldCB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzXHJcbiAgICB0aGlzLnNldENhbnZhc1NpemUoY2FudmFzU2l6ZSk7XHJcblxyXG4gICAgLy8gU2V0IHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgdGhpcy5zZXRTaXplKGNhbnZhc1NpemUpO1xyXG4gICAgdGhpcy5zZXRab29tTGV2ZWwoem9vbUxldmVsKTtcclxuXHJcbiAgICAvLyBTZXQgdGhlIGNlbnRlciAoYW5kIG1ha2UgdGhlIHZpZXdwb3J0IHN0YXkgdGhlcmUpXHJcbiAgICB0aGlzLnNldENlbnRlcih0aGlzLnZpZXcuaGFsZlNpemUuY2xvbmUoKSk7XHJcbiAgICB0aGlzLnNldEZvY3VzKHRoaXMudmlldy5oYWxmU2l6ZS5jbG9uZSgpKTtcclxuICB9XHJcblxyXG4gIC8qKiBFbmFibGVzIHRoZSB2aWV3cG9ydCB0byB6b29tIGluIGFuZCBvdXQgKi9cclxuICBlbmFibGVab29tKCk6IHZvaWQge1xyXG4gICAgdGhpcy5zY3JvbGxab29tRW5hYmxlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnRcclxuICAgKiBAcmV0dXJucyBUaGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCBhcyBhIFZlYzJcclxuICAgKi9cclxuICBnZXRDZW50ZXIoKTogVmVjMiB7XHJcbiAgICByZXR1cm4gdGhpcy52aWV3LmNlbnRlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBuZXcgVmVjMiB3aXRoIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0XHJcbiAgICogQHJldHVybnMgVGhlIHRvcCBsZWZ0IGNvcm5kZXIgb2YgdGhlIFZpZXBvcnQgYXMgYSBWZWMyXHJcbiAgICovXHJcbiAgZ2V0T3JpZ2luKCk6IFZlYzIge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMudmlldy5sZWZ0LCB0aGlzLnZpZXcudG9wKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHJlZ2lvbiB2aXNpYmxlIHRvIHRoaXMgdmlld3BvcnRcclxuICAgKiBAcmV0dXJucyBUaGUgQUFCQiBjb250YWluaW5nIHRoZSByZWdpb24gdmlzaWJsZSB0byB0aGUgdmlld3BvcnRcclxuICAgKi9cclxuICBnZXRWaWV3KCk6IEFBQkIge1xyXG4gICAgcmV0dXJuIHRoaXMudmlldztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XHJcbiAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IHBvc2l0aW9uIG9yIHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSB5IFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb3NpdGlvblxyXG4gICAqL1xyXG4gIHNldENlbnRlcih2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcclxuICAgIGxldCBwb3M6IFZlYzI7XHJcbiAgICBpZiAodmVjT3JYIGluc3RhbmNlb2YgVmVjMikge1xyXG4gICAgICBwb3MgPSB2ZWNPclg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwb3MgPSBuZXcgVmVjMih2ZWNPclgsIHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudmlldy5jZW50ZXIgPSBwb3M7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydCBhcyBhIFZlYzJcclxuICAgKiBAcmV0dXJucyBUaGUgaGFsZi1zaXplIG9mIHRoZSB2aWV3cG9ydCBhcyBhIFZlYzJcclxuICAgKi9cclxuICBnZXRIYWxmU2l6ZSgpOiBWZWMyIHtcclxuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0SGFsZlNpemUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IHdpZHRoIG9mIHRoZSB2aWV3cG9ydCBvciB0aGUgbmV3IHNpemUgYXMgYSBWZWMyXHJcbiAgICogQHBhcmFtIHkgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICovXHJcbiAgc2V0U2l6ZSh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcclxuICAgIGlmICh2ZWNPclggaW5zdGFuY2VvZiBWZWMyKSB7XHJcbiAgICAgIHRoaXMudmlldy5zZXRIYWxmU2l6ZSh2ZWNPclguc2NhbGVkKDEgLyAyKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnZpZXcuc2V0SGFsZlNpemUobmV3IFZlYzIodmVjT3JYIC8gMiwgeSAvIDIpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGhhbGYtc2l6ZSBvZiB0aGUgdmlld3BvcnRcclxuICAgKiBAcGFyYW0gdmVjT3JYIFRoZSBuZXcgaGFsZi13aWR0aCBvZiB0aGUgdmlld3BvcnQgb3IgdGhlIG5ldyBoYWxmLXNpemUgYXMgYSBWZWMyXHJcbiAgICogQHBhcmFtIHkgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICovXHJcbiAgc2V0SGFsZlNpemUodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XHJcbiAgICBpZiAodmVjT3JYIGluc3RhbmNlb2YgVmVjMikge1xyXG4gICAgICB0aGlzLnZpZXcuc2V0SGFsZlNpemUodmVjT3JYLmNsb25lKCkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy52aWV3LnNldEhhbGZTaXplKG5ldyBWZWMyKHZlY09yWCwgeSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgdmlld3BvcnQgd2l0aCB0aGUgc2l6ZSBvZiB0aGUgY3VycmVudCBDYW52YXNcclxuICAgKiBAcGFyYW0gdmVjT3JYIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzLCBvciB0aGUgY2FudmFzIHNpemUgYXMgYSBWZWMyXHJcbiAgICogQHBhcmFtIHkgVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzXHJcbiAgICovXHJcbiAgc2V0Q2FudmFzU2l6ZSh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcclxuICAgIGlmICh2ZWNPclggaW5zdGFuY2VvZiBWZWMyKSB7XHJcbiAgICAgIHRoaXMuY2FudmFzU2l6ZSA9IHZlY09yWC5jbG9uZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5jYW52YXNTaXplID0gbmV3IFZlYzIodmVjT3JYLCB5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICogQHBhcmFtIHpvb20gVGhlIHpvb20gbGV2ZWxcclxuICAgKi9cclxuICBzZXRab29tTGV2ZWwoem9vbTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLnZpZXcuaGFsZlNpemUuY29weSh0aGlzLmNhbnZhc1NpemUuc2NhbGVkKDEgLyB6b29tIC8gMikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgem9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcclxuICAgKiBAcmV0dXJucyBUaGUgem9vbSBsZXZlbFxyXG4gICAqL1xyXG4gIGdldFpvb21MZXZlbCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY2FudmFzU2l6ZS54IC8gdGhpcy52aWV3Lmh3IC8gMjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHNtb290aGluZyBmYWN0b3IgZm9yIHRoZSB2aWV3cG9ydCBtb3ZlbWVudC5cclxuICAgKiBAcGFyYW0gc21vb3RoaW5nRmFjdG9yIFRoZSBzbW9vdGhpbmcgZmFjdG9yIGZvciB0aGUgdmlld3BvcnRcclxuICAgKi9cclxuICBzZXRTbW9vdGhpbmdGYWN0b3Ioc21vb3RoaW5nRmFjdG9yOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGlmIChzbW9vdGhpbmdGYWN0b3IgPCAwKSBzbW9vdGhpbmdGYWN0b3IgPSAwO1xyXG4gICAgdGhpcy5zbW9vdGhpbmdGYWN0b3IgPSBzbW9vdGhpbmdGYWN0b3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZWxscyB0aGUgdmlld3BvcnQgdG8gZm9jdXMgb24gYSBwb2ludC4gT3ZlcmlkZGVuIGJ5IFwiZm9sbG93aW5nXCIuXHJcbiAgICogQHBhcmFtIGZvY3VzIFRoZSBwb2ludCB0aGUgIHZpZXdwb3J0IHNob3VsZCBmb2N1cyBvblxyXG4gICAqL1xyXG4gIHNldEZvY3VzKGZvY3VzOiBWZWMyKTogdm9pZCB7XHJcbiAgICB0aGlzLmZvY3VzLmNvcHkoZm9jdXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBDYW52YXNOb2RlIGlzIGluc2lkZSBvZiB0aGUgdmlld3BvcnRcclxuICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBjaGVja1xyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG5vZGUgaXMgY3VycmVudGx5IHZpc2libGUgaW4gdGhlIHZpZXdwb3J0LCBmYWxzZSBpZiBub3RcclxuICAgKi9cclxuICBpbmNsdWRlcyhub2RlOiBDYW52YXNOb2RlKTogYm9vbGVhbiB7XHJcbiAgICBsZXQgcGFyYWxsYXggPVxyXG4gICAgICBub2RlLmdldExheWVyKCkgaW5zdGFuY2VvZiBQYXJhbGxheExheWVyIHx8XHJcbiAgICAgIG5vZGUuZ2V0TGF5ZXIoKSBpbnN0YW5jZW9mIFVJTGF5ZXJcclxuICAgICAgICA/ICg8UGFyYWxsYXhMYXllcj5ub2RlLmdldExheWVyKCkpLnBhcmFsbGF4XHJcbiAgICAgICAgOiBuZXcgVmVjMigxLCAxKTtcclxuICAgIGxldCBjZW50ZXIgPSB0aGlzLnZpZXcuY2VudGVyLmNsb25lKCk7XHJcbiAgICB0aGlzLnZpZXcuY2VudGVyLm11bHQocGFyYWxsYXgpO1xyXG4gICAgbGV0IG92ZXJsYXBzID0gdGhpcy52aWV3Lm92ZXJsYXBzKG5vZGUuYm91bmRhcnkpO1xyXG4gICAgdGhpcy52aWV3LmNlbnRlciA9IGNlbnRlcjtcclxuICAgIHJldHVybiBvdmVybGFwcztcclxuICB9XHJcblxyXG4gIC8vIFRPRE86IFB1dCBzb21lIGVycm9yIGhhbmRsaW5nIG9uIHRoaXMgZm9yIHRyeWluZyB0byBtYWtlIHRoZSBib3VuZHMgdG9vIHNtYWxsIGZvciB0aGUgdmlld3BvcnRcclxuICAvLyBUT0RPOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBkb25lIGF1dG9tYXRpY2FsbHksIG9yIHNob3VsZCBjb25zaWRlciB0aGUgYXNwZWN0IHJhdGlvIG9yIHNvbWV0aGluZ1xyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGJvdW5kcyBvZiB0aGUgdmlld3BvcnRcclxuICAgKiBAcGFyYW0gbG93ZXJYIFRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHZpZXdwb3J0XHJcbiAgICogQHBhcmFtIGxvd2VyWSBUaGUgdG9wIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0XHJcbiAgICogQHBhcmFtIHVwcGVyWCBUaGUgcmlnaHQgZWRnZSBvZiB0aGUgdmlld3BvcnRcclxuICAgKiBAcGFyYW0gdXBwZXJZIFRoZSBib3R0b20gZWRnZSBvZiB0aGUgdmlld3BvcnRcclxuICAgKi9cclxuICBzZXRCb3VuZHMoXHJcbiAgICBsb3dlclg6IG51bWJlcixcclxuICAgIGxvd2VyWTogbnVtYmVyLFxyXG4gICAgdXBwZXJYOiBudW1iZXIsXHJcbiAgICB1cHBlclk6IG51bWJlcixcclxuICApOiB2b2lkIHtcclxuICAgIGxldCBod2lkdGggPSAodXBwZXJYIC0gbG93ZXJYKSAvIDI7XHJcbiAgICBsZXQgaGhlaWdodCA9ICh1cHBlclkgLSBsb3dlclkpIC8gMjtcclxuICAgIGxldCB4ID0gbG93ZXJYICsgaHdpZHRoO1xyXG4gICAgbGV0IHkgPSBsb3dlclkgKyBoaGVpZ2h0O1xyXG4gICAgdGhpcy5ib3VuZGFyeS5jZW50ZXIuc2V0KHgsIHkpO1xyXG4gICAgdGhpcy5ib3VuZGFyeS5oYWxmU2l6ZS5zZXQoaHdpZHRoLCBoaGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1ha2UgdGhlIHZpZXdwb3J0IGZvbGxvdyB0aGUgc3BlY2lmaWVkIEdhbWVOb2RlXHJcbiAgICogQHBhcmFtIG5vZGUgVGhlIEdhbWVOb2RlIHRvIGZvbGxvd1xyXG4gICAqL1xyXG4gIGZvbGxvdyhub2RlOiBHYW1lTm9kZSk6IHZvaWQge1xyXG4gICAgdGhpcy5mb2xsb3dpbmcgPSBub2RlO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlVmlldygpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmxhc3RQb3NpdGlvbnMuZ2V0U2l6ZSgpID4gTWF0aC5taW4odGhpcy5zbW9vdGhpbmdGYWN0b3IsIDEpKSB7XHJcbiAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5kZXF1ZXVlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IHRoZSBhdmVyYWdlIG9mIHRoZSBsYXN0IDEwIHBvc2l0aW9uc1xyXG4gICAgbGV0IHBvcyA9IFZlYzIuWkVSTztcclxuICAgIGlmICh0aGlzLnNtb290aGluZ0ZhY3RvciAhPSAwKSB7XHJcbiAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5mb3JFYWNoKHBvc2l0aW9uID0+IHBvcy5hZGQocG9zaXRpb24pKTtcclxuICAgICAgcG9zLnNjYWxlKDEgLyB0aGlzLmxhc3RQb3NpdGlvbnMuZ2V0U2l6ZSgpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5mb3JFYWNoKHBvc2l0aW9uID0+IChwb3MgPSBwb3NpdGlvbikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCB0aGlzIHBvc2l0aW9uIGVpdGhlciB0byB0aGUgb2JqZWN0IG9yIHRvIGl0cyBib3VuZHNcclxuICAgIHBvcy54ID0gTWF0aFV0aWxzLmNsYW1wKFxyXG4gICAgICBwb3MueCxcclxuICAgICAgdGhpcy5ib3VuZGFyeS5sZWZ0ICsgdGhpcy52aWV3Lmh3LFxyXG4gICAgICB0aGlzLmJvdW5kYXJ5LnJpZ2h0IC0gdGhpcy52aWV3Lmh3LFxyXG4gICAgKTtcclxuICAgIHBvcy55ID0gTWF0aFV0aWxzLmNsYW1wKFxyXG4gICAgICBwb3MueSxcclxuICAgICAgdGhpcy5ib3VuZGFyeS50b3AgKyB0aGlzLnZpZXcuaGgsXHJcbiAgICAgIHRoaXMuYm91bmRhcnkuYm90dG9tIC0gdGhpcy52aWV3LmhoLFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBBc3N1cmUgdGhlcmUgYXJlIG5vIGxpbmVzIGluIHRoZSB0aWxlbWFwXHJcbiAgICBwb3MueCA9IE1hdGguZmxvb3IocG9zLngpO1xyXG4gICAgcG9zLnkgPSBNYXRoLmZsb29yKHBvcy55KTtcclxuXHJcbiAgICB0aGlzLnZpZXcuY2VudGVyLmNvcHkocG9zKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgLy8gSWYgem9vbSBpcyBlbmFibGVkXHJcbiAgICBpZiAodGhpcy5zY3JvbGxab29tRW5hYmxlZCkge1xyXG4gICAgICBpZiAoSW5wdXQuZGlkSnVzdFNjcm9sbCgpKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRTaXplID0gdGhpcy52aWV3LmdldEhhbGZTaXplKCkuY2xvbmUoKTtcclxuICAgICAgICBpZiAoSW5wdXQuZ2V0U2Nyb2xsRGlyZWN0aW9uKCkgPCAwKSB7XHJcbiAgICAgICAgICAvLyBab29tIGluXHJcbiAgICAgICAgICBjdXJyZW50U2l6ZS5zY2FsZSgxIC8gdGhpcy5aT09NX0ZBQ1RPUik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFpvb20gb3V0XHJcbiAgICAgICAgICBjdXJyZW50U2l6ZS5zY2FsZSh0aGlzLlpPT01fRkFDVE9SKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50U2l6ZS54ID4gdGhpcy5ib3VuZGFyeS5odykge1xyXG4gICAgICAgICAgbGV0IGZhY3RvciA9IHRoaXMuYm91bmRhcnkuaHcgLyBjdXJyZW50U2l6ZS54O1xyXG4gICAgICAgICAgY3VycmVudFNpemUueCA9IHRoaXMuYm91bmRhcnkuaHc7XHJcbiAgICAgICAgICBjdXJyZW50U2l6ZS55ICo9IGZhY3RvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50U2l6ZS55ID4gdGhpcy5ib3VuZGFyeS5oaCkge1xyXG4gICAgICAgICAgbGV0IGZhY3RvciA9IHRoaXMuYm91bmRhcnkuaGggLyBjdXJyZW50U2l6ZS55O1xyXG4gICAgICAgICAgY3VycmVudFNpemUueSA9IHRoaXMuYm91bmRhcnkuaGg7XHJcbiAgICAgICAgICBjdXJyZW50U2l6ZS54ICo9IGZhY3RvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudmlldy5zZXRIYWxmU2l6ZShjdXJyZW50U2l6ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB2aWV3cG9ydCBpcyBmb2xsb3dpbmcgYW4gb2JqZWN0XHJcbiAgICBpZiAodGhpcy5mb2xsb3dpbmcpIHtcclxuICAgICAgLy8gVXBkYXRlIG91ciBsaXN0IG9mIHByZXZpb3VzIHBvc2l0aW9uc1xyXG4gICAgICB0aGlzLmxhc3RQb3NpdGlvbnMuZW5xdWV1ZSh0aGlzLmZvbGxvd2luZy5wb3NpdGlvbi5jbG9uZSgpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5lbnF1ZXVlKHRoaXMuZm9jdXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXBkYXRlVmlldygpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudFwiO1xyXG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY1wiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XHJcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuaW1wb3J0IFNsaWRlciBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9TbGlkZXJcIjtcclxuaW1wb3J0IFRleHRJbnB1dCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9UZXh0SW5wdXRcIjtcclxuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xyXG5pbXBvcnQgUGFydGljbGUgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1BhcnRpY2xlXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuXHJcbi8vIEBpZ25vcmVQYWdlXHJcblxyXG4vKipcclxuICogQSBmYWN0b3J5IHRoYXQgYWJzdHJhY3RzIGFkZGluZyBAcmVmZXJlbmNlW0NhbnZhc05vZGVdcyB0byB0aGUgQHJlZmVyZW5jZVtTY2VuZV0uXHJcbiAqIEFjY2VzcyBtZXRob2RzIGluIHRoaXMgZmFjdG9yeSB0aHJvdWdoIFNjZW5lLmFkZC5bbWV0aG9kTmFtZV0oKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbnZhc05vZGVGYWN0b3J5IHtcclxuICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xyXG4gIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuXHJcbiAgaW5pdChzY2VuZTogU2NlbmUpOiB2b2lkIHtcclxuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGFuIGluc3RhbmNlIG9mIGEgVUlFbGVtZW50IHRvIHRoZSBjdXJyZW50IHNjZW5lIC0gaS5lLiBhbnkgY2xhc3MgdGhhdCBleHRlbmRzIFVJRWxlbWVudFxyXG4gICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIFVJRWxlbWVudCB0byBhZGRcclxuICAgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciB0byBhZGQgdGhlIFVJRWxlbWVudCB0b1xyXG4gICAqIEBwYXJhbSBvcHRpb25zIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBmZWVkIHRvIHRoZSBjb25zdHJ1Y3RvclxyXG4gICAqIEByZXR1cm5zIEEgbmV3IFVJRWxlbWVudFxyXG4gICAqL1xyXG4gIGFkZFVJRWxlbWVudCA9IChcclxuICAgIHR5cGU6IHN0cmluZyB8IFVJRWxlbWVudFR5cGUsXHJcbiAgICBsYXllck5hbWU6IHN0cmluZyxcclxuICAgIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxyXG4gICk6IFVJRWxlbWVudCA9PiB7XHJcbiAgICAvLyBHZXQgdGhlIGxheWVyXHJcbiAgICBsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XHJcblxyXG4gICAgbGV0IGluc3RhbmNlOiBVSUVsZW1lbnQ7XHJcblxyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgIGNhc2UgVUlFbGVtZW50VHlwZS5CVVRUT046XHJcbiAgICAgICAgaW5zdGFuY2UgPSB0aGlzLmJ1aWxkQnV0dG9uKG9wdGlvbnMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFVJRWxlbWVudFR5cGUuTEFCRUw6XHJcbiAgICAgICAgaW5zdGFuY2UgPSB0aGlzLmJ1aWxkTGFiZWwob3B0aW9ucyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgVUlFbGVtZW50VHlwZS5TTElERVI6XHJcbiAgICAgICAgaW5zdGFuY2UgPSB0aGlzLmJ1aWxkU2xpZGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFVJRWxlbWVudFR5cGUuVEVYVF9JTlBVVDpcclxuICAgICAgICBpbnN0YW5jZSA9IHRoaXMuYnVpbGRUZXh0SW5wdXQob3B0aW9ucyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgYFVJRWxlbWVudFR5cGUgJyR7dHlwZX0nIGRvZXMgbm90IGV4aXN0LCBvciBpcyByZWdpc3RlcmVkIGluY29ycmVjdGx5LmA7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XHJcbiAgICBpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xyXG4gICAgdGhpcy5zY2VuZS5nZXRTY2VuZUdyYXBoKCkuYWRkTm9kZShpbnN0YW5jZSk7XHJcblxyXG4gICAgLy8gQWRkIGluc3RhbmNlIHRvIGxheWVyXHJcbiAgICBsYXllci5hZGROb2RlKGluc3RhbmNlKTtcclxuXHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIHNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxyXG4gICAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgc3ByaXRlXHJcbiAgICogQHJldHVybnMgQSBuZXcgU3ByaXRlXHJcbiAgICovXHJcbiAgYWRkU3ByaXRlID0gKGtleTogc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZyk6IFNwcml0ZSA9PiB7XHJcbiAgICBsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XHJcblxyXG4gICAgbGV0IGluc3RhbmNlID0gbmV3IFNwcml0ZShrZXkpO1xyXG5cclxuICAgIC8vIEFkZCBpbnN0YW5jZSB0byBzY2VuZVxyXG4gICAgaW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XHJcbiAgICBpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgIShcclxuICAgICAgICB0aGlzLnNjZW5lLmlzUGFyYWxsYXhMYXllcihsYXllck5hbWUpIHx8IHRoaXMuc2NlbmUuaXNVSUxheWVyKGxheWVyTmFtZSlcclxuICAgICAgKVxyXG4gICAgKSB7XHJcbiAgICAgIHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxyXG4gICAgbGF5ZXIuYWRkTm9kZShpbnN0YW5jZSk7XHJcblxyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYW4gQW5pbWF0ZWRTcHJpdGUgdG8gdGhlIGN1cnJlbnQgc2NlbmVcclxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcclxuICAgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxyXG4gICAqIEByZXR1cm5zIEEgbmV3IEFuaW1hdGVkU3ByaXRlXHJcbiAgICovXHJcbiAgYWRkQW5pbWF0ZWRTcHJpdGUgPSAoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogQW5pbWF0ZWRTcHJpdGUgPT4ge1xyXG4gICAgbGV0IGxheWVyID0gdGhpcy5zY2VuZS5nZXRMYXllcihsYXllck5hbWUpO1xyXG4gICAgbGV0IHNwcml0ZXNoZWV0ID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U3ByaXRlc2hlZXQoa2V5KTtcclxuICAgIGxldCBpbnN0YW5jZSA9IG5ldyBBbmltYXRlZFNwcml0ZShzcHJpdGVzaGVldCk7XHJcblxyXG4gICAgLy8gQWRkIGluc3RhbmNlIGZvIHNjZW5lXHJcbiAgICBpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcclxuICAgIGluc3RhbmNlLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICAhKFxyXG4gICAgICAgIHRoaXMuc2NlbmUuaXNQYXJhbGxheExheWVyKGxheWVyTmFtZSkgfHwgdGhpcy5zY2VuZS5pc1VJTGF5ZXIobGF5ZXJOYW1lKVxyXG4gICAgICApXHJcbiAgICApIHtcclxuICAgICAgdGhpcy5zY2VuZS5nZXRTY2VuZUdyYXBoKCkuYWRkTm9kZShpbnN0YW5jZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIGluc3RhbmNlIHRvIGxheWVyXHJcbiAgICBsYXllci5hZGROb2RlKGluc3RhbmNlKTtcclxuXHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIG5ldyBncmFwaGljIGVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgU2NlbmVcclxuICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBncmFwaGljIHRvIGFkZFxyXG4gICAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgZ3JhcGhpY1xyXG4gICAqIEBwYXJhbSBvcHRpb25zIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzZW5kIHRvIHRoZSBncmFwaGljIGNvbnN0cnVjdG9yXHJcbiAgICogQHJldHVybnMgQSBuZXcgR3JhcGhpY1xyXG4gICAqL1xyXG4gIGFkZEdyYXBoaWMgPSAoXHJcbiAgICB0eXBlOiBHcmFwaGljVHlwZSB8IHN0cmluZyxcclxuICAgIGxheWVyTmFtZTogc3RyaW5nLFxyXG4gICAgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4sXHJcbiAgKTogR3JhcGhpYyA9PiB7XHJcbiAgICAvLyBHZXQgdGhlIGxheWVyXHJcbiAgICBsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XHJcblxyXG4gICAgbGV0IGluc3RhbmNlOiBHcmFwaGljO1xyXG5cclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlIEdyYXBoaWNUeXBlLlBPSU5UOlxyXG4gICAgICAgIGluc3RhbmNlID0gdGhpcy5idWlsZFBvaW50KG9wdGlvbnMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIEdyYXBoaWNUeXBlLkxJTkU6XHJcbiAgICAgICAgaW5zdGFuY2UgPSB0aGlzLmJ1aWxkTGluZShvcHRpb25zKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBHcmFwaGljVHlwZS5SRUNUOlxyXG4gICAgICAgIGluc3RhbmNlID0gdGhpcy5idWlsZFJlY3Qob3B0aW9ucyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgR3JhcGhpY1R5cGUuUEFSVElDTEU6XHJcbiAgICAgICAgaW5zdGFuY2UgPSB0aGlzLmJ1aWxkUGFydGljbGUob3B0aW9ucyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgYEdyYXBoaWNUeXBlICcke3R5cGV9JyBkb2VzIG5vdCBleGlzdCwgb3IgaXMgcmVnaXN0ZXJlZCBpbmNvcnJlY3RseS5gO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBpbnN0YW5jZSB0byBzY2VuZVxyXG4gICAgaW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XHJcbiAgICBpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgIShcclxuICAgICAgICB0aGlzLnNjZW5lLmlzUGFyYWxsYXhMYXllcihsYXllck5hbWUpIHx8IHRoaXMuc2NlbmUuaXNVSUxheWVyKGxheWVyTmFtZSlcclxuICAgICAgKVxyXG4gICAgKSB7XHJcbiAgICAgIHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxyXG4gICAgbGF5ZXIuYWRkTm9kZShpbnN0YW5jZSk7XHJcblxyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gIH07XHJcblxyXG4gIC8qIC0tLS0tLS0tLS0gQlVJTERFUlMgLS0tLS0tLS0tLSAqL1xyXG5cclxuICBidWlsZEJ1dHRvbihvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IEJ1dHRvbiB7XHJcbiAgICB0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiQnV0dG9uXCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xyXG4gICAgdGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkJ1dHRvblwiLCBvcHRpb25zLCBcInRleHRcIiwgXCJzdHJpbmdcIik7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBCdXR0b24ob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy50ZXh0KTtcclxuICB9XHJcblxyXG4gIGJ1aWxkTGFiZWwob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBMYWJlbCB7XHJcbiAgICB0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiTGFiZWxcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XHJcbiAgICB0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiTGFiZWxcIiwgb3B0aW9ucywgXCJ0ZXh0XCIsIFwic3RyaW5nXCIpO1xyXG5cclxuICAgIHJldHVybiBuZXcgTGFiZWwob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy50ZXh0KTtcclxuICB9XHJcblxyXG4gIGJ1aWxkU2xpZGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBTbGlkZXIge1xyXG4gICAgdGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlNsaWRlclwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHJcbiAgICBsZXQgaW5pdFZhbHVlID0gMDtcclxuICAgIGlmIChvcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgaW5pdFZhbHVlID0gb3B0aW9ucy52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFNsaWRlcihvcHRpb25zLnBvc2l0aW9uLCBpbml0VmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgYnVpbGRUZXh0SW5wdXQob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IFRleHRJbnB1dCB7XHJcbiAgICB0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiVGV4dElucHV0XCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xyXG5cclxuICAgIHJldHVybiBuZXcgVGV4dElucHV0KG9wdGlvbnMucG9zaXRpb24pO1xyXG4gIH1cclxuXHJcbiAgYnVpbGRQb2ludChvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFBvaW50IHtcclxuICAgIHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJQb2ludFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFBvaW50KG9wdGlvbnMucG9zaXRpb24pO1xyXG4gIH1cclxuXHJcbiAgYnVpbGRQYXJ0aWNsZShvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFBvaW50IHtcclxuICAgIHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJQYXJ0aWNsZVwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuICAgIHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJQYXJ0aWNsZVwiLCBvcHRpb25zLCBcInNpemVcIiwgVmVjMiwgXCJWZWMyXCIpO1xyXG4gICAgdGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlBhcnRpY2xlXCIsIG9wdGlvbnMsIFwibWFzc1wiLCBcIm51bWJlclwiLCBcIm51bWJlclwiKTtcclxuXHJcbiAgICAvL0NoYW5nZWQgZm9yIHRlc3RpbmdcclxuICAgIHJldHVybiBuZXcgUGFydGljbGUob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy5zaXplLCBvcHRpb25zLm1hc3MpO1xyXG4gIH1cclxuXHJcbiAgYnVpbGRMaW5lKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUG9pbnQge1xyXG4gICAgdGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkxpbmVcIiwgb3B0aW9ucywgXCJzdGFydFwiLCBWZWMyLCBcIlZlYzJcIik7XHJcbiAgICB0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiTGluZVwiLCBvcHRpb25zLCBcImVuZFwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBMaW5lKG9wdGlvbnMuc3RhcnQsIG9wdGlvbnMuZW5kKTtcclxuICB9XHJcblxyXG4gIGJ1aWxkUmVjdChvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY3Qge1xyXG4gICAgdGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlJlY3RcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XHJcbiAgICB0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUmVjdFwiLCBvcHRpb25zLCBcInNpemVcIiwgVmVjMiwgXCJWZWMyXCIpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUmVjdChvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLnNpemUpO1xyXG4gIH1cclxuXHJcbiAgLyogLS0tLS0tLS0tLSBFUlJPUiBIQU5ETElORyAtLS0tLS0tLS0tICovXHJcblxyXG4gIGNoZWNrSWZQcm9wRXhpc3RzPFQ+KFxyXG4gICAgb2JqZWN0TmFtZTogc3RyaW5nLFxyXG4gICAgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PixcclxuICAgIHByb3A6IHN0cmluZyxcclxuICAgIHR5cGU6IChuZXcgKC4uLmFyZ3M6IGFueSkgPT4gVCkgfCBzdHJpbmcsXHJcbiAgICB0eXBlTmFtZT86IHN0cmluZyxcclxuICApIHtcclxuICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zW3Byb3BdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgb3B0aW9ucyBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eVxyXG4gICAgICB0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZU5hbWV9LCBidXQgbm9uZSB3YXMgcHJvdmlkZWQuYDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHByb3BlcnR5IGhhcyB0aGUgY29ycmVjdCB0eXBlXHJcbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGlmICghKHR5cGVvZiBvcHRpb25zW3Byb3BdID09PSB0eXBlKSkge1xyXG4gICAgICAgICAgdGhyb3cgYCR7b2JqZWN0TmFtZX0gb2JqZWN0IHJlcXVpcmVzIGFyZ3VtZW50ICR7cHJvcH0gb2YgdHlwZSAke3R5cGV9LCBidXQgcHJvdmlkZWQgJHtwcm9wfSB3YXMgbm90IG9mIHR5cGUgJHt0eXBlfS5gO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAvLyBJZiB0eXBlIGlzIGEgY29uc3RydWN0b3IsIGNoZWNrIGFnYWluc3QgdGhhdFxyXG4gICAgICAgIGlmICghKG9wdGlvbnNbcHJvcF0gaW5zdGFuY2VvZiB0eXBlKSkge1xyXG4gICAgICAgICAgdGhyb3cgYCR7b2JqZWN0TmFtZX0gb2JqZWN0IHJlcXVpcmVzIGFyZ3VtZW50ICR7cHJvcH0gb2YgdHlwZSAke3R5cGVOYW1lfSwgYnV0IHByb3ZpZGVkICR7cHJvcH0gd2FzIG5vdCBvZiB0eXBlICR7dHlwZU5hbWV9LmA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IGAke29iamVjdE5hbWV9IG9iamVjdCByZXF1aXJlcyBhcmd1bWVudCAke3Byb3B9IG9mIHR5cGUgJHt0eXBlTmFtZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGVOYW1lfS5gO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcclxuaW1wb3J0IENhbnZhc05vZGVGYWN0b3J5IGZyb20gXCIuL0NhbnZhc05vZGVGYWN0b3J5XCI7XHJcbmltcG9ydCBUaWxlbWFwRmFjdG9yeSBmcm9tIFwiLi9UaWxlbWFwRmFjdG9yeVwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcclxuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50XCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xyXG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY1wiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vTGF5ZXJcIjtcclxuXHJcbmludGVyZmFjZSBVSUVsZW1lbnRPcHRpb25zIHtcclxuICBwb3NpdGlvbjogVmVjMjtcclxuICB0ZXh0Pzogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIG1hbmFnZXIgb2YgYWxsIGZhY3RvcmllcyB1c2VkIGZvciBhZGRpbmcgQHJlZmVyZW5jZVtHYW1lTm9kZV1zIHRvIHRoZSBAcmVmZXJlbmNlW1NjZW5lXS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhY3RvcnlNYW5hZ2VyIHtcclxuICAvLyBDb25zdHJ1Y3RvcnMgYXJlIGNhbGxlZCBoZXJlIHRvIGFsbG93IGFzc2lnbm1lbnQgb2YgdGhlaXIgZnVuY3Rpb25zIHRvIGZ1bmN0aW9ucyBpbiB0aGlzIGNsYXNzXHJcbiAgcHJpdmF0ZSBjYW52YXNOb2RlRmFjdG9yeTogQ2FudmFzTm9kZUZhY3RvcnkgPSBuZXcgQ2FudmFzTm9kZUZhY3RvcnkoKTtcclxuICBwcml2YXRlIHRpbGVtYXBGYWN0b3J5OiBUaWxlbWFwRmFjdG9yeSA9IG5ldyBUaWxlbWFwRmFjdG9yeSgpO1xyXG5cclxuICBjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPikge1xyXG4gICAgdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5pbml0KHNjZW5lKTtcclxuICAgIHRoaXMudGlsZW1hcEZhY3RvcnkuaW5pdChzY2VuZSwgdGlsZW1hcHMpO1xyXG4gIH1cclxuXHJcbiAgLy8gRXhwb3NlIGFsbCBvZiB0aGUgZmFjdG9yaWVzIHRocm91Z2ggdGhlIGZhY3RvcnkgbWFuYWdlclxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYW4gaW5zdGFuY2Ugb2YgYSBVSUVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgc2NlbmUgLSBpLmUuIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgVUlFbGVtZW50XHJcbiAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgVUlFbGVtZW50IHRvIGFkZFxyXG4gICAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIHRvIGFkZCB0aGUgVUlFbGVtZW50IHRvXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGZlZWQgdG8gdGhlIGNvbnN0cnVjdG9yXHJcbiAgICogQHJldHVybnMgQSBuZXcgVUlFbGVtZW50XHJcbiAgICovXHJcbiAgdWlFbGVtZW50KFxyXG4gICAgdHlwZTogc3RyaW5nIHwgVUlFbGVtZW50VHlwZSxcclxuICAgIGxheWVyTmFtZTogc3RyaW5nLFxyXG4gICAgb3B0aW9ucz86IFVJRWxlbWVudE9wdGlvbnMsXHJcbiAgKTogVUlFbGVtZW50IHtcclxuICAgIHJldHVybiB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmFkZFVJRWxlbWVudCh0eXBlLCBsYXllck5hbWUsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIHNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxyXG4gICAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgc3ByaXRlXHJcbiAgICogQHJldHVybnMgQSBuZXcgU3ByaXRlXHJcbiAgICovXHJcbiAgc3ByaXRlKGtleTogc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZyk6IFNwcml0ZSB7XHJcbiAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRTcHJpdGUoa2V5LCBsYXllck5hbWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhbiBBbmltYXRlZFNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxyXG4gICAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgc3ByaXRlXHJcbiAgICogQHJldHVybnMgQSBuZXcgQW5pbWF0ZWRTcHJpdGVcclxuICAgKi9cclxuICBhbmltYXRlZFNwcml0ZShrZXk6IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcpOiBBbmltYXRlZFNwcml0ZSB7XHJcbiAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRBbmltYXRlZFNwcml0ZShrZXksIGxheWVyTmFtZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgbmV3IGdyYXBoaWMgZWxlbWVudCB0byB0aGUgY3VycmVudCBTY2VuZVxyXG4gICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGdyYXBoaWMgdG8gYWRkXHJcbiAgICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBncmFwaGljXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIGdyYXBoaWMgY29uc3RydWN0b3JcclxuICAgKiBAcmV0dXJucyBBIG5ldyBHcmFwaGljXHJcbiAgICovXHJcbiAgZ3JhcGhpYyhcclxuICAgIHR5cGU6IEdyYXBoaWNUeXBlIHwgc3RyaW5nLFxyXG4gICAgbGF5ZXJOYW1lOiBzdHJpbmcsXHJcbiAgICBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55PixcclxuICApOiBHcmFwaGljIHtcclxuICAgIHJldHVybiB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmFkZEdyYXBoaWModHlwZSwgbGF5ZXJOYW1lLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSB0aWxlbWFwIHRvIHRoZSBzY2VuZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIHRpbGVtYXAgdG8gbG9hZFxyXG4gICAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkZXNpcmVkIHRpbGVtYXBcclxuICAgKiBAcGFyYW0gYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzZW5kIHRvIHRoZSB0aWxlbWFwIGNvbnN0cnVjdG9yXHJcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgTGF5ZXJzLCBlYWNoIG9mIHdoaWNoIGNvbnRhaW5zIGEgbGF5ZXIgb2YgdGhlIHRpbGVtYXAgYXMgaXRzIG93biBUaWxlbWFwIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIHRpbGVtYXAoa2V5OiBzdHJpbmcsIHNjYWxlPzogVmVjMik6IEFycmF5PExheWVyPiB7XHJcbiAgICByZXR1cm4gdGhpcy50aWxlbWFwRmFjdG9yeS5hZGQoa2V5LCBzY2FsZSk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcclxuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XHJcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vTGF5ZXJcIjtcclxuaW1wb3J0IFRpbGVzZXQgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgeyBUaWxlZENvbGxlY3Rpb25UaWxlIH0gZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcclxuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcclxuaW1wb3J0IFBvc2l0aW9uR3JhcGggZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9HcmFwaHMvUG9zaXRpb25HcmFwaFwiO1xyXG5pbXBvcnQgTmF2bWVzaCBmcm9tIFwiLi4vLi4vUGF0aGZpbmRpbmcvTmF2bWVzaFwiO1xyXG5cclxuLy8gQGlnbm9yZVBhZ2VcclxuXHJcbi8qKlxyXG4gKiBBIGZhY3RvcnkgdGhhdCBhYnN0cmFjdHMgYWRkaW5nIEByZWZlcmVuY2VbVGlsZW1hcF1zIHRvIHRoZSBAcmVmZXJlbmNlW1NjZW5lXS5cclxuICogQWNjZXNzIG1ldGhvZHMgaW4gdGhpcyBmYWN0b3J5IHRocm91Z2ggU2NlbmUuYWRkLlttZXRob2ROYW1lXSgpLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZW1hcEZhY3Rvcnkge1xyXG4gIHByaXZhdGUgc2NlbmU6IFNjZW5lO1xyXG4gIHByaXZhdGUgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xyXG4gIHByaXZhdGUgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XHJcblxyXG4gIGluaXQoc2NlbmU6IFNjZW5lLCB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD4pOiB2b2lkIHtcclxuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgIHRoaXMudGlsZW1hcHMgPSB0aWxlbWFwcztcclxuICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPIC0gVGhpcyBpcyBzcGVjaWZpY2FsbHkgY2F0ZXJlZCB0byBUaWxlZCB0aWxlbWFwcyByaWdodCBub3cuIEluIHRoZSBmdXR1cmUsXHJcbiAgLy8gaXQgd291bGQgYmUgZ29vZCB0byBoYXZlIGEgXCJwYXJzZVRpbGVtYXBcIiBmdW5jdGlvbiB0aGF0IHdvdWxkIGNvbnZlcnQgdGhlIHRpbGVtYXBcclxuICAvLyBkYXRhIGludG8gYSBzdGFuZGFyZCBmb3JtYXQuIFRoaXMgY291bGQgYWxsb3cgZm9yIHN1cHBvcnQgZnJvbSBvdGhlciBwcm9ncmFtc1xyXG4gIC8vIG9yIHRoZSBkZXZlbG9wbWVudCBvZiBhbiBpbnRlcm5hbCBsZXZlbCBidWlsZGVyIHRvb2xcclxuICAvKipcclxuICAgKiBBZGRzIGEgdGlsZW1hcCB0byB0aGUgc2NlbmVcclxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwIHRvIGxvYWRcclxuICAgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGVzaXJlZCB0aWxlbWFwXHJcbiAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc2VuZCB0byB0aGUgdGlsZW1hcCBjb25zdHJ1Y3RvclxyXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIExheWVycywgZWFjaCBvZiB3aGljaCBjb250YWlucyBhIGxheWVyIG9mIHRoZSB0aWxlbWFwIGFzIGl0cyBvd24gVGlsZW1hcCBpbnN0YW5jZS5cclxuICAgKi9cclxuICBhZGQgPSAoa2V5OiBzdHJpbmcsIHNjYWxlOiBWZWMyID0gbmV3IFZlYzIoMSwgMSkpOiBBcnJheTxMYXllcj4gPT4ge1xyXG4gICAgLy8gR2V0IFRpbGVtYXAgRGF0YVxyXG4gICAgbGV0IHRpbGVtYXBEYXRhID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0VGlsZW1hcChrZXkpO1xyXG5cclxuICAgIC8vIFNldCB0aGUgY29uc3RydWN0b3IgZm9yIHRoaXMgdGlsZW1hcCB0byBlaXRoZXIgYmUgb3J0aG9ncmFwaGljIG9yIGlzb21ldHJpY1xyXG4gICAgbGV0IGNvbnN0cjogbmV3ICguLi5hcmdzOiBhbnkpID0+IFRpbGVtYXA7XHJcbiAgICBpZiAodGlsZW1hcERhdGEub3JpZW50YXRpb24gPT09IFwib3J0aG9ncmFwaGljXCIpIHtcclxuICAgICAgY29uc3RyID0gT3J0aG9nb25hbFRpbGVtYXA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBObyBpc29tZXRyaWMgdGlsZW1hcCBzdXBwb3J0IHJpZ2h0IG5vdywgc28gT3J0aG9ncmFwaGljIHRpbGVtYXBcclxuICAgICAgY29uc3RyID0gT3J0aG9nb25hbFRpbGVtYXA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcmV0dXJuIHZhbHVlIGFycmF5XHJcbiAgICBsZXQgc2NlbmVMYXllcnMgPSBuZXcgQXJyYXk8TGF5ZXI+KCk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGFsbCBvZiB0aGUgdGlsZXNldHMgZm9yIHRoaXMgdGlsZW1hcFxyXG4gICAgbGV0IHRpbGVzZXRzID0gbmV3IEFycmF5PFRpbGVzZXQ+KCk7XHJcblxyXG4gICAgbGV0IGNvbGxlY3Rpb25UaWxlcyA9IG5ldyBBcnJheTxUaWxlZENvbGxlY3Rpb25UaWxlPigpO1xyXG5cclxuICAgIGZvciAobGV0IHRpbGVzZXQgb2YgdGlsZW1hcERhdGEudGlsZXNldHMpIHtcclxuICAgICAgaWYgKHRpbGVzZXQuaW1hZ2UpIHtcclxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc3RhbmRhcmQgdGlsZXNldCBhbmQgbm90IGEgY29sbGVjdGlvbiwgY3JlYXRlIGEgdGlsZXNldCBmb3IgaXQuXHJcbiAgICAgICAgLy8gVE9ETyAtIFdlIGFyZSBpZ25vcmluZyBjb2xsZWN0aW9uIHRpbGVzZXRzIGZvciBub3cuIFRoaXMgaXMgbGlrZWx5IG5vdCBhIGdyZWF0IGlkZWEgaW4gcHJhY3RpY2UsXHJcbiAgICAgICAgLy8gYXMgdGhlb3JldGljYWxseSBzb21lb25lIGNvdWxkIHdhbnQgdG8gdXNlIG9uZSBmb3IgYSBzdGFuZGFyZCB0aWxlbWFwLiBXZSBhcmUgYXNzdW1pbmcgZm9yIG5vd1xyXG4gICAgICAgIC8vIHRoYXQgd2Ugb25seSB3YW50IHRvIHVzZSB0aGVtIGZvciBvYmplY3QgbGF5ZXJzXHJcbiAgICAgICAgdGlsZXNldHMucHVzaChuZXcgVGlsZXNldCh0aWxlc2V0KSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGlsZXNldC50aWxlcy5mb3JFYWNoKHRpbGUgPT4gKHRpbGUuaWQgKz0gdGlsZXNldC5maXJzdGdpZCkpO1xyXG4gICAgICAgIGNvbGxlY3Rpb25UaWxlcy5wdXNoKC4uLnRpbGVzZXQudGlsZXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9vcCBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIHRpbGVtYXAgYW5kIGNyZWF0ZSB0aWxlZGxheWVycyBvciBvYmplY3QgbGF5ZXJzXHJcbiAgICBmb3IgKGxldCBsYXllciBvZiB0aWxlbWFwRGF0YS5sYXllcnMpIHtcclxuICAgICAgbGV0IHNjZW5lTGF5ZXI7XHJcbiAgICAgIGxldCBpc1BhcmFsbGF4TGF5ZXIgPSBmYWxzZTtcclxuICAgICAgbGV0IGRlcHRoID0gMDtcclxuXHJcbiAgICAgIGlmIChsYXllci5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgcHJvcCBvZiBsYXllci5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICBpZiAocHJvcC5uYW1lID09PSBcIlBhcmFsbGF4XCIpIHtcclxuICAgICAgICAgICAgaXNQYXJhbGxheExheWVyID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAocHJvcC5uYW1lID09PSBcIkRlcHRoXCIpIHtcclxuICAgICAgICAgICAgZGVwdGggPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzUGFyYWxsYXhMYXllcikge1xyXG4gICAgICAgIHNjZW5lTGF5ZXIgPSB0aGlzLnNjZW5lLmFkZFBhcmFsbGF4TGF5ZXIoXHJcbiAgICAgICAgICBsYXllci5uYW1lLFxyXG4gICAgICAgICAgbmV3IFZlYzIoMSwgMSksXHJcbiAgICAgICAgICBkZXB0aCxcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNjZW5lTGF5ZXIgPSB0aGlzLnNjZW5lLmFkZExheWVyKGxheWVyLm5hbWUsIGRlcHRoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGxheWVyLnR5cGUgPT09IFwidGlsZWxheWVyXCIpIHtcclxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgdGlsZW1hcCBvYmplY3QgZm9yIHRoZSBsYXllclxyXG4gICAgICAgIGxldCB0aWxlbWFwID0gbmV3IGNvbnN0cih0aWxlbWFwRGF0YSwgbGF5ZXIsIHRpbGVzZXRzLCBzY2FsZSk7XHJcbiAgICAgICAgdGlsZW1hcC5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xyXG4gICAgICAgIHRpbGVtYXAuc2V0U2NlbmUodGhpcy5zY2VuZSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aWxlbWFwIHRvIHNjZW5lXHJcbiAgICAgICAgdGhpcy50aWxlbWFwcy5wdXNoKHRpbGVtYXApO1xyXG5cclxuICAgICAgICBzY2VuZUxheWVyLmFkZE5vZGUodGlsZW1hcCk7XHJcblxyXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRpbGVtYXAgd2l0aCBwaHlzaWNzIGlmIGl0J3MgY29sbGlkYWJsZVxyXG4gICAgICAgIGlmICh0aWxlbWFwLmlzQ29sbGlkYWJsZSkge1xyXG4gICAgICAgICAgdGlsZW1hcC5hZGRQaHlzaWNzKCk7XHJcblxyXG4gICAgICAgICAgaWYgKGxheWVyLnByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBsYXllci5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZSA9PT0gXCJHcm91cFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aWxlbWFwLnNldEdyb3VwKGl0ZW0udmFsdWUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgaXNOYXZtZXNoUG9pbnRzID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IG5hdm1lc2hOYW1lO1xyXG4gICAgICAgIGxldCBlZGdlcztcclxuICAgICAgICBpZiAobGF5ZXIucHJvcGVydGllcykge1xyXG4gICAgICAgICAgZm9yIChsZXQgcHJvcCBvZiBsYXllci5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wLm5hbWUgPT09IFwiTmF2bWVzaFBvaW50c1wiKSB7XHJcbiAgICAgICAgICAgICAgaXNOYXZtZXNoUG9pbnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wLm5hbWUgPT09IFwibmFtZVwiKSB7XHJcbiAgICAgICAgICAgICAgbmF2bWVzaE5hbWUgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AubmFtZSA9PT0gXCJlZGdlc1wiKSB7XHJcbiAgICAgICAgICAgICAgZWRnZXMgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNOYXZtZXNoUG9pbnRzKSB7XHJcbiAgICAgICAgICBsZXQgZyA9IG5ldyBQb3NpdGlvbkdyYXBoKCk7XHJcblxyXG4gICAgICAgICAgZm9yIChsZXQgb2JqIG9mIGxheWVyLm9iamVjdHMpIHtcclxuICAgICAgICAgICAgZy5hZGRQb3NpdGlvbmVkTm9kZShuZXcgVmVjMihvYmoueCwgb2JqLnkpKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKGxldCBlZGdlIG9mIGVkZ2VzKSB7XHJcbiAgICAgICAgICAgIGcuYWRkRWRnZShlZGdlLmZyb20sIGVkZ2UudG8pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuc2NlbmVcclxuICAgICAgICAgICAgLmdldE5hdmlnYXRpb25NYW5hZ2VyKClcclxuICAgICAgICAgICAgLmFkZE5hdmlnYWJsZUVudGl0eShuYXZtZXNoTmFtZSwgbmV3IE5hdm1lc2goZykpO1xyXG5cclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTGF5ZXIgaXMgYW4gb2JqZWN0IGxheWVyLCBzbyBhZGQgZWFjaCBvYmplY3QgYXMgYSBzcHJpdGUgdG8gYSBuZXcgbGF5ZXJcclxuICAgICAgICBmb3IgKGxldCBvYmogb2YgbGF5ZXIub2JqZWN0cykge1xyXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgb2JqIGlzIGNvbGxpZGFibGVcclxuICAgICAgICAgIGxldCBoYXNQaHlzaWNzID0gZmFsc2U7XHJcbiAgICAgICAgICBsZXQgaXNDb2xsaWRhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICBsZXQgaXNUcmlnZ2VyID0gZmFsc2U7XHJcbiAgICAgICAgICBsZXQgb25FbnRlciA9IG51bGw7XHJcbiAgICAgICAgICBsZXQgb25FeGl0ID0gbnVsbDtcclxuICAgICAgICAgIGxldCB0cmlnZ2VyR3JvdXAgPSBudWxsO1xyXG4gICAgICAgICAgbGV0IGdyb3VwID0gXCJcIjtcclxuXHJcbiAgICAgICAgICBpZiAob2JqLnByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBvZiBvYmoucHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgIGlmIChwcm9wLm5hbWUgPT09IFwiSGFzUGh5c2ljc1wiKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNQaHlzaWNzID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AubmFtZSA9PT0gXCJDb2xsaWRhYmxlXCIpIHtcclxuICAgICAgICAgICAgICAgIGlzQ29sbGlkYWJsZSA9IHByb3AudmFsdWU7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wLm5hbWUgPT09IFwiR3JvdXBcIikge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXAgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcC5uYW1lID09PSBcIklzVHJpZ2dlclwiKSB7XHJcbiAgICAgICAgICAgICAgICBpc1RyaWdnZXIgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcC5uYW1lID09PSBcIlRyaWdnZXJHcm91cFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyR3JvdXAgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcC5uYW1lID09PSBcIlRyaWdnZXJPbkVudGVyXCIpIHtcclxuICAgICAgICAgICAgICAgIG9uRW50ZXIgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcC5uYW1lID09PSBcIlRyaWdnZXJPbkV4aXRcIikge1xyXG4gICAgICAgICAgICAgICAgb25FeGl0ID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBsZXQgc3ByaXRlOiBTcHJpdGU7XHJcblxyXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgb2JqIGlzIGEgdGlsZSBmcm9tIGEgdGlsZXNldFxyXG4gICAgICAgICAgZm9yIChsZXQgdGlsZXNldCBvZiB0aWxlc2V0cykge1xyXG4gICAgICAgICAgICBpZiAodGlsZXNldC5oYXNUaWxlKG9iai5naWQpKSB7XHJcbiAgICAgICAgICAgICAgLy8gVGhlIG9iamVjdCBpcyBhIHRpbGUgZnJvbSB0aGlzIHNldFxyXG4gICAgICAgICAgICAgIGxldCBpbWFnZUtleSA9IHRpbGVzZXQuZ2V0SW1hZ2VLZXkoKTtcclxuICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdGlsZXNldC5nZXRJbWFnZU9mZnNldEZvclRpbGUob2JqLmdpZCk7XHJcbiAgICAgICAgICAgICAgc3ByaXRlID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKGltYWdlS2V5LCBsYXllci5uYW1lKTtcclxuICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi5zZXQoXHJcbiAgICAgICAgICAgICAgICAob2JqLnggKyBzaXplLnggLyAyKSAqIHNjYWxlLngsXHJcbiAgICAgICAgICAgICAgICAob2JqLnkgLSBzaXplLnkgLyAyKSAqIHNjYWxlLnksXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICBzcHJpdGUuc2V0SW1hZ2VPZmZzZXQob2Zmc2V0KTtcclxuICAgICAgICAgICAgICBzcHJpdGUuc2l6ZS5jb3B5KHNpemUpO1xyXG4gICAgICAgICAgICAgIHNwcml0ZS5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOb3QgaW4gYSB0aWxlc2V0LCBtdXN0IGNvcnJlc3BvbmQgdG8gYSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICBpZiAoIXNwcml0ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0aWxlIG9mIGNvbGxlY3Rpb25UaWxlcykge1xyXG4gICAgICAgICAgICAgIGlmIChvYmouZ2lkID09PSB0aWxlLmlkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW1hZ2VLZXkgPSB0aWxlLmltYWdlO1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKGltYWdlS2V5LCBsYXllci5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi5zZXQoXHJcbiAgICAgICAgICAgICAgICAgIChvYmoueCArIHRpbGUuaW1hZ2V3aWR0aCAvIDIpICogc2NhbGUueCxcclxuICAgICAgICAgICAgICAgICAgKG9iai55IC0gdGlsZS5pbWFnZWhlaWdodCAvIDIpICogc2NhbGUueSxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUuc2NhbGUuc2V0KHNjYWxlLngsIHNjYWxlLnkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIHNwcml0ZS4gQXNzb2NpYXRlIGl0IHdpdGggb3VyIHBoeXNpY3Mgb2JqZWN0IGlmIHRoZXJlIGlzIG9uZVxyXG4gICAgICAgICAgaWYgKGhhc1BoeXNpY3MpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgc3ByaXRlIGEgc3RhdGljIHBoeXNpY3Mgb2JqZWN0XHJcbiAgICAgICAgICAgIHNwcml0ZS5hZGRQaHlzaWNzKFxyXG4gICAgICAgICAgICAgIHNwcml0ZS5ib3VuZGFyeS5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgIFZlYzIuWkVSTyxcclxuICAgICAgICAgICAgICBpc0NvbGxpZGFibGUsXHJcbiAgICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgc3ByaXRlLnNldEdyb3VwKGdyb3VwKTtcclxuICAgICAgICAgICAgaWYgKGlzVHJpZ2dlciAmJiB0cmlnZ2VyR3JvdXAgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICBzcHJpdGUuc2V0VHJpZ2dlcih0cmlnZ2VyR3JvdXAsIG9uRW50ZXIsIG9uRXhpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcmV0dXJuIHZhbHVlXHJcbiAgICAgIHNjZW5lTGF5ZXJzLnB1c2goc2NlbmVMYXllcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNjZW5lTGF5ZXJzO1xyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuL1NjZW5lXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XHJcblxyXG4vKipcclxuICogQSBsYXllciBpbiB0aGUgc2NlbmUuIExheWVycyBhcmUgdXNlZCBmb3Igc29ydGluZyBAcmVmZXJlbmNlW0dhbWVOb2RlXXMgYnkgZGVwdGguXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllciB7XHJcbiAgLyoqIFRoZSBzY2VuZSB0aGlzIGxheWVyIGJlbG9uZ3MgdG8gKi9cclxuICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xyXG5cclxuICAvKiogVGhlIG5hbWUgb2YgdGhpcyBsYXllciAqL1xyXG4gIHByb3RlY3RlZCBuYW1lOiBzdHJpbmc7XHJcblxyXG4gIC8qKiBXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgcGF1c2VkIG9yIG5vdCAqL1xyXG4gIHByb3RlY3RlZCBwYXVzZWQ6IGJvb2xlYW47XHJcblxyXG4gIC8qKiBXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgaGlkZGVuIGZyb20gYmVpbmcgcmVuZGVyZWQgb3Igbm90ICovXHJcbiAgcHJvdGVjdGVkIGhpZGRlbjogYm9vbGVhbjtcclxuXHJcbiAgLyoqIFRoZSBnbG9iYWwgYWxwaGEgbGV2ZWwgb2YgdGhpcyBsYXllciAqL1xyXG4gIHByb3RlY3RlZCBhbHBoYTogbnVtYmVyO1xyXG5cclxuICAvKiogQW4gYXJyYXkgb2YgdGhlIEdhbWVOb2RlcyB0aGF0IGJlbG9uZyB0byB0aGlzIGxheWVyICovXHJcbiAgcHJvdGVjdGVkIGl0ZW1zOiBBcnJheTxHYW1lTm9kZT47XHJcblxyXG4gIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGxheWVyIHNob3VsZCBiZSB5c29ydGVkICovXHJcbiAgcHJvdGVjdGVkIHlTb3J0OiBib29sZWFuO1xyXG5cclxuICAvKiogVGhlIGRlcHRoIG9mIHRoaXMgbGF5ZXIgY29tcGFyZWQgdG8gb3RoZXIgbGF5ZXJzICovXHJcbiAgcHJvdGVjdGVkIGRlcHRoOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgbGF5ZXIuIFRvIGRvIHRoaXMgaW4gYSBnYW1lLCB1c2UgdGhlIGFkZExheWVyKCkgbWV0aG9kIGluIEByZWZyZW5jZVtTY2VuZV1cclxuICAgKiBAcGFyYW0gc2NlbmUgVGhlIHNjZW5lIHRvIGFkZCB0aGUgbGF5ZXIgdG9cclxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIG5hbWU6IHN0cmluZykge1xyXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgdGhpcy5hbHBoYSA9IDE7XHJcbiAgICB0aGlzLml0ZW1zID0gbmV3IEFycmF5KCk7XHJcbiAgICB0aGlzLnlTb3J0ID0gZmFsc2U7XHJcbiAgICB0aGlzLmRlcHRoID0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJlaXZlcyB0aGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICAgKiBAcmV0dXJucyBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICAgKi9cclxuICBnZXROYW1lKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2VzL1VucGF1c2VzIHRoZSBsYXllci4gQWZmZWN0cyBhbGwgZWxlbWVudHMgaW4gdGhpcyBsYXllclxyXG4gICAqIEBwYXJhbSBwYXVzZVZhbHVlIFRydWUgaWYgdGhlIGxheWVyIHNob3VsZCBiZSBwYXVzZWQsIGZhbHNlIGlmIG5vdFxyXG4gICAqL1xyXG4gIHNldFBhdXNlZChwYXVzZVZhbHVlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICB0aGlzLnBhdXNlZCA9IHBhdXNlVmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBsYXllciBpcyBwYXVzZWRcclxuICAgKi9cclxuICBpc1BhdXNlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLnBhdXNlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyXHJcbiAgICogQHBhcmFtIGFscGhhIFRoZSBuZXcgb3BhY2l0eSB2YWx1ZSBpbiB0aGUgcmFuZ2UgWzAsIDFdXHJcbiAgICovXHJcbiAgc2V0QWxwaGEoYWxwaGE6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5hbHBoYSA9IE1hdGhVdGlscy5jbGFtcChhbHBoYSwgMCwgMSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBsYXllclxyXG4gICAqIEByZXR1cm5zIFRoZSBvcGFjaXR5XHJcbiAgICovXHJcbiAgZ2V0QWxwaGEoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmFscGhhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgbGF5ZXIncyBoaWRkZW4gdmFsdWUuIElmIGhpZGRlbiwgYSBsYXllciB3aWxsIG5vdCBiZSByZW5kZXJlZCwgYnV0IHdpbGwgc3RpbGwgdXBkYXRlXHJcbiAgICogQHBhcmFtIGhpZGRlbiBUaGUgaGlkZGVuIHZhbHVlIG9mIHRoZSBsYXllclxyXG4gICAqL1xyXG4gIHNldEhpZGRlbihoaWRkZW46IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIHRoaXMuaGlkZGVuID0gaGlkZGVuO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgaGlkZWVuIHZhbHVlIG9mIHRoZSBseWFlclxyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHNjZW5lIGlzIGhpZGRlbiwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgaXNIaWRkZW4oKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWRkZW47XHJcbiAgfVxyXG5cclxuICAvKiogUGF1c2VzIHRoaXMgc2NlbmUgYW5kIGhpZGVzIGl0ICovXHJcbiAgZGlzYWJsZSgpOiB2b2lkIHtcclxuICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcclxuICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKiBVbnBhdXNlcyB0aGlzIGxheWVyIGFuZCBtYWtlcyBpdCB2aXNpYmxlICovXHJcbiAgZW5hYmxlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBzY2VuZSB3aWxsIHlTb3J0IGF1dG9tYXRpY2FsbHkuXHJcbiAgICogeVNvcnRpbmcgbWVhbnMgdGhhdCBDYW52YXNOb2RlcyBvbiB0aGlzIGxheWVyIHdpbGwgaGF2ZSB0aGVpciBkZXB0aCBzb3J0ZWQgZGVwZW5kaW5nIG9uIHRoZWlyIHktdmFsdWUuXHJcbiAgICogVGhpcyBtZWFucyB0aGF0IGlmIGFuIG9iamVjdCBpcyBcImhpZ2hlclwiIGluIHRoZSBzY2VuZSwgaXQgd2lsbCBzb3J0IGJlaGluZCBvYmplY3RzIHRoYXQgYXJlIFwibG93ZXJcIi5cclxuICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgMy80IHZpZXcgZ2FtZXMsIG9yIHNpbWlsYXIgc2l0dWF0aW9ucywgd2hlcmUgeW91IHNvbWV0aW1lcyB3YW50IHRvIGJlIGluIGZyb250IG9mIG9iamVjdHMsXHJcbiAgICogYW5kIG90aGVyIHRpbWVzIHdhbnQgdG8gYmUgYmVoaW5kIHRoZSBzYW1lIG9iamVjdHMuXHJcbiAgICogQHBhcmFtIHlTb3J0IFRydWUgaWYgeVNvcnRpbmcgc2hvdWxkIGJlIGFjdGl2ZSwgZmFsc2UgaWYgbm90XHJcbiAgICovXHJcbiAgc2V0WVNvcnQoeVNvcnQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIHRoaXMueVNvcnQgPSB5U29ydDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHlTb3J0IHN0YXR1cyBvZiB0aGUgc2NlbmVcclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHlTb3J0aW5nIGlzIG9jY3VycmluZywgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgZ2V0WVNvcnQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy55U29ydDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGRlcHRoIG9mIHRoZSBsYXllciBjb21wYXJlZCB0byBvdGhlciBsYXllcnMuIEEgbGFyZ2VyIG51bWJlciBtZWFucyB0aGUgbGF5ZXIgd2lsbCBiZSBjbG9zZXIgdG8gdGhlIHNjcmVlbi5cclxuICAgKiBAcGFyYW0gZGVwdGggVGhlIGRlcHRoIG9mIHRoZSBsYXllci5cclxuICAgKi9cclxuICBzZXREZXB0aChkZXB0aDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLmRlcHRoID0gZGVwdGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZXMgdGhlIGRlcHRoIG9mIHRoZSBsYXllci5cclxuICAgKiBAcmV0dXJucyBUaGUgZGVwdGhcclxuICAgKi9cclxuICBnZXREZXB0aCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuZGVwdGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgbm9kZSB0byB0aGlzIGxheWVyXHJcbiAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gYWRkIHRvIHRoaXMgbGF5ZXIuXHJcbiAgICovXHJcbiAgYWRkTm9kZShub2RlOiBHYW1lTm9kZSk6IHZvaWQge1xyXG4gICAgdGhpcy5pdGVtcy5wdXNoKG5vZGUpO1xyXG4gICAgbm9kZS5zZXRMYXllcih0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhpcyBsYXllclxyXG4gICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxyXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgd2FzIHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIHJlbW92ZU5vZGUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcclxuICAgIC8vIEZpbmQgYW5kIHJlbW92ZSB0aGUgbm9kZVxyXG4gICAgbGV0IGluZGV4ID0gdGhpcy5pdGVtcy5pbmRleE9mKG5vZGUpO1xyXG5cclxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICBub2RlLnNldExheWVyKHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyZWl2ZXMgYWxsIEdhbWVOb2RlcyBmcm9tIHRoaXMgbGF5ZXJcclxuICAgKiBAcmV0dXJucyBhbiBBcnJheSB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGUgR2FtZU5vZGVzIGluIHRoaXMgbGF5ZXIuXHJcbiAgICovXHJcbiAgZ2V0SXRlbXMoKTogQXJyYXk8R2FtZU5vZGU+IHtcclxuICAgIHJldHVybiB0aGlzLml0ZW1zO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgTGF5ZXIgZnJvbSBcIi4uL0xheWVyXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XHJcblxyXG4vKipcclxuICogQW4gZXh0ZW5zaW9uIG9mIGEgTGF5ZXIgdGhhdCBoYXMgYSBwYXJhbGxheCB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcmFsbGF4TGF5ZXIgZXh0ZW5kcyBMYXllciB7XHJcbiAgLyoqIFRoZSB2YWx1ZSBvZiB0aGUgcGFyYWxsYXggb2YgdGhlIExheWVyICovXHJcbiAgcGFyYWxsYXg6IFZlYzI7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgUGFyYWxsYXhMYXllci5cclxuICAgKiBVc2UgYWRkUGFyYWxsYXhMYXllcigpIGluIEByZWZlcmVuY2VbU2NlbmVdIHRvIGFkZCBhIGxheWVyIG9mIHRoaXMgdHlwZSB0byB5b3VyIGdhbWUuXHJcbiAgICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0byBhZGQgdGhpcyBQYXJhbGxheExheWVyIHRvXHJcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFBhcmFsbGF4TGF5ZXJcclxuICAgKiBAcGFyYW0gcGFyYWxsYXggVGhlIHBhcmFsbGF4IGxldmVsXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCBuYW1lOiBzdHJpbmcsIHBhcmFsbGF4OiBWZWMyKSB7XHJcbiAgICBzdXBlcihzY2VuZSwgbmFtZSk7XHJcbiAgICB0aGlzLnBhcmFsbGF4ID0gcGFyYWxsYXg7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XHJcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuL1BhcmFsbGF4TGF5ZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBBIExheWVyIHN0cmljdGx5IHRvIGJlIHVzZWQgZm9yIG1hbmFnaW5nIFVJRWxlbWVudHMuXHJcbiAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYSBMYXllciB0aGF0IGFsd2F5cyBzdGF5cyBpbiB0aGUgc2FtZSBwbGFjZSxcclxuICogYW5kIHRodXMgcmVuZGVycyB0aGluZ3MgbGlrZSBhIEhVRCBvciBhbiBpbnZlbnRvcnkgd2l0aG91dCB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIHRoZSBcXHJlZmVyZW5jZVtWaWV3cG9ydF0gc2Nyb2xsLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVUlMYXllciBleHRlbmRzIFBhcmFsbGF4TGF5ZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgVUlMYXllci5cclxuICAgKiBVc2UgYWRkVUlMYXllcigpIGluIEByZWZlcmVuY2VbU2NlbmVdIHRvIGFkZCBhIGxheWVyIG9mIHRoaXMgdHlwZSB0byB5b3VyIGdhbWUuXHJcbiAgICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0byBhZGQgdGhpcyBVSUxheWVyIHRvXHJcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFVJTGF5ZXJcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIG5hbWU6IHN0cmluZykge1xyXG4gICAgc3VwZXIoc2NlbmUsIG5hbWUsIFZlYzIuWkVSTyk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBMYXllciBmcm9tIFwiLi9MYXllclwiO1xyXG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBTY2VuZUdyYXBoIGZyb20gXCIuLi9TY2VuZUdyYXBoL1NjZW5lR3JhcGhcIjtcclxuaW1wb3J0IFBoeXNpY3NNYW5hZ2VyIGZyb20gXCIuLi9QaHlzaWNzL1BoeXNpY3NNYW5hZ2VyXCI7XHJcbmltcG9ydCBCYXNpY1BoeXNpY3NNYW5hZ2VyIGZyb20gXCIuLi9QaHlzaWNzL0Jhc2ljUGh5c2ljc01hbmFnZXJcIjtcclxuaW1wb3J0IFNjZW5lR3JhcGhBcnJheSBmcm9tIFwiLi4vU2NlbmVHcmFwaC9TY2VuZUdyYXBoQXJyYXlcIjtcclxuaW1wb3J0IEZhY3RvcnlNYW5hZ2VyIGZyb20gXCIuL0ZhY3Rvcmllcy9GYWN0b3J5TWFuYWdlclwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBHYW1lIGZyb20gXCIuLi9Mb29wL0dhbWVcIjtcclxuaW1wb3J0IFNjZW5lTWFuYWdlciBmcm9tIFwiLi9TY2VuZU1hbmFnZXJcIjtcclxuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uL0V2ZW50cy9FbWl0dGVyXCI7XHJcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XHJcbmltcG9ydCBOYXZpZ2F0aW9uTWFuYWdlciBmcm9tIFwiLi4vUGF0aGZpbmRpbmcvTmF2aWdhdGlvbk1hbmFnZXJcIjtcclxuaW1wb3J0IEFJTWFuYWdlciBmcm9tIFwiLi4vQUkvQUlNYW5hZ2VyXCI7XHJcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFBhcmFsbGF4TGF5ZXIgZnJvbSBcIi4vTGF5ZXJzL1BhcmFsbGF4TGF5ZXJcIjtcclxuaW1wb3J0IFVJTGF5ZXIgZnJvbSBcIi4vTGF5ZXJzL1VJTGF5ZXJcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgU2NlbmVPcHRpb25zIGZyb20gXCIuL1NjZW5lT3B0aW9uc1wiO1xyXG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXJcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgVGltZXJNYW5hZ2VyIGZyb20gXCIuLi9UaW1pbmcvVGltZXJNYW5hZ2VyXCI7XHJcbmltcG9ydCBUd2Vlbk1hbmFnZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9BbmltYXRpb25zL1R3ZWVuTWFuYWdlclwiO1xyXG5pbXBvcnQgUGFydGljbGVTeXN0ZW1NYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9QYXJ0aWNsZVN5c3RlbU1hbmFnZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBTY2VuZXMgYXJlIHRoZSBtYWluIGNvbnRhaW5lciBpbiB0aGUgZ2FtZSBlbmdpbmUuXHJcbiAqIFlvdXIgbWFpbiBzY2VuZSBpcyB0aGUgY3VycmVudCBsZXZlbCBvciBtZW51IG9mIHRoZSBnYW1lLCBhbmQgd2lsbCBjb250YWluIGFsbCBvZiB0aGUgR2FtZU5vZGVzIG5lZWRlZC5cclxuICogU2NlbmVzIHByb3ZpZGUgYW4gZWFzeSB3YXkgdG8gbG9hZCBhc3NldHMsIGFkZCBhc3NldHMgdG8gdGhlIGdhbWUgd29ybGQsIGFuZCB1bmxvYWQgYXNzZXRzLFxyXG4gKiBhbmQgaGF2ZSBsaWZlY3ljbGUgbWV0aG9kcyBleHBvc2VkIGZvciB0aGVzZSBmdW5jdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZSBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG4gIC8qKiBUaGUgc2l6ZSBvZiB0aGUgZ2FtZSB3b3JsZC4gKi9cclxuICBwcm90ZWN0ZWQgd29ybGRTaXplOiBWZWMyO1xyXG5cclxuICAvKiogVGhlIHZpZXdwb3J0LiAqL1xyXG4gIHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XHJcblxyXG4gIC8qKiBBIGZsYWcgdGhhdCByZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBzY2VuZSBpcyBydW5uaW5nIG9yIG5vdC4gKi9cclxuICBwcm90ZWN0ZWQgcnVubmluZzogYm9vbGVhbjtcclxuXHJcbiAgLyoqIFRoZSBtYW5hZ2VyIG9mIHRoaXMgc2NlbmUuICovXHJcbiAgcHJvdGVjdGVkIHNjZW5lTWFuYWdlcjogU2NlbmVNYW5hZ2VyO1xyXG5cclxuICAvKiogVGhlIHJlY2VpdmVyIGZvciB0aGlzIHNjZW5lLiAqL1xyXG4gIHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XHJcblxyXG4gIC8qKiBUaGUgZW1pdHRlciBmb3IgdGhpcyBzY2VuZS4gKi9cclxuICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcclxuXHJcbiAgLyoqIFRoaXMgbGlzdCBvZiB0aWxlbWFwcyBpbiB0aGlzIHNjZW5lLiAqL1xyXG4gIHByb3RlY3RlZCB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD47XHJcblxyXG4gIC8qKiBBIG1hcCBmcm9tIGxheWVyIG5hbWVzIHRvIHRoZSBsYXllcnMgdGhlbXNlbHZlcyAqL1xyXG4gIHByb3RlY3RlZCBsYXllcnM6IE1hcDxMYXllcj47XHJcblxyXG4gIC8qKiBBIG1hcCBmcm9tIHBhcmFsbGF4IGxheWVyIG5hbWVzIHRvIHRoZSBwYXJhbGxheCBsYXllcnMgdGhlbXNlbHZlcyAqL1xyXG4gIHByb3RlY3RlZCBwYXJhbGxheExheWVyczogTWFwPFBhcmFsbGF4TGF5ZXI+O1xyXG5cclxuICAvKiogQSBtYXAgZnJvbSB1aUxheWVyIG5hbWVzIHRvIHRoZSB1aUxheWVycyB0aGVtc2VsdmVzICovXHJcbiAgcHJvdGVjdGVkIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj47XHJcblxyXG4gIC8qKiBUaGUgc2NlbmUgZ3JhcGggb2YgdGhlIFNjZW5lKi9cclxuICBwcm90ZWN0ZWQgc2NlbmVHcmFwaDogU2NlbmVHcmFwaDtcclxuXHJcbiAgLyoqIFRoZSBwaHlzaWNzIG1hbmFnZXIgb2YgdGhlIFNjZW5lICovXHJcbiAgcHJvdGVjdGVkIHBoeXNpY3NNYW5hZ2VyOiBQaHlzaWNzTWFuYWdlcjtcclxuXHJcbiAgLyoqIFRoZSBuYXZpZ2F0aW9uIG1hbmFnZXIgb2YgdGhlIFNjZW5lICovXHJcbiAgcHJvdGVjdGVkIG5hdk1hbmFnZXI6IE5hdmlnYXRpb25NYW5hZ2VyO1xyXG5cclxuICAvKiogVGhlIEFJIG1hbmFnZXIgb2YgdGhlIFNjZW5lICovXHJcbiAgcHJvdGVjdGVkIGFpTWFuYWdlcjogQUlNYW5hZ2VyO1xyXG5cclxuICAvKiogVGhlIHJlbmRlcmluZ01hbmFnZXIgb2YgdGhlIHNjZW5lICovXHJcbiAgcHJvdGVjdGVkIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXI7XHJcblxyXG4gIC8qKiBBbiBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgdGhlIGFkZGluZyBvZiBkaWZmZXJlbnQgbm9kZXMgdG8gdGhlIHNjZW5lICovXHJcbiAgcHVibGljIGFkZDogRmFjdG9yeU1hbmFnZXI7XHJcblxyXG4gIC8qKiBBbiBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgdGhlIGxvYWRpbmcgb2YgZGlmZmVyZW50IGZpbGVzIGZvciB1c2UgaW4gdGhlIHNjZW5lLiBBbiBhbGlhcyBmb3IgcmVzb3VyY2VNYW5hZ2VyICovXHJcbiAgcHVibGljIGxvYWQ6IFJlc291cmNlTWFuYWdlcjtcclxuXHJcbiAgLyoqIEFuIGludGVyZmFjZSB0aGF0IGFsbG93cyB0aGUgbG9hZGluZyBhbmQgdW5sb2FkaW5nIG9mIGRpZmZlcmVudCBmaWxlcyBmb3IgdXNlIGluIHRoZSBzY2VuZSAqL1xyXG4gIHB1YmxpYyByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuXHJcbiAgLyoqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoaXMgc2NlbmUgKi9cclxuICBwdWJsaWMgc2NlbmVPcHRpb25zOiBTY2VuZU9wdGlvbnM7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgU2NlbmUuIFRvIGFkZCBhIG5ldyBTY2VuZSBpbiB5b3VyIGdhbWUsIHVzZSBjaGFuZ2VUb1NjZW5lKCkgaW4gQHJlZmVyZW5jZVtTY2VuZU1hbmFnZXJdXHJcbiAgICogQHBhcmFtIHZpZXdwb3J0IFRoZSB2aWV3cG9ydCBvZiB0aGUgZ2FtZVxyXG4gICAqIEBwYXJhbSBzY2VuZU1hbmFnZXIgVGhlIFNjZW5lTWFuYWdlciB0aGF0IG93bnMgdGhpcyBTY2VuZVxyXG4gICAqIEBwYXJhbSByZW5kZXJpbmdNYW5hZ2VyIFRoZSBSZW5kZXJpbmdNYW5hZ2VyIHRoYXQgd2lsbCBoYW5kbGUgdGhpcyBTY2VuZSdzIHJlbmRlcmluZ1xyXG4gICAqIEBwYXJhbSBnYW1lIFRoZSBpbnN0YW5jZSBvZiB0aGUgR2FtZVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBTY2VuZSBpbml0aWFsaXphdGlvblxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgdmlld3BvcnQ6IFZpZXdwb3J0LFxyXG4gICAgc2NlbmVNYW5hZ2VyOiBTY2VuZU1hbmFnZXIsXHJcbiAgICByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyLFxyXG4gICAgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PixcclxuICApIHtcclxuICAgIHRoaXMuc2NlbmVPcHRpb25zID0gU2NlbmVPcHRpb25zLnBhcnNlKFxyXG4gICAgICBvcHRpb25zID09PSB1bmRlZmluZWQgPyB7fSA6IG9wdGlvbnMsXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMud29ybGRTaXplID0gbmV3IFZlYzIoNTAwLCA1MDApO1xyXG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xyXG4gICAgdGhpcy52aWV3cG9ydC5zZXRCb3VuZHMoMCwgMCwgMjU2MCwgMTI4MCk7XHJcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuc2NlbmVNYW5hZ2VyID0gc2NlbmVNYW5hZ2VyO1xyXG4gICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xyXG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuXHJcbiAgICB0aGlzLnRpbGVtYXBzID0gbmV3IEFycmF5KCk7XHJcbiAgICB0aGlzLnNjZW5lR3JhcGggPSBuZXcgU2NlbmVHcmFwaEFycmF5KHRoaXMudmlld3BvcnQsIHRoaXMpO1xyXG5cclxuICAgIHRoaXMubGF5ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy51aUxheWVycyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMucGFyYWxsYXhMYXllcnMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgdGhpcy5waHlzaWNzTWFuYWdlciA9IG5ldyBCYXNpY1BoeXNpY3NNYW5hZ2VyKHRoaXMuc2NlbmVPcHRpb25zLnBoeXNpY3MpO1xyXG4gICAgdGhpcy5uYXZNYW5hZ2VyID0gbmV3IE5hdmlnYXRpb25NYW5hZ2VyKCk7XHJcbiAgICB0aGlzLmFpTWFuYWdlciA9IG5ldyBBSU1hbmFnZXIoKTtcclxuICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IHJlbmRlcmluZ01hbmFnZXI7XHJcblxyXG4gICAgdGhpcy5hZGQgPSBuZXcgRmFjdG9yeU1hbmFnZXIodGhpcywgdGhpcy50aWxlbWFwcyk7XHJcblxyXG4gICAgdGhpcy5sb2FkID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IHRoaXMubG9hZDtcclxuXHJcbiAgICAvLyBHZXQgdGhlIHRpbWVyIG1hbmFnZXIgYW5kIGNsZWFyIGFueSBleGlzdGluZyB0aW1lcnNcclxuICAgIFRpbWVyTWFuYWdlci5nZXRJbnN0YW5jZSgpLmNsZWFyVGltZXJzKCk7XHJcbiAgfVxyXG5cclxuICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYSBuZXcgc2NlbmUgaXMgY3JlYXRlZCwgYmVmb3JlIGFueXRoaW5nIGVsc2UuICovXHJcbiAgaW5pdFNjZW5lKGluaXQ6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHt9XHJcblxyXG4gIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBnZXRzIGNhbGxlZCB3aGVuIGEgbmV3IHNjZW5lIGlzIGNyZWF0ZWQuIExvYWQgYWxsIGZpbGVzIHlvdSB3aXNoIHRvIGFjY2VzcyBpbiB0aGUgc2NlbmUgaGVyZS4gKi9cclxuICBsb2FkU2NlbmUoKTogdm9pZCB7fVxyXG5cclxuICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIGNhbGxlZCBzdHJpY3RseSBhZnRlciBsb2FkU2NlbmUoKS4gQ3JlYXRlIGFueSBnYW1lIG9iamVjdHMgeW91IHdpc2ggdG8gdXNlIGluIHRoZSBzY2VuZSBoZXJlLiAqL1xyXG4gIHN0YXJ0U2NlbmUoKTogdm9pZCB7fVxyXG5cclxuICAvKipcclxuICAgKiBBIGxpZmVjeWNsZSBtZXRob2QgY2FsbGVkIGV2ZXJ5IGZyYW1lIG9mIHRoZSBnYW1lLiBUaGlzIGlzIHdoZXJlIHlvdSBjYW4gZHluYW1pY2FsbHkgZG8gdGhpbmdzIGxpa2UgYWRkIGluIG5ldyBlbmVtaWVzXHJcbiAgICogQHBhcmFtIGRlbHRhIFRoZSB0aW1lIHRoaXMgZnJhbWUgcmVwcmVzZW50c1xyXG4gICAqL1xyXG4gIHVwZGF0ZVNjZW5lKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7fVxyXG5cclxuICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgb24gc2NlbmUgZGVzdHJ1Y3Rpb24uIFNwZWNpZnkgd2hpY2ggZmlsZXMgeW91IG5vIGxvbmdlciBuZWVkIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uICovXHJcbiAgdW5sb2FkU2NlbmUoKTogdm9pZCB7fVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMudXBkYXRlU2NlbmUoZGVsdGFUKTtcclxuXHJcbiAgICAvLyBEbyB0aW1lIHVwZGF0ZXNcclxuICAgIFRpbWVyTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgIC8vIERvIGFsbCBBSSB1cGRhdGVzXHJcbiAgICB0aGlzLmFpTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgYWxsIHBoeXNpY3Mgb2JqZWN0c1xyXG4gICAgdGhpcy5waHlzaWNzTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgYWxsIGNhbnZhcyBvYmplY3RzXHJcbiAgICB0aGlzLnNjZW5lR3JhcGgudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgLy8gVXBkYXRlIGFsbCB0aWxlbWFwc1xyXG4gICAgdGhpcy50aWxlbWFwcy5mb3JFYWNoKHRpbGVtYXAgPT4ge1xyXG4gICAgICBpZiAoIXRpbGVtYXAuZ2V0TGF5ZXIoKS5pc1BhdXNlZCgpKSB7XHJcbiAgICAgICAgdGlsZW1hcC51cGRhdGUoZGVsdGFUKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVXBkYXRlIGFsbCB0d2VlbnNcclxuICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBhbGwgcGFydGljbGUgc3lzdGVtc1xyXG4gICAgUGFydGljbGVTeXN0ZW1NYW5hZ2VyLmdldEluc3RhbmNlKCkudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHZpZXdwb3J0XHJcbiAgICB0aGlzLnZpZXdwb3J0LnVwZGF0ZShkZWx0YVQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29sbGVjdHMgcmVuZGVyYWJsZSBzZXRzIGFuZCBjb29yZGluYXRlcyB3aXRoIHRoZSBSZW5kZXJpbmdNYW5hZ2VyIHRvIGRyYXcgdGhlIFNjZW5lXHJcbiAgICovXHJcbiAgcmVuZGVyKCk6IHZvaWQge1xyXG4gICAgLy8gR2V0IHRoZSB2aXNpYmxlIHNldCBvZiBub2Rlc1xyXG4gICAgbGV0IHZpc2libGVTZXQgPSB0aGlzLnNjZW5lR3JhcGguZ2V0VmlzaWJsZVNldCgpO1xyXG5cclxuICAgIC8vIEFkZCBwYXJhbGxheCBsYXllciBpdGVtcyB0byB0aGUgdmlzaWJsZSBzZXQgKHdlJ3JlIHJlbmRlcmluZyB0aGVtIGFsbCBmb3Igbm93KVxyXG4gICAgdGhpcy5wYXJhbGxheExheWVycy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGxldCBwTGF5ZXIgPSB0aGlzLnBhcmFsbGF4TGF5ZXJzLmdldChrZXkpO1xyXG4gICAgICBmb3IgKGxldCBub2RlIG9mIHBMYXllci5nZXRJdGVtcygpKSB7XHJcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDYW52YXNOb2RlKSB7XHJcbiAgICAgICAgICB2aXNpYmxlU2V0LnB1c2gobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTZW5kIHRoZSB2aXNpYmxlIHNldCwgdGlsZW1hcHMsIGFuZCB1aUxheWVycyB0byB0aGUgcmVuZGVyZXJcclxuICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlci5yZW5kZXIodmlzaWJsZVNldCwgdGhpcy50aWxlbWFwcywgdGhpcy51aUxheWVycyk7XHJcblxyXG4gICAgbGV0IG5vZGVzID0gdGhpcy5zY2VuZUdyYXBoLmdldEFsbE5vZGVzKCk7XHJcbiAgICB0aGlzLnRpbGVtYXBzLmZvckVhY2godGlsZW1hcCA9PlxyXG4gICAgICB0aWxlbWFwLnZpc2libGUgPyBub2Rlcy5wdXNoKHRpbGVtYXApIDogMCxcclxuICAgICk7XHJcbiAgICBEZWJ1Zy5zZXROb2Rlcyhub2Rlcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBzY2VuZSBhcyBydW5uaW5nIG9yIG5vdFxyXG4gICAqIEBwYXJhbSBydW5uaW5nIFRydWUgaWYgdGhlIFNjZW5lIHNob3VsZCBiZSBydW5uaW5nLCBmYWxzZSBpZiBub3RcclxuICAgKi9cclxuICBzZXRSdW5uaW5nKHJ1bm5pbmc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIHRoaXMucnVubmluZyA9IHJ1bm5pbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBTY2VuZSBpcyBydW5uaW5nXHJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc2NlbmUgaXMgcnVubmluZywgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgaXNSdW5uaW5nKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMucnVubmluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhpcyBTY2VuZVxyXG4gICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxyXG4gICAqL1xyXG4gIHJlbW92ZShub2RlOiBHYW1lTm9kZSk6IHZvaWQge1xyXG4gICAgLy8gUmVtb3ZlIGZyb20gdGhlIHNjZW5lIGdyYXBoXHJcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIENhbnZhc05vZGUpIHtcclxuICAgICAgdGhpcy5zY2VuZUdyYXBoLnJlbW92ZU5vZGUobm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogRGVzdHJveXMgdGhpcyBzY2VuZSBhbmQgYWxsIG5vZGVzIGluIGl0ICovXHJcbiAgZGVzdHJveSgpOiB2b2lkIHtcclxuICAgIGZvciAobGV0IG5vZGUgb2YgdGhpcy5zY2VuZUdyYXBoLmdldEFsbE5vZGVzKCkpIHtcclxuICAgICAgbm9kZS5kZXN0cm95KCk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgdGlsZW1hcCBvZiB0aGlzLnRpbGVtYXBzKSB7XHJcbiAgICAgIHRpbGVtYXAuZGVzdHJveSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVjZWl2ZXIuZGVzdHJveSgpO1xyXG5cclxuICAgIGRlbGV0ZSB0aGlzLnNjZW5lR3JhcGg7XHJcbiAgICBkZWxldGUgdGhpcy5waHlzaWNzTWFuYWdlcjtcclxuICAgIGRlbGV0ZSB0aGlzLm5hdk1hbmFnZXI7XHJcbiAgICBkZWxldGUgdGhpcy5haU1hbmFnZXI7XHJcbiAgICBkZWxldGUgdGhpcy5yZWNlaXZlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBuZXcgbGF5ZXIgdG8gdGhlIHNjZW5lIGFuZCByZXR1cm5zIGl0XHJcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIG5ldyBsYXllclxyXG4gICAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIGxheWVyXHJcbiAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgTGF5ZXJcclxuICAgKi9cclxuICBhZGRMYXllcihuYW1lOiBzdHJpbmcsIGRlcHRoPzogbnVtYmVyKTogTGF5ZXIge1xyXG4gICAgaWYgKFxyXG4gICAgICB0aGlzLmxheWVycy5oYXMobmFtZSkgfHxcclxuICAgICAgdGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSkgfHxcclxuICAgICAgdGhpcy51aUxheWVycy5oYXMobmFtZSlcclxuICAgICkge1xyXG4gICAgICB0aHJvdyBgTGF5ZXIgd2l0aCBuYW1lICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBsYXllciA9IG5ldyBMYXllcih0aGlzLCBuYW1lKTtcclxuXHJcbiAgICB0aGlzLmxheWVycy5hZGQobmFtZSwgbGF5ZXIpO1xyXG5cclxuICAgIGlmIChkZXB0aCkge1xyXG4gICAgICBsYXllci5zZXREZXB0aChkZXB0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIG5ldyBwYXJhbGxheCBsYXllciB0byB0aGlzIHNjZW5lIGFuZCByZXR1cm5zIGl0XHJcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBhcmFsbGF4IGxheWVyXHJcbiAgICogQHBhcmFtIHBhcmFsbGF4IFRoZSBwYXJhbGxheCBsZXZlbFxyXG4gICAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIGxheWVyXHJcbiAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgUGFyYWxsYXhMYXllclxyXG4gICAqL1xyXG4gIGFkZFBhcmFsbGF4TGF5ZXIoXHJcbiAgICBuYW1lOiBzdHJpbmcsXHJcbiAgICBwYXJhbGxheDogVmVjMixcclxuICAgIGRlcHRoPzogbnVtYmVyLFxyXG4gICk6IFBhcmFsbGF4TGF5ZXIge1xyXG4gICAgaWYgKFxyXG4gICAgICB0aGlzLmxheWVycy5oYXMobmFtZSkgfHxcclxuICAgICAgdGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSkgfHxcclxuICAgICAgdGhpcy51aUxheWVycy5oYXMobmFtZSlcclxuICAgICkge1xyXG4gICAgICB0aHJvdyBgTGF5ZXIgd2l0aCBuYW1lICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBsYXllciA9IG5ldyBQYXJhbGxheExheWVyKHRoaXMsIG5hbWUsIHBhcmFsbGF4KTtcclxuXHJcbiAgICB0aGlzLnBhcmFsbGF4TGF5ZXJzLmFkZChuYW1lLCBsYXllcik7XHJcblxyXG4gICAgaWYgKGRlcHRoKSB7XHJcbiAgICAgIGxheWVyLnNldERlcHRoKGRlcHRoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGF5ZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgbmV3IFVJTGF5ZXIgdG8gdGhlIHNjZW5lXHJcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIG5ldyBVSWxheWVyXHJcbiAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgVUlMYXllclxyXG4gICAqL1xyXG4gIGFkZFVJTGF5ZXIobmFtZTogc3RyaW5nKTogVUlMYXllciB7XHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMubGF5ZXJzLmhhcyhuYW1lKSB8fFxyXG4gICAgICB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSB8fFxyXG4gICAgICB0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKVxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IGBMYXllciB3aXRoIG5hbWUgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2A7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGxheWVyID0gbmV3IFVJTGF5ZXIodGhpcywgbmFtZSk7XHJcblxyXG4gICAgdGhpcy51aUxheWVycy5hZGQobmFtZSwgbGF5ZXIpO1xyXG5cclxuICAgIHJldHVybiBsYXllcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYSBsYXllciBmcm9tIHRoZSBzY2VuZSBieSBuYW1lIGlmIGl0IGV4aXN0cy5cclxuICAgKiBUaGlzIGNhbiBiZSBhIExheWVyIG9yIGFueSBvZiBpdHMgc3ViY2xhc3Nlc1xyXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG4gICAqIEByZXR1cm5zIFRoZSBMYXllciBmb3VuZCB3aXRoIHRoYXQgbmFtZVxyXG4gICAqL1xyXG4gIGdldExheWVyKG5hbWU6IHN0cmluZyk6IExheWVyIHtcclxuICAgIGlmICh0aGlzLmxheWVycy5oYXMobmFtZSkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzLmdldChuYW1lKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyYWxsYXhMYXllcnMuZ2V0KG5hbWUpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy51aUxheWVycy5nZXQobmFtZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBgUmVxdWVzdGVkIGxheWVyICR7bmFtZX0gZG9lcyBub3QgZXhpc3QuYDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxheWVyIGlzIGEgUGFyYWxsYXhMYXllclxyXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBsYXllciBpcyBhIFBhcmFsbGF4TGF5ZXJcclxuICAgKi9cclxuICBpc1BhcmFsbGF4TGF5ZXIobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBsYXllciBpcyBhIFVJTGF5ZXJcclxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgbGF5ZXIgaXMgUGFyYWxsYXhMYXllclxyXG4gICAqL1xyXG4gIGlzVUlMYXllcihuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIG9mIHRoaXMgbm9kZSB3aXRoIHJlc3BlY3QgdG8gY2FtZXJhIHNwYWNlIChkdWUgdG8gdGhlIHZpZXdwb3J0IG1vdmluZykuXHJcbiAgICogVGhpcyB2YWx1ZSBpcyBhZmZlY3RlZCBieSB0aGUgcGFyYWxsYXggbGV2ZWwgb2YgdGhlIEByZWZlcmVuY2VbTGF5ZXJdIHRoZSBub2RlIGlzIG9uLlxyXG4gICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGNoZWNrIHRoZSB2aWV3cG9ydCB3aXRoIHJlc3BlY3QgdG9cclxuICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgdHJhbnNsYXRpb24gb2Ygdmlld3BvcnQgd2l0aCByZXNwZWN0IHRvIHRoaXMgbm9kZS5cclxuICAgKi9cclxuICBnZXRWaWV3VHJhbnNsYXRpb24obm9kZTogR2FtZU5vZGUpOiBWZWMyIHtcclxuICAgIGxldCBsYXllciA9IG5vZGUuZ2V0TGF5ZXIoKTtcclxuXHJcbiAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBQYXJhbGxheExheWVyIHx8IGxheWVyIGluc3RhbmNlb2YgVUlMYXllcikge1xyXG4gICAgICByZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRPcmlnaW4oKS5tdWx0KGxheWVyLnBhcmFsbGF4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0LmdldE9yaWdpbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgc2NhbGUgbGV2ZWwgb2YgdGhlIHZpZXdcclxuICAgKiBAcmV0dXJucyBUaGUgem9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcclxuICAgKi9cclxuICBnZXRWaWV3U2NhbGUoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgVmlld3BvcnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2NlbmVcclxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBWaWV3cG9ydFxyXG4gICAqL1xyXG4gIGdldFZpZXdwb3J0KCk6IFZpZXdwb3J0IHtcclxuICAgIHJldHVybiB0aGlzLnZpZXdwb3J0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgd29ybGQgc2l6ZSBvZiB0aGlzIFNjZW5lXHJcbiAgICogQHJldHVybnMgVGhlIHdvcmxkIHNpemUgaW4gYSBWZWMyXHJcbiAgICovXHJcbiAgZ2V0V29ybGRTaXplKCk6IFZlYzIge1xyXG4gICAgcmV0dXJuIHRoaXMud29ybGRTaXplO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgU2NlbmVHcmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxyXG4gICAqIEByZXR1cm5zIFRoZSBTY2VuZUdyYXBoXHJcbiAgICovXHJcbiAgZ2V0U2NlbmVHcmFwaCgpOiBTY2VuZUdyYXBoIHtcclxuICAgIHJldHVybiB0aGlzLnNjZW5lR3JhcGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBQaHlzaWNzTWFuYWdlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxyXG4gICAqIEByZXR1cm5zIFRoZSBQaHlzaWNzTWFuYWdlclxyXG4gICAqL1xyXG4gIGdldFBoeXNpY3NNYW5hZ2VyKCk6IFBoeXNpY3NNYW5hZ2VyIHtcclxuICAgIHJldHVybiB0aGlzLnBoeXNpY3NNYW5hZ2VyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgTmF2aWdhdGlvbk1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2NlbmVcclxuICAgKiBAcmV0dXJucyBUaGUgTmF2aWdhdGlvbk1hbmFnZXJcclxuICAgKi9cclxuICBnZXROYXZpZ2F0aW9uTWFuYWdlcigpOiBOYXZpZ2F0aW9uTWFuYWdlciB7XHJcbiAgICByZXR1cm4gdGhpcy5uYXZNYW5hZ2VyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgQUlNYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNjZW5lXHJcbiAgICogQHJldHVybnMgVGhlIEFJTWFuYWdlclxyXG4gICAqL1xyXG4gIGdldEFJTWFuYWdlcigpOiBBSU1hbmFnZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuYWlNYW5hZ2VyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGVzIGFuIElEIGZvciBhIEdhbWVOb2RlXHJcbiAgICogQHJldHVybnMgVGhlIG5ldyBJRFxyXG4gICAqL1xyXG4gIGdlbmVyYXRlSWQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLnNjZW5lTWFuYWdlci5nZW5lcmF0ZUlkKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZXMgYSBUaWxlbWFwIGluIHRoaXMgU2NlbmVcclxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgVGlsZW1hcFxyXG4gICAqIEByZXR1cm5zIFRoZSBUaWxlbWFwLCBpZiBvbmUgdGhpcyBuYW1lIGV4aXN0cywgb3RoZXJ3aXNlIG51bGxcclxuICAgKi9cclxuICBnZXRUaWxlbWFwKG5hbWU6IHN0cmluZyk6IFRpbGVtYXAge1xyXG4gICAgZm9yIChsZXQgdGlsZW1hcCBvZiB0aGlzLnRpbGVtYXBzKSB7XHJcbiAgICAgIGlmICh0aWxlbWFwLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGlsZW1hcDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4vU2NlbmVcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcclxuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9SZW5kZXJpbmdNYW5hZ2VyXCI7XHJcbmltcG9ydCBNZW1vcnlVdGlscyBmcm9tIFwiLi4vVXRpbHMvTWVtb3J5VXRpbHNcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgU2NlbmVNYW5hZ2VyIGFjdHMgYXMgYW4gaW50ZXJmYWNlIHRvIGNyZWF0ZSBTY2VuZXMsIGFuZCBoYW5kbGVzIHRoZSBsaWZlY3ljbGUgbWV0aG9kcyBvZiBTY2VuZXMuXHJcbiAqIEl0IGdpdmVzIFNjZW5lcyBhY2Nlc3MgdG8gaW5mb3JtYXRpb24gdGhleSBuZWVkIGZyb20gdGhlIEByZWZlcmVuY2VbR2FtZV0gY2xhc3Mgd2hpbGUga2VlcGluZyBhIGxheWVyIG9mIHNlcGFyYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZU1hbmFnZXIge1xyXG4gIC8qKiBUaGUgY3VycmVudCBTY2VuZSBvZiB0aGUgZ2FtZSAqL1xyXG4gIHByb3RlY3RlZCBjdXJyZW50U2NlbmU6IFNjZW5lO1xyXG5cclxuICAvKiogVGhlIFZpZXdwb3J0IG9mIHRoZSBnYW1lICovXHJcbiAgcHJvdGVjdGVkIHZpZXdwb3J0OiBWaWV3cG9ydDtcclxuXHJcbiAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBSZXNvdXJjZU1hbmFnZXIgKi9cclxuICBwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XHJcblxyXG4gIC8qKiBBIGNvdW50ZXIgdG8ga2VlcCB0cmFjayBvZiBnYW1lIGlkcyAqL1xyXG4gIHByb3RlY3RlZCBpZENvdW50ZXI6IG51bWJlcjtcclxuXHJcbiAgLyoqIFRoZSBSZW5kZXJpbmdNYW5hZ2VyIG9mIHRoZSBnYW1lICovXHJcbiAgcHJvdGVjdGVkIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXI7XHJcblxyXG4gIC8qKiBGb3IgY29uc2lzdGVuY3ksIG9ubHkgY2hhbmdlIHNjZW5lcyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB1cGRhdGUgY3ljbGUgKi9cclxuICBwcm90ZWN0ZWQgcGVuZGluZ1NjZW5lOiBTY2VuZTtcclxuICBwcm90ZWN0ZWQgcGVuZGluZ1NjZW5lSW5pdDogUmVjb3JkPHN0cmluZywgYW55PjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBTY2VuZU1hbmFnZXJcclxuICAgKiBAcGFyYW0gdmlld3BvcnQgVGhlIFZpZXdwb3J0IG9mIHRoZSBnYW1lXHJcbiAgICogQHBhcmFtIGdhbWUgVGhlIEdhbWUgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gcmVuZGVyaW5nTWFuYWdlciBUaGUgUmVuZGVyaW5nTWFuYWdlciBvZiB0aGUgZ2FtZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHZpZXdwb3J0OiBWaWV3cG9ydCwgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcikge1xyXG4gICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcclxuICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IHJlbmRlcmluZ01hbmFnZXI7XHJcbiAgICB0aGlzLmlkQ291bnRlciA9IDA7XHJcbiAgICB0aGlzLnBlbmRpbmdTY2VuZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBzY2VuZSBhcyB0aGUgbWFpbiBzY2VuZS5cclxuICAgKiBVc2UgdGhpcyBtZXRob2QgaWYgeW91J3ZlIGNyZWF0ZWQgYSBzdWJjbGFzcyBvZiBTY2VuZSwgYW5kIHlvdSB3YW50IHRvIGFkZCBpdCBhcyB0aGUgbWFpbiBTY2VuZS5cclxuICAgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgc2NlbmUgdG8gYWRkXHJcbiAgICogQHBhcmFtIGluaXQgQW4gb2JqZWN0IHRvIHBhc3MgdG8gdGhlIGluaXQgZnVuY3Rpb24gb2YgdGhlIG5ldyBzY2VuZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBjaGFuZ2VUb1NjZW5lPFQgZXh0ZW5kcyBTY2VuZT4oXHJcbiAgICBjb25zdHI6IG5ldyAoLi4uYXJnczogYW55KSA9PiBULFxyXG4gICAgaW5pdD86IFJlY29yZDxzdHJpbmcsIGFueT4sXHJcbiAgICBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55PixcclxuICApOiB2b2lkIHtcclxuICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgdGhlIG5ldyBzY2VuZSAtIGNoYW5nZSBpcyBwZW5kaW5nIHVudGlsIG5leHQgdXBkYXRlXCIpO1xyXG4gICAgdGhpcy5wZW5kaW5nU2NlbmUgPSBuZXcgY29uc3RyKFxyXG4gICAgICB0aGlzLnZpZXdwb3J0LFxyXG4gICAgICB0aGlzLFxyXG4gICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIsXHJcbiAgICAgIG9wdGlvbnMsXHJcbiAgICApO1xyXG4gICAgdGhpcy5wZW5kaW5nU2NlbmVJbml0ID0gaW5pdDtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBkb1NjZW5lQ2hhbmdlKCkge1xyXG4gICAgY29uc29sZS5sb2coXCJQZXJmb3JtaW5nIHNjZW5lIGNoYW5nZVwiKTtcclxuICAgIHRoaXMudmlld3BvcnQuc2V0Q2VudGVyKFxyXG4gICAgICB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueCxcclxuICAgICAgdGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLnksXHJcbiAgICApO1xyXG5cclxuICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlVubG9hZGluZyBvbGQgc2NlbmVcIik7XHJcbiAgICAgIHRoaXMuY3VycmVudFNjZW5lLnVubG9hZFNjZW5lKCk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIkRlc3Ryb3lpbmcgb2xkIHNjZW5lXCIpO1xyXG4gICAgICB0aGlzLmN1cnJlbnRTY2VuZS5kZXN0cm95KCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJVbmxvYWRpbmcgb2xkIHJlc291cmNlcy4uLlwiKTtcclxuICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyLnVubG9hZEFsbFJlc291cmNlcygpO1xyXG5cclxuICAgIC8vIE1ha2UgdGhlIHBlbmRpbmcgc2NlbmUgdGhlIGN1cnJlbnQgb25lXHJcbiAgICB0aGlzLmN1cnJlbnRTY2VuZSA9IHRoaXMucGVuZGluZ1NjZW5lO1xyXG5cclxuICAgIC8vIE1ha2UgdGhlIHBlbmRpbmcgc2NlbmUgbnVsbFxyXG4gICAgdGhpcy5wZW5kaW5nU2NlbmUgPSBudWxsO1xyXG5cclxuICAgIC8vIEluaXQgdGhlIHNjZW5lXHJcbiAgICB0aGlzLmN1cnJlbnRTY2VuZS5pbml0U2NlbmUodGhpcy5wZW5kaW5nU2NlbmVJbml0KTtcclxuXHJcbiAgICAvLyBFbnF1ZXVlIGFsbCBzY2VuZSBhc3NldCBsb2Fkc1xyXG4gICAgdGhpcy5jdXJyZW50U2NlbmUubG9hZFNjZW5lKCk7XHJcblxyXG4gICAgLy8gTG9hZCBhbGwgYXNzZXRzXHJcbiAgICBjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIFNjZW5lIExvYWRcIik7XHJcbiAgICB0aGlzLnJlc291cmNlTWFuYWdlci5sb2FkUmVzb3VyY2VzRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coXCJTdGFydGluZyBTY2VuZVwiKTtcclxuICAgICAgdGhpcy5jdXJyZW50U2NlbmUuc3RhcnRTY2VuZSgpO1xyXG4gICAgICB0aGlzLmN1cnJlbnRTY2VuZS5zZXRSdW5uaW5nKHRydWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLnNldFNjZW5lKHRoaXMuY3VycmVudFNjZW5lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRFxyXG4gICAqIEByZXR1cm5zIEEgbmV3IElEXHJcbiAgICovXHJcbiAgcHVibGljIGdlbmVyYXRlSWQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmlkQ291bnRlcisrO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVycyB0aGUgY3VycmVudCBTY2VuZVxyXG4gICAqL1xyXG4gIHB1YmxpYyByZW5kZXIoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUpIHtcclxuICAgICAgdGhpcy5jdXJyZW50U2NlbmUucmVuZGVyKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IFNjZW5lXHJcbiAgICogQHBhcmFtIGRlbHRhVCBUaGUgdGltZXN0ZXAgb2YgdGhlIFNjZW5lXHJcbiAgICovXHJcbiAgcHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcikge1xyXG4gICAgaWYgKHRoaXMucGVuZGluZ1NjZW5lICE9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMuZG9TY2VuZUNoYW5nZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSAmJiB0aGlzLmN1cnJlbnRTY2VuZS5pc1J1bm5pbmcoKSkge1xyXG4gICAgICB0aGlzLmN1cnJlbnRTY2VuZS51cGRhdGUoZGVsdGFUKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IEFycmF5VXRpbHMgZnJvbSBcIi4uL1V0aWxzL0FycmF5VXRpbHNcIjtcclxuXHJcbi8vIEBpZ25vcmVQYWdlXHJcblxyXG4vKipcclxuICogVGhlIG9wdGlvbnMgdG8gZ2l2ZSBhIEByZWZlcmVuY2VbU2NlbmVdIGZvciBpbml0aWFsaXphdGlvblxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVPcHRpb25zIHtcclxuICBwaHlzaWNzOiB7XHJcbiAgICBncm91cHM6IEFycmF5PHN0cmluZz47XHJcbiAgICBjb2xsaXNpb25zOiBBcnJheTxBcnJheTxudW1iZXI+PjtcclxuICB9O1xyXG5cclxuICBzdGF0aWMgcGFyc2Uob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IFNjZW5lT3B0aW9ucyB7XHJcbiAgICBsZXQgc09wdCA9IG5ldyBTY2VuZU9wdGlvbnMoKTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5waHlzaWNzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgc09wdC5waHlzaWNzID0geyBncm91cHM6IHVuZGVmaW5lZCwgY29sbGlzaW9uczogdW5kZWZpbmVkIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzT3B0LnBoeXNpY3MgPSBvcHRpb25zLnBoeXNpY3M7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNPcHQ7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRUeXBlXCI7XHJcblxyXG4vKipcclxuICogTWFuYWdlcyBhbnkgc291bmRzIG9yIG11c2ljIG5lZWRlZCBmb3IgdGhlIGdhbWUuXHJcbiAqIFRocm91Z2ggdGhlIEV2ZW50UXVldWUsIGV4cG9zZXMgaW50ZXJmYWNlIHRvIHBsYXkgc291bmRzIHNvIEdhbWVOb2RlcyBjYW4gYWN0aXZhdGUgc291bmRzIHdpdGhvdXRcclxuICogbmVlZGluZyBkaXJlY3QgcmVmZXJlbmNlcyB0byB0aGUgYXVkaW8gc3lzdGVtXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdWRpb01hbmFnZXIge1xyXG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBBdWRpb01hbmFnZXI7XHJcblxyXG4gIC8qKiBUaGUgZXZlbnQgcmVjZWl2ZXIgb2YgdGhpcyBBdWRpb01hbmFnZXIgKi9cclxuICBwcml2YXRlIHJlY2VpdmVyOiBSZWNlaXZlcjtcclxuXHJcbiAgLyoqIEEgTWFwIG9mIHRoZSBuYW1lcyBvZiBjdXJyZW50bHkgcGxheWluZyAob3IgcGF1c2VkKSBzb3VuZHMgdG8gdGhlaXIgQXVkaW9CdWZmZXJzICovXHJcbiAgcHJpdmF0ZSBjdXJyZW50U291bmRzOiBNYXA8QXVkaW9CdWZmZXJTb3VyY2VOb2RlPjtcclxuXHJcbiAgcHJpdmF0ZSBhdWRpb0N0eDogQXVkaW9Db250ZXh0O1xyXG5cclxuICBwcml2YXRlIGdhaW5Ob2RlczogQXJyYXk8R2Fpbk5vZGU+O1xyXG5cclxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5pbml0QXVkaW8oKTtcclxuICAgIHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcclxuICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFtcclxuICAgICAgR2FtZUV2ZW50VHlwZS5QTEFZX1NPVU5ELFxyXG4gICAgICBHYW1lRXZlbnRUeXBlLlNUT1BfU09VTkQsXHJcbiAgICAgIEdhbWVFdmVudFR5cGUuUExBWV9NVVNJQyxcclxuICAgICAgR2FtZUV2ZW50VHlwZS5QTEFZX1NGWCxcclxuICAgICAgR2FtZUV2ZW50VHlwZS5NVVRFX0NIQU5ORUwsXHJcbiAgICAgIEdhbWVFdmVudFR5cGUuVU5NVVRFX0NIQU5ORUwsXHJcbiAgICBdKTtcclxuICAgIHRoaXMuY3VycmVudFNvdW5kcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICB0aGlzLmdhaW5Ob2RlcyA9IG5ldyBBcnJheTxHYWluTm9kZT4oTUFYX0FVRElPX0NIQU5ORUxTKTtcclxuICAgIHRoaXMuaW5pdEdhaW5Ob2RlcygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBpbnN0YW5jZSBvZiB0aGUgQXVkaW9NYW5hZ2VyIGNsYXNzIG9yIGNyZWF0ZSBhIG5ldyBvbmUgaWYgbm9uZSBleGlzdHNcclxuICAgKiBAcmV0dXJucyBUaGUgQXVkaW9NYW5hZ2VyXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBBdWRpb01hbmFnZXIge1xyXG4gICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XHJcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgQXVkaW9NYW5hZ2VyKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIHRoZSB3ZWJBdWRpbyBjb250ZXh0XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBpbml0QXVkaW8oKTogdm9pZCB7XHJcbiAgICB0cnkge1xyXG4gICAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dDsgLy8gfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcclxuICAgICAgdGhpcy5hdWRpb0N0eCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcclxuICAgICAgY29uc29sZS5sb2coXCJXZWIgQXVkaW8gQVBJIHN1Y2Nlc3NmdWxseSBsb2FkZWRcIik7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcIldlYiBBdWRpbyBBUEkgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGluaXRHYWluTm9kZXMoKTogdm9pZCB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BWF9BVURJT19DSEFOTkVMUzsgaSsrKSB7XHJcbiAgICAgIHRoaXMuZ2Fpbk5vZGVzW2ldID0gdGhpcy5hdWRpb0N0eC5jcmVhdGVHYWluKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGF1ZGlvIGNvbnRleHRcclxuICAgKiBAcmV0dXJucyBUaGUgQXVkaW9Db250ZXh0XHJcbiAgICovXHJcbiAgcHVibGljIGdldEF1ZGlvQ29udGV4dCgpOiBBdWRpb0NvbnRleHQge1xyXG4gICAgcmV0dXJuIHRoaXMuYXVkaW9DdHg7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAgICAgIEFjY29yZGluZyB0byB0aGUgTUROLCBjcmVhdGUgYSBuZXcgc291bmQgZm9yIGV2ZXJ5IGNhbGw6XHJcblxyXG4gICAgICAgIEFuIEF1ZGlvQnVmZmVyU291cmNlTm9kZSBjYW4gb25seSBiZSBwbGF5ZWQgb25jZTsgYWZ0ZXIgZWFjaCBjYWxsIHRvIHN0YXJ0KCksIHlvdSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBub2RlXHJcbiAgICAgICAgaWYgeW91IHdhbnQgdG8gcGxheSB0aGUgc2FtZSBzb3VuZCBhZ2Fpbi4gRm9ydHVuYXRlbHksIHRoZXNlIG5vZGVzIGFyZSB2ZXJ5IGluZXhwZW5zaXZlIHRvIGNyZWF0ZSwgYW5kIHRoZVxyXG4gICAgICAgIGFjdHVhbCBBdWRpb0J1ZmZlcnMgY2FuIGJlIHJldXNlZCBmb3IgbXVsdGlwbGUgcGxheXMgb2YgdGhlIHNvdW5kLiBJbmRlZWQsIHlvdSBjYW4gdXNlIHRoZXNlIG5vZGVzIGluIGFcclxuICAgICAgICBcImZpcmUgYW5kIGZvcmdldFwiIG1hbm5lcjogY3JlYXRlIHRoZSBub2RlLCBjYWxsIHN0YXJ0KCkgdG8gYmVnaW4gcGxheWluZyB0aGUgc291bmQsIGFuZCBkb24ndCBldmVuIGJvdGhlciB0b1xyXG4gICAgICAgIGhvbGQgYSByZWZlcmVuY2UgdG8gaXQuIEl0IHdpbGwgYXV0b21hdGljYWxseSBiZSBnYXJiYWdlLWNvbGxlY3RlZCBhdCBhbiBhcHByb3ByaWF0ZSB0aW1lLCB3aGljaCB3b24ndCBiZVxyXG4gICAgICAgIHVudGlsIHNvbWV0aW1lIGFmdGVyIHRoZSBzb3VuZCBoYXMgZmluaXNoZWQgcGxheWluZy5cclxuICAgICovXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBzb3VuZCBmcm9tIHRoZSBrZXkgb2YgYSBsb2FkZWQgYXVkaW8gZmlsZVxyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIGF1ZGlvIGZpbGUgdG8gY3JlYXRlIGEgbmV3IHNvdW5kIGZvclxyXG4gICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIEF1ZGlvQnVmZmVyXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGNyZWF0ZVNvdW5kKFxyXG4gICAga2V5OiBzdHJpbmcsXHJcbiAgICBob2xkUmVmZXJlbmNlOiBib29sZWFuLFxyXG4gICAgY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSxcclxuICAgIG9wdGlvbnM6IE1hcDxhbnk+LFxyXG4gICk6IEF1ZGlvQnVmZmVyU291cmNlTm9kZSB7XHJcbiAgICAvLyBHZXQgYXVkaW8gYnVmZmVyXHJcbiAgICBsZXQgYnVmZmVyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0QXVkaW8oa2V5KTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYSBzb3VuZCBzb3VyY2VcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzLmF1ZGlvQ3R4LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG5cclxuICAgIC8vIFRlbGwgdGhlIHNvdXJjZSB3aGljaCBzb3VuZCB0byBwbGF5XHJcbiAgICBzb3VyY2UuYnVmZmVyID0gYnVmZmVyO1xyXG5cclxuICAgIC8vIEFkZCBhbnkgYWRkaXRpb25hbCBub2Rlc1xyXG4gICAgY29uc3Qgbm9kZXM6IEFycmF5PEF1ZGlvTm9kZT4gPSBbc291cmNlXTtcclxuXHJcbiAgICAvLyBEbyBhbnkgYWRkaXRpb25hbCBub2RlcyBoZXJlP1xyXG4gICAgLy8gT2YgY291cnNlLCB0aGVyZSBhcmVuJ3QgYW55IHN1cHBvcnRlZCB5ZXQuLi5cclxuXHJcbiAgICAvLyBBZGQgdGhlIGdhaW4gbm9kZSBmb3IgdGhpcyBjaGFubmVsXHJcbiAgICBub2Rlcy5wdXNoKHRoaXMuZ2Fpbk5vZGVzW2NoYW5uZWxdKTtcclxuXHJcbiAgICAvLyBDb25uZWN0IGFueSBub2RlcyBhbG9uZyB0aGUgcGF0aFxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBub2Rlc1tpIC0gMV0uY29ubmVjdChub2Rlc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29ubmVjdCB0aGUgc291cmNlIHRvIHRoZSBjb250ZXh0J3MgZGVzdGluYXRpb25cclxuICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLmNvbm5lY3QodGhpcy5hdWRpb0N0eC5kZXN0aW5hdGlvbik7XHJcblxyXG4gICAgcmV0dXJuIHNvdXJjZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBsYXkgdGhlIHNvdW5kIHNwZWNpZmllZCBieSB0aGUga2V5XHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzb3VuZCB0byBwbGF5XHJcbiAgICogQHBhcmFtIGxvb3AgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB0byBsb29wIHRoZSBzb3VuZFxyXG4gICAqIEBwYXJhbSBob2xkUmVmZXJlbmNlIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3Qgd2Ugd2FudCB0byBob2xkIG9uIHRvIGEgcmVmZXJlbmNlIG9mIHRoZSBhdWRpbyBub2RlLiBUaGlzIGlzIGdvb2QgZm9yIHBsYXlpbmcgbXVzaWMgb24gYSBsb29wIHRoYXQgd2lsbCBldmVudHVhbGx5IG5lZWQgdG8gYmUgc3RvcHBlZC5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgcGxheVNvdW5kKFxyXG4gICAga2V5OiBzdHJpbmcsXHJcbiAgICBsb29wOiBib29sZWFuLFxyXG4gICAgaG9sZFJlZmVyZW5jZTogYm9vbGVhbixcclxuICAgIGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUsXHJcbiAgICBvcHRpb25zOiBNYXA8YW55PixcclxuICApOiB2b2lkIHtcclxuICAgIGxldCBzb3VuZCA9IHRoaXMuY3JlYXRlU291bmQoa2V5LCBob2xkUmVmZXJlbmNlLCBjaGFubmVsLCBvcHRpb25zKTtcclxuXHJcbiAgICBpZiAobG9vcCkge1xyXG4gICAgICBzb3VuZC5sb29wID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgYSByZWZlcmVuY2Ugb2YgdGhlIG5ldyBzb3VuZCB0byBhIG1hcC4gVGhpcyB3aWxsIGFsbG93IHVzIHRvIHN0b3AgYSBsb29waW5nIG9yIGxvbmcgc291bmQgYXQgYSBsYXRlciB0aW1lXHJcbiAgICBpZiAoaG9sZFJlZmVyZW5jZSkge1xyXG4gICAgICB0aGlzLmN1cnJlbnRTb3VuZHMuYWRkKGtleSwgc291bmQpO1xyXG4gICAgfVxyXG5cclxuICAgIHNvdW5kLnN0YXJ0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIHRoZSBzb3VuZCBzcGVjaWZpZWQgYnkgdGhlIGtleVxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBzdG9wU291bmQoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGxldCBzb3VuZCA9IHRoaXMuY3VycmVudFNvdW5kcy5nZXQoa2V5KTtcclxuICAgIGlmIChzb3VuZCkge1xyXG4gICAgICBzb3VuZC5zdG9wKCk7XHJcbiAgICAgIHRoaXMuY3VycmVudFNvdW5kcy5kZWxldGUoa2V5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBtdXRlQ2hhbm5lbChjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlKSB7XHJcbiAgICB0aGlzLmdhaW5Ob2Rlc1tjaGFubmVsXS5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRoaXMuYXVkaW9DdHguY3VycmVudFRpbWUpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHVubXV0ZUNoYW5uZWwoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSkge1xyXG4gICAgdGhpcy5nYWluTm9kZXNbY2hhbm5lbF0uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgxLCB0aGlzLmF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHZvbHVtZSBvZiBhIGNoYW5uZWwgdXNpbmcgdGhlIEdhaW5Ob2RlIGZvciB0aGF0IGNoYW5uZWwuIEZvciBtb3JlXHJcbiAgICogaW5mb3JtYXRpb24gb24gR2Fpbk5vZGVzLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0dhaW5Ob2RlXHJcbiAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGF1ZGlvIGNoYW5uZWwgdG8gc2V0IHRoZSB2b2x1bWUgZm9yXHJcbiAgICogQHBhcmFtIHZvbHVtZSBUaGUgdm9sdW1lIG9mIHRoZSBjaGFubmVsLiAwIGlzIG11dGVkLiBWYWx1ZXMgYmVsb3cgemVybyB3aWxsIGJlIHNldCB0byB6ZXJvLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBzZXRWb2x1bWUoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSwgdm9sdW1lOiBudW1iZXIpIHtcclxuICAgIGlmICh2b2x1bWUgPCAwKSB7XHJcbiAgICAgIHZvbHVtZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYW0gPSBBdWRpb01hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIGFtLmdhaW5Ob2Rlc1tjaGFubmVsXS5nYWluLnNldFZhbHVlQXRUaW1lKHZvbHVtZSwgYW0uYXVkaW9DdHguY3VycmVudFRpbWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgR2Fpbk5vZGUgZm9yIHRoaXMgY2hhbm5lbC5cclxuICAgKiBMZWFybiBtb3JlIGFib3V0IEdhaW5Ob2RlcyBoZXJlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9HYWluTm9kZVxyXG4gICAqIERPTidUIFVTRSBUSElTIFVOTEVTUyBZT1UgS05PVyBXSEFUIFlPVSdSRSBET0lOR1xyXG4gICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsXHJcbiAgICogQHJldHVybnMgVGhlIEdhaW5Ob2RlIGZvciB0aGUgc3BlY2lmaWVkIGNoYW5uZWxcclxuICAgKi9cclxuICBnZXRDaGFubmVsR2Fpbk5vZGUoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2Fpbk5vZGVzW2NoYW5uZWxdO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAvLyBQbGF5IGVhY2ggYXVkaW8gY2xpcCByZXF1ZXN0ZWRcclxuICAgIC8vIFRPRE8gLSBBZGQgbG9naWMgdG8gbWVyZ2Ugc291bmRzIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBvZiB0aGUgc2FtZSBrZXlcclxuICAgIHdoaWxlICh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XHJcbiAgICAgIGxldCBldmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XHJcbiAgICAgIGlmIChcclxuICAgICAgICBldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfU09VTkQgfHxcclxuICAgICAgICBldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfTVVTSUMgfHxcclxuICAgICAgICBldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfU0ZYXHJcbiAgICAgICkge1xyXG4gICAgICAgIGxldCBzb3VuZEtleSA9IGV2ZW50LmRhdGEuZ2V0KFwia2V5XCIpO1xyXG4gICAgICAgIGxldCBsb29wID0gZXZlbnQuZGF0YS5nZXQoXCJsb29wXCIpO1xyXG4gICAgICAgIGxldCBob2xkUmVmZXJlbmNlID0gZXZlbnQuZGF0YS5nZXQoXCJob2xkUmVmZXJlbmNlXCIpO1xyXG5cclxuICAgICAgICBsZXQgY2hhbm5lbCA9IEF1ZGlvQ2hhbm5lbFR5cGUuREVGQVVMVDtcclxuXHJcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9NVVNJQykge1xyXG4gICAgICAgICAgY2hhbm5lbCA9IEF1ZGlvQ2hhbm5lbFR5cGUuTVVTSUM7XHJcbiAgICAgICAgfSBlbHNlIGlmIChHYW1lRXZlbnRUeXBlLlBMQVlfU0ZYKSB7XHJcbiAgICAgICAgICBjaGFubmVsID0gQXVkaW9DaGFubmVsVHlwZS5TRlg7XHJcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLmhhcyhcImNoYW5uZWxcIikpIHtcclxuICAgICAgICAgIGNoYW5uZWwgPSBldmVudC5kYXRhLmdldChcImNoYW5uZWxcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnBsYXlTb3VuZChzb3VuZEtleSwgbG9vcCwgaG9sZFJlZmVyZW5jZSwgY2hhbm5lbCwgZXZlbnQuZGF0YSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlNUT1BfU09VTkQpIHtcclxuICAgICAgICBsZXQgc291bmRLZXkgPSBldmVudC5kYXRhLmdldChcImtleVwiKTtcclxuICAgICAgICB0aGlzLnN0b3BTb3VuZChzb3VuZEtleSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1VVEVfQ0hBTk5FTCkge1xyXG4gICAgICAgIHRoaXMubXV0ZUNoYW5uZWwoZXZlbnQuZGF0YS5nZXQoXCJjaGFubmVsXCIpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuVU5NVVRFX0NIQU5ORUwpIHtcclxuICAgICAgICB0aGlzLnVubXV0ZUNoYW5uZWwoZXZlbnQuZGF0YS5nZXQoXCJjaGFubmVsXCIpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGVudW0gQXVkaW9DaGFubmVsVHlwZSB7XHJcbiAgREVGQVVMVCA9IDAsXHJcbiAgU0ZYID0gMSxcclxuICBNVVNJQyA9IDIsXHJcbiAgQ1VTVE9NXzEgPSAzLFxyXG4gIENVU1RPTV8yID0gNCxcclxuICBDVVNUT01fMyA9IDUsXHJcbiAgQ1VTVE9NXzQgPSA2LFxyXG4gIENVU1RPTV81ID0gNyxcclxuICBDVVNUT01fNiA9IDgsXHJcbiAgQ1VTVE9NXzcgPSA5LFxyXG4gIENVU1RPTV84ID0gMTAsXHJcbiAgQ1VTVE9NXzkgPSAxMSxcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IE1BWF9BVURJT19DSEFOTkVMUyA9IDEyO1xyXG4iLCJpbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi9VdGlscy9NYXRoVXRpbHNcIjtcclxuaW1wb3J0IFRpbWVyTWFuYWdlciBmcm9tIFwiLi9UaW1lck1hbmFnZXJcIjtcclxuXHJcbi8qKiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG4gIC8qKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIHRpbWVyICovXHJcbiAgcHJvdGVjdGVkIHN0YXRlOiBUaW1lclN0YXRlO1xyXG5cclxuICAvKiogVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIHRpbWVyIGVuZHMgKi9cclxuICBwcm90ZWN0ZWQgb25FbmQ6IEZ1bmN0aW9uO1xyXG5cclxuICAvKiogV2hldGhlciBvciBub3QgdGhpcyB0aW1lciBzaG91bGQgbG9vcCAqL1xyXG4gIHByb3RlY3RlZCBsb29wOiBib29sZWFuO1xyXG5cclxuICAvKiogVGhlIHRvdGFsIGFtb3VudCBvZiB0aW1lIHRoaXMgdGltZXIgcnVucyBmb3IgKi9cclxuICBwcm90ZWN0ZWQgdG90YWxUaW1lOiBudW1iZXI7XHJcblxyXG4gIC8qKiBUaGUgYW1vdW50IG9mIHRpbWUgbGVmdCBvbiB0aGUgY3VycmVudCBydW4gKi9cclxuICBwcm90ZWN0ZWQgdGltZUxlZnQ6IG51bWJlcjtcclxuXHJcbiAgLyoqIFRoZSBudW1iZXIgb2YgdGltZXMgdGhpcyB0aW1lciBoYXMgYmVlbiBydW4gKi9cclxuICBwcm90ZWN0ZWQgbnVtUnVuczogbnVtYmVyO1xyXG5cclxuICBjb25zdHJ1Y3Rvcih0aW1lOiBudW1iZXIsIG9uRW5kPzogRnVuY3Rpb24sIGxvb3A6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgLy8gUmVnaXN0ZXIgdGhpcyB0aW1lclxyXG4gICAgVGltZXJNYW5hZ2VyLmdldEluc3RhbmNlKCkuYWRkVGltZXIodGhpcyk7XHJcblxyXG4gICAgdGhpcy50b3RhbFRpbWUgPSB0aW1lO1xyXG4gICAgdGhpcy50aW1lTGVmdCA9IDA7XHJcbiAgICB0aGlzLm9uRW5kID0gb25FbmQ7XHJcbiAgICB0aGlzLmxvb3AgPSBsb29wO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFRpbWVyU3RhdGUuU1RPUFBFRDtcclxuICAgIHRoaXMubnVtUnVucyA9IDA7XHJcbiAgfVxyXG5cclxuICBpc1N0b3BwZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gVGltZXJTdGF0ZS5TVE9QUEVEO1xyXG4gIH1cclxuXHJcbiAgaXNQYXVzZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gVGltZXJTdGF0ZS5QQVVTRUQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgdGltZXIgaGFzIGJlZW4gcnVuIGJlZm9yZVxyXG4gICAqIEByZXR1cm5zIHRydWUgaWYgaXQgaGFzIGJlZW4gcnVuIGF0IGxlYXN0IG9uY2UgKGFmdGVyIHRoZSBsYXRlc3QgcmVzZXQpLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgaGFzUnVuKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMubnVtUnVucyA+IDA7XHJcbiAgfVxyXG5cclxuICBzdGFydCh0aW1lPzogbnVtYmVyKSB7XHJcbiAgICBpZiAodGltZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMudG90YWxUaW1lID0gdGltZTtcclxuICAgIH1cclxuICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLkFDVElWRTtcclxuICAgIHRoaXMudGltZUxlZnQgPSB0aGlzLnRvdGFsVGltZTtcclxuICB9XHJcblxyXG4gIC8qKiBSZXNldHMgdGhpcyB0aW1lci4gU2V0cyB0aGUgcHJvZ3Jlc3MgYmFjayB0byB6ZXJvLCBhbmQgc2V0cyB0aGUgbnVtYmVyIG9mIHJ1bnMgYmFjayB0byB6ZXJvICovXHJcbiAgcmVzZXQoKSB7XHJcbiAgICB0aGlzLnRpbWVMZWZ0ID0gdGhpcy50b3RhbFRpbWU7XHJcbiAgICB0aGlzLm51bVJ1bnMgPSAwO1xyXG4gIH1cclxuXHJcbiAgcGF1c2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLnN0YXRlID0gVGltZXJTdGF0ZS5QQVVTRUQ7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpIHtcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBUaW1lclN0YXRlLkFDVElWRSkge1xyXG4gICAgICB0aGlzLnRpbWVMZWZ0IC09IGRlbHRhVCAqIDEwMDA7XHJcblxyXG4gICAgICBpZiAodGhpcy50aW1lTGVmdCA8PSAwKSB7XHJcbiAgICAgICAgdGhpcy50aW1lTGVmdCA9IE1hdGhVdGlscy5jbGFtcExvdzAodGhpcy50aW1lTGVmdCk7XHJcbiAgICAgICAgdGhpcy5lbmQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGVuZCgpIHtcclxuICAgIC8vIFVwZGF0ZSB0aGUgc3RhdGVcclxuICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLlNUT1BQRUQ7XHJcbiAgICB0aGlzLm51bVJ1bnMgKz0gMTtcclxuXHJcbiAgICAvLyBDYWxsIHRoZSBlbmQgZnVuY3Rpb24gaWYgdGhlcmUgaXMgb25lXHJcbiAgICBpZiAodGhpcy5vbkVuZCkge1xyXG4gICAgICB0aGlzLm9uRW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9vcCBpZiB3ZSB3YW50IHRvXHJcbiAgICBpZiAodGhpcy5sb29wKSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLkFDVElWRTtcclxuICAgICAgdGhpcy50aW1lTGVmdCA9IHRoaXMudG90YWxUaW1lO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIFwiVGltZXI6IFwiICtcclxuICAgICAgdGhpcy5zdGF0ZSArXHJcbiAgICAgIFwiIC0gVGltZSBMZWZ0OiBcIiArXHJcbiAgICAgIHRoaXMudGltZUxlZnQgK1xyXG4gICAgICBcIm1zIG9mIFwiICtcclxuICAgICAgdGhpcy50b3RhbFRpbWUgK1xyXG4gICAgICBcIm1zXCJcclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZW51bSBUaW1lclN0YXRlIHtcclxuICBBQ1RJVkUgPSBcIkFDVElWRVwiLFxyXG4gIFBBVVNFRCA9IFwiUEFVU0VEXCIsXHJcbiAgU1RPUFBFRCA9IFwiU1RPUFBFRFwiLFxyXG59XHJcbiIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XHJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi9UaW1lclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXJNYW5hZ2VyIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XHJcbiAgcHJvdGVjdGVkIHRpbWVyczogQXJyYXk8VGltZXI+O1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMudGltZXJzID0gbmV3IEFycmF5KCk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgc3RhdGljIGluc3RhbmNlOiBUaW1lck1hbmFnZXI7XHJcblxyXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBUaW1lck1hbmFnZXIge1xyXG4gICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XHJcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgVGltZXJNYW5hZ2VyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XHJcbiAgfVxyXG5cclxuICBhZGRUaW1lcih0aW1lcjogVGltZXIpIHtcclxuICAgIHRoaXMudGltZXJzLnB1c2godGltZXIpO1xyXG4gIH1cclxuXHJcbiAgY2xlYXJUaW1lcnMoKSB7XHJcbiAgICB0aGlzLnRpbWVycyA9IG5ldyBBcnJheSgpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLnRpbWVycy5mb3JFYWNoKHRpbWVyID0+IHRpbWVyLnVwZGF0ZShkZWx0YVQpKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi9NYXRoVXRpbHNcIjtcclxuXHJcbi8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIG1vdmVkIHRvIHRoZSBkYXRhdHlwZXMgZm9sZGVyXHJcbi8qKlxyXG4gKiBBIENvbG9yIHV0aWwgY2xhc3MgdGhhdCBrZWVwcyB0cmFjayBvZiBjb2xvcnMgbGlrZSBhIHZlY3RvciwgYnV0IGNhbiBiZSBjb252ZXJ0ZWQgaW50byBhIHN0cmluZyBmb3JtYXRcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9yIHtcclxuICAvKiogVGhlIHJlZCB2YWx1ZSAqL1xyXG4gIHB1YmxpYyByOiBudW1iZXI7XHJcbiAgLyoqIFRoZSBncmVlbiB2YWx1ZSAqL1xyXG4gIHB1YmxpYyBnOiBudW1iZXI7XHJcbiAgLyoqIFRoZSBibHVlIHZhbHVlICovXHJcbiAgcHVibGljIGI6IG51bWJlcjtcclxuICAvKiogVGhlIGFscGhhIHZhbHVlICovXHJcbiAgcHVibGljIGE6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBjb2xvclxyXG4gICAqIEBwYXJhbSByIFJlZFxyXG4gICAqIEBwYXJhbSBnIEdyZWVuXHJcbiAgICogQHBhcmFtIGIgQmx1ZVxyXG4gICAqIEBwYXJhbSBhIEFscGhhXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IocjogbnVtYmVyID0gMCwgZzogbnVtYmVyID0gMCwgYjogbnVtYmVyID0gMCwgYTogbnVtYmVyID0gMSkge1xyXG4gICAgdGhpcy5yID0gcjtcclxuICAgIHRoaXMuZyA9IGc7XHJcbiAgICB0aGlzLmIgPSBiO1xyXG4gICAgdGhpcy5hID0gYTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zcGFyZW50IGNvbG9yXHJcbiAgICogQHJldHVybnMgcmdiYSgwLCAwLCAwLCAwKVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgVFJBTlNQQVJFTlQoKTogQ29sb3Ige1xyXG4gICAgcmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZCBjb2xvclxyXG4gICAqIEByZXR1cm5zIHJnYigyNTUsIDAsIDApXHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBSRUQoKTogQ29sb3Ige1xyXG4gICAgcmV0dXJuIG5ldyBDb2xvcigyNTUsIDAsIDAsIDEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR3JlZW4gY29sb3JcclxuICAgKiBAcmV0dXJucyByZ2IoMCwgMjU1LCAwKVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgR1JFRU4oKTogQ29sb3Ige1xyXG4gICAgcmV0dXJuIG5ldyBDb2xvcigwLCAyNTUsIDAsIDEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmx1ZSBjb2xvclxyXG4gICAqIEByZXR1cm5zIHJnYigwLCAwLCAyNTUpXHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBCTFVFKCk6IENvbG9yIHtcclxuICAgIHJldHVybiBuZXcgQ29sb3IoMCwgMCwgMjU1LCAxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFllbGxvdyBjb2xvclxyXG4gICAqIEByZXR1cm5zIHJnYigyNTUsIDI1NSwgMClcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IFlFTExPVygpOiBDb2xvciB7XHJcbiAgICByZXR1cm4gbmV3IENvbG9yKDI1NSwgMjU1LCAwLCAxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hZ2VudGEgY29sb3JcclxuICAgKiBAcmV0dXJucyByZ2IoMjU1LCAwLCAyNTUpXHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBNQUdFTlRBKCk6IENvbG9yIHtcclxuICAgIHJldHVybiBuZXcgQ29sb3IoMjU1LCAwLCAyNTUsIDEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3lhbiBjb2xvclxyXG4gICAqIEByZXR1cm5zIHJnYigwLCAyNTUsIDI1NSlcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IENZQU4oKTogQ29sb3Ige1xyXG4gICAgcmV0dXJuIG5ldyBDb2xvcigwLCAyNTUsIDI1NSwgMSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaGl0ZSBjb2xvclxyXG4gICAqIEByZXR1cm5zIHJnYigyNTUsIDI1NSwgMjU1KVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgV0hJVEUoKTogQ29sb3Ige1xyXG4gICAgcmV0dXJuIG5ldyBDb2xvcigyNTUsIDI1NSwgMjU1LCAxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJsYWNrIGNvbG9yXHJcbiAgICogQHJldHVybnMgcmdiKDAsIDAsIDApXHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBCTEFDSygpOiBDb2xvciB7XHJcbiAgICByZXR1cm4gbmV3IENvbG9yKDAsIDAsIDAsIDEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3JhbmdlIGNvbG9yXHJcbiAgICogQHJldHVybnMgcmdiKDI1NSwgMTAwLCAwKVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgT1JBTkdFKCk6IENvbG9yIHtcclxuICAgIHJldHVybiBuZXcgQ29sb3IoMjU1LCAxMDAsIDAsIDEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgY29sb3IgdG8gdGhlIHZhbHVlcyBwcm92aWRlZFxyXG4gICAqIEBwYXJhbSByIFJlZFxyXG4gICAqIEBwYXJhbSBnIEdyZWVuXHJcbiAgICogQHBhcmFtIGIgQmx1ZVxyXG4gICAqIEBwYXJhbSBhIEFscGhhXHJcbiAgICovXHJcbiAgc2V0KHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIsIGE6IG51bWJlciA9IDEpOiB2b2lkIHtcclxuICAgIHRoaXMuciA9IHI7XHJcbiAgICB0aGlzLmcgPSBnO1xyXG4gICAgdGhpcy5iID0gYjtcclxuICAgIHRoaXMuYSA9IGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IGNvbG9yIHNsaWdodGx5IGxpZ2h0ZXIgdGhhbiB0aGUgY3VycmVudCBjb2xvclxyXG4gICAqIEByZXR1cm5zIEEgbmV3IGxpZ2h0ZXIgQ29sb3JcclxuICAgKi9cclxuICBsaWdodGVuKCk6IENvbG9yIHtcclxuICAgIHJldHVybiBuZXcgQ29sb3IoXHJcbiAgICAgIE1hdGhVdGlscy5jbGFtcCh0aGlzLnIgKyA0MCwgMCwgMjU1KSxcclxuICAgICAgTWF0aFV0aWxzLmNsYW1wKHRoaXMuZyArIDQwLCAwLCAyNTUpLFxyXG4gICAgICBNYXRoVXRpbHMuY2xhbXAodGhpcy5iICsgNDAsIDAsIDI1NSksXHJcbiAgICAgIE1hdGhVdGlscy5jbGFtcCh0aGlzLmEgKyAxMCwgMCwgMjU1KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IGNvbG9yIHNsaWdodGx5IGRhcmtlciB0aGFuIHRoZSBjdXJyZW50IGNvbG9yXHJcbiAgICogQHJldHVybnMgQSBuZXcgZGFya2VyIENvbG9yXHJcbiAgICovXHJcbiAgZGFya2VuKCk6IENvbG9yIHtcclxuICAgIHJldHVybiBuZXcgQ29sb3IoXHJcbiAgICAgIE1hdGhVdGlscy5jbGFtcCh0aGlzLnIgLSA0MCwgMCwgMjU1KSxcclxuICAgICAgTWF0aFV0aWxzLmNsYW1wKHRoaXMuZyAtIDQwLCAwLCAyNTUpLFxyXG4gICAgICBNYXRoVXRpbHMuY2xhbXAodGhpcy5iIC0gNDAsIDAsIDI1NSksXHJcbiAgICAgIE1hdGhVdGlscy5jbGFtcCh0aGlzLmEgKyAxMCwgMCwgMjU1KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoaXMgY29sb3IgYXMgYW4gYXJyYXlcclxuICAgKiBAcmV0dXJucyBbciwgZywgYiwgYV1cclxuICAgKi9cclxuICB0b0FycmF5KCk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcclxuICAgIHJldHVybiBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGNvbG9yIGFzIGEgc3RyaW5nIG9mIHRoZSBmb3JtICNSUkdHQkJcclxuICAgKiBAcmV0dXJucyAjUlJHR0JCXHJcbiAgICovXHJcbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIFwiI1wiICtcclxuICAgICAgTWF0aFV0aWxzLnRvSGV4KHRoaXMuciwgMikgK1xyXG4gICAgICBNYXRoVXRpbHMudG9IZXgodGhpcy5nLCAyKSArXHJcbiAgICAgIE1hdGhVdGlscy50b0hleCh0aGlzLmIsIDIpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiKHIsIGcsIGIpXHJcbiAgICogQHJldHVybnMgcmdiKHIsIGcsIGIpXHJcbiAgICovXHJcbiAgdG9TdHJpbmdSR0IoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIFwicmdiKFwiICtcclxuICAgICAgdGhpcy5yLnRvU3RyaW5nKCkgK1xyXG4gICAgICBcIiwgXCIgK1xyXG4gICAgICB0aGlzLmcudG9TdHJpbmcoKSArXHJcbiAgICAgIFwiLCBcIiArXHJcbiAgICAgIHRoaXMuYi50b1N0cmluZygpICtcclxuICAgICAgXCIpXCJcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBjb2xvciBhcyBhIHN0cmluZyBvZiB0aGUgZm9ybSByZ2JhKHIsIGcsIGIsIGEpXHJcbiAgICogQHJldHVybnMgcmdiYShyLCBnLCBiLCBhKVxyXG4gICAqL1xyXG4gIHRvU3RyaW5nUkdCQSgpOiBzdHJpbmcge1xyXG4gICAgaWYgKHRoaXMuYSA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZ1JHQigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChcclxuICAgICAgXCJyZ2JhKFwiICtcclxuICAgICAgdGhpcy5yLnRvU3RyaW5nKCkgK1xyXG4gICAgICBcIiwgXCIgK1xyXG4gICAgICB0aGlzLmcudG9TdHJpbmcoKSArXHJcbiAgICAgIFwiLCBcIiArXHJcbiAgICAgIHRoaXMuYi50b1N0cmluZygpICtcclxuICAgICAgXCIsIFwiICtcclxuICAgICAgdGhpcy5hLnRvU3RyaW5nKCkgK1xyXG4gICAgICBcIilcIlxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFR1cm5zIHRoaXMgY29sb3IgaW50byBhIGZsb2F0MzJBcnJheSBhbmQgY2hhbmdlcyBjb2xvciByYW5nZSB0byBbMC4wLCAxLjBdXHJcbiAgICogQHJldHVybnMgYSBGbG9hdDMyQXJyYXkgY29udGFpbmluZyB0aGUgY29sb3JcclxuICAgKi9cclxuICB0b1dlYkdMKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbdGhpcy5yIC8gMjU1LCB0aGlzLmcgLyAyNTUsIHRoaXMuYiAvIDI1NSwgdGhpcy5hXSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZnJvbVN0cmluZ0hleChzdHI6IHN0cmluZyk6IENvbG9yIHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGlmIChzdHIuY2hhckF0KDApID09IFwiI1wiKSBpICs9IDE7XHJcbiAgICBsZXQgciA9IE1hdGhVdGlscy5mcm9tSGV4KHN0ci5zdWJzdHJpbmcoaSwgaSArIDIpKTtcclxuICAgIGxldCBnID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpICsgMiwgaSArIDQpKTtcclxuICAgIGxldCBiID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpICsgNCwgaSArIDYpKTtcclxuICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYik7XHJcbiAgfVxyXG59XHJcbiIsIi8vIEBpZ25vcmVQYWdlXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFYXNlRnVuY3Rpb25zIHtcclxuICBzdGF0aWMgZWFzZUluT3V0U2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIC0oTWF0aC5jb3MoTWF0aC5QSSAqIHgpIC0gMSkgLyAyO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGVhc2VPdXRJblNpbmUoeDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB4IDwgMC41XHJcbiAgICAgID8gLU1hdGguY29zKE1hdGguUEkgKiAoeCArIDAuNSkpIC8gMlxyXG4gICAgICA6IC1NYXRoLmNvcyhNYXRoLlBJICogKHggLSAwLjUpKSAvIDIgKyAxO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGVhc2VPdXRTaW5lKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gTWF0aC5zaW4oKHggKiBNYXRoLlBJKSAvIDIpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGVhc2VJblNpbmUoeDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiAxIC0gTWF0aC5jb3MoKHggKiBNYXRoLlBJKSAvIDIpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGVhc2VJbk91dFF1aW50KHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4geCA8IDAuNSA/IDE2ICogeCAqIHggKiB4ICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgNSkgLyAyO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGVhc2VJbk91dFF1YWQoeDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB4IDwgMC41ID8gMiAqIHggKiB4IDogMSAtIE1hdGgucG93KC0yICogeCArIDIsIDIpIC8gMjtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBlYXNlT3V0SW5RdWFkKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4geCA8IDAuNSA/IHRoaXMuZWFzZU91dEluX091dFBvdyh4LCAyKSA6IHRoaXMuZWFzZU91dEluX0luUG93KHgsIDIpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZWFzZU91dEluX091dFBvdyh4OiBudW1iZXIsIHBvdzogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiAwLjUgLSBNYXRoLnBvdygtMiAqIHggKyAxLCBwb3cpIC8gMjtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGVhc2VPdXRJbl9JblBvdyh4OiBudW1iZXIsIHBvdzogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiAwLjUgKyBNYXRoLnBvdygyICogeCAtIDEsIHBvdykgLyAyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGVudW0gRWFzZUZ1bmN0aW9uVHlwZSB7XHJcbiAgLy8gU0lORVxyXG4gIElOX09VVF9TSU5FID0gXCJlYXNlSW5PdXRTaW5lXCIsXHJcbiAgT1VUX0lOX1NJTkUgPSBcImVhc2VPdXRJblNpbmVcIixcclxuICBJTl9TSU5FID0gXCJlYXNlSW5TaW5lXCIsXHJcbiAgT1VUX1NJTkUgPSBcImVhc2VPdXRTaW5lXCIsXHJcblxyXG4gIC8vIFFVQURcclxuICBJTl9PVVRfUVVBRCA9IFwiZWFzZUluT3V0UXVhZFwiLFxyXG4gIE9VVF9JTl9RVUFEID0gXCJlYXNlT3V0SW5RdWFkXCIsXHJcblxyXG4gIC8vIFFVSU5UXHJcbiAgSU5fT1VUX1FVSU5UID0gXCJlYXNlSW5PdXRRdWludFwiLFxyXG59XHJcbiIsImltcG9ydCBHcmFwaCBmcm9tIFwiLi4vRGF0YVR5cGVzL0dyYXBocy9HcmFwaFwiO1xyXG5pbXBvcnQgRWRnZU5vZGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvRWRnZU5vZGVcIjtcclxuXHJcbi8qKiBBIGNsYXNzIHRvIHByb3ZpZGVzIHNvbWUgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGdyYXBocyAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaFV0aWxzIHtcclxuICAvKipcclxuICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBEamlrc3RyYSdzIHNob3J0ZXN0IHBhdGggYWxnb3JpdGhtIGJhc2VkIG9uIHRoZSBvbmUgZGVzY3JpYmVkIGluIFRoZSBBbGdvcml0aG0gRGVzaWduIE1hbnVhbC5cclxuICAgKiBAcGFyYW0gZyBUaGUgZ3JhcGhcclxuICAgKiBAcGFyYW0gc3RhcnQgVGhlIG51bWJlciB0byBzdGFydCB0aGUgc2hvcnRlc3QgcGF0aCBmcm9tXHJcbiAgICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcGFyZW50IG9mIGVhY2ggbm9kZSBvZiB0aGUgR3JhcGggaW4gdGhlIHNob3J0ZXN0IHBhdGguXHJcbiAgICovXHJcbiAgc3RhdGljIGRqaWtzdHJhKGc6IEdyYXBoLCBzdGFydDogbnVtYmVyKTogQXJyYXk8bnVtYmVyPiB7XHJcbiAgICBsZXQgaTogbnVtYmVyOyAvLyBDb3VudGVyXHJcbiAgICBsZXQgcDogRWRnZU5vZGU7IC8vIFBvaW50ZXIgdG8gZWRnZW5vZGVcclxuICAgIGxldCBpblRyZWU6IEFycmF5PGJvb2xlYW4+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xyXG4gICAgbGV0IGRpc3RhbmNlOiBBcnJheTxudW1iZXI+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xyXG4gICAgbGV0IHBhcmVudDogQXJyYXk8bnVtYmVyPiA9IG5ldyBBcnJheShnLm51bVZlcnRpY2VzKTtcclxuICAgIGxldCB2OiBudW1iZXI7IC8vIEN1cnJlbnQgdmVydGV4IHRvIHByb2Nlc3NcclxuICAgIGxldCB3OiBudW1iZXI7IC8vIENhbmRpZGF0ZSBmb3IgbmV4dCB2ZXJ0ZXhcclxuICAgIGxldCB3ZWlnaHQ6IG51bWJlcjsgLy8gRWRnZSB3ZWlnaHRcclxuICAgIGxldCBkaXN0OyAvLyBCZXN0IGN1cnJlbnQgZGlzdGFuY2UgZnJvbSBzdGFydFxyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBnLm51bVZlcnRpY2VzOyBpKyspIHtcclxuICAgICAgaW5UcmVlW2ldID0gZmFsc2U7XHJcbiAgICAgIGRpc3RhbmNlW2ldID0gSW5maW5pdHk7XHJcbiAgICAgIHBhcmVudFtpXSA9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc3RhbmNlW3N0YXJ0XSA9IDA7XHJcbiAgICB2ID0gc3RhcnQ7XHJcblxyXG4gICAgd2hpbGUgKCFpblRyZWVbdl0pIHtcclxuICAgICAgaW5UcmVlW3ZdID0gdHJ1ZTtcclxuICAgICAgcCA9IGcuZWRnZXNbdl07XHJcblxyXG4gICAgICB3aGlsZSAocCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHcgPSBwLnk7XHJcbiAgICAgICAgd2VpZ2h0ID0gcC53ZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChkaXN0YW5jZVt3XSA+IGRpc3RhbmNlW3ZdICsgd2VpZ2h0KSB7XHJcbiAgICAgICAgICBkaXN0YW5jZVt3XSA9IGRpc3RhbmNlW3ZdICsgd2VpZ2h0O1xyXG4gICAgICAgICAgcGFyZW50W3ddID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHYgPSAwO1xyXG5cclxuICAgICAgZGlzdCA9IEluZmluaXR5O1xyXG5cclxuICAgICAgZm9yIChpID0gMDsgaSA8PSBnLm51bVZlcnRpY2VzOyBpKyspIHtcclxuICAgICAgICBpZiAoIWluVHJlZVtpXSAmJiBkaXN0ID4gZGlzdGFuY2VbaV0pIHtcclxuICAgICAgICAgIGRpc3QgPSBkaXN0YW5jZTtcclxuICAgICAgICAgIHYgPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJlbnQ7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5cclxuLyoqIEEgY2xhc3MgY29udGFpbmluZyBzb21lIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBtYXRoIG9wZXJhdGlvbnMgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0aFV0aWxzIHtcclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzaWduIG9mIHRoZSB2YWx1ZSBwcm92aWRlZFxyXG4gICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBleHRyYWN0IHRoZSBzaWduIGZyb21cclxuICAgKiBAcmV0dXJucyAtMSBpZiB0aGUgbnVtYmVyIGlzIGxlc3MgdGhhbiAwLCAxIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBzaWduKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4geCA8IDAgPyAtMSA6IDE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHggaXMgYmV0d2VlbiBhIGFuZCBiXHJcbiAgICogQHBhcmFtIGEgVGhlIG1pbiBib3VuZFxyXG4gICAqIEBwYXJhbSBiIFRoZSBtYXggYm91bmRcclxuICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gY2hlY2tcclxuICAgKiBAcGFyYW0gZXhjbHVzaXZlIFdoZXRoZXIgb3Igbm90IGEgYW5kIGIgYXJlIGV4Y2x1c2l2ZSBib3VuZHNcclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHggaXMgYmV0d2VlbiBhIGFuZCBiLCBmYWxzZSBvdGhlcndpc2VcclxuICAgKi9cclxuICBzdGF0aWMgYmV0d2VlbihcclxuICAgIGE6IG51bWJlcixcclxuICAgIGI6IG51bWJlcixcclxuICAgIHg6IG51bWJlcixcclxuICAgIGV4Y2x1c2l2ZT86IGJvb2xlYW4sXHJcbiAgKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoZXhjbHVzaXZlKSB7XHJcbiAgICAgIHJldHVybiBhIDwgeCAmJiB4IDwgYjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBhIDw9IHggJiYgeCA8PSBiO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhbXBzIHRoZSB2YWx1ZSB4IHRvIHRoZSByYW5nZSBbbWluLCBtYXhdLCByb3VuZGluZyB1cCBvciBkb3duIGlmIG5lZWRlZFxyXG4gICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICogQHBhcmFtIG1pbiBUaGUgbWluIG9mIHRoZSByYW5nZVxyXG4gICAqIEBwYXJhbSBtYXggVGhlIG1heCBvZiB0aGUgcmFuZ2VcclxuICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCBvciBtaW4vbWF4IGlmIGl0IGV4Y2VlZHMgdGhlaXIgYm91bmRzXHJcbiAgICovXHJcbiAgc3RhdGljIGNsYW1wKHg6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGlmICh4IDwgbWluKSByZXR1cm4gbWluO1xyXG4gICAgaWYgKHggPiBtYXgpIHJldHVybiBtYXg7XHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYW1wcyB0aGUgdmFsdWUgeCB0byB0aGUgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICogQHBhcmFtIHggVGhlIHZhbHVlIHRvIGJlIGNsYW1wZWRcclxuICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBiZXR3ZWVuIDAgYW5kIDEsIG9yIDAvMSBpZiBpdCBleGNlZWRzIHRoZWlyIGJvdW5kc1xyXG4gICAqL1xyXG4gIHN0YXRpYyBjbGFtcDAxKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gTWF0aFV0aWxzLmNsYW1wKHgsIDAsIDEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhbXBzIHRoZSBsb3dlciBlbmQgb2YgdGhlIHZhbHVlIG9mIHggdG8gdGhlIHJhbmdlIHRvIG1pblxyXG4gICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICogQHBhcmFtIG1pbiBUaGUgbWluaW11bSBhbGxvd2VkIHZhbHVlIG9mIHhcclxuICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gbWluLCBvdGhlcndpc2UgbWluXHJcbiAgICovXHJcbiAgc3RhdGljIGNsYW1wTG93KHg6IG51bWJlciwgbWluOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHggPCBtaW4gPyBtaW4gOiB4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhbXBzIHRoZSBsb3dlciBlbmQgb2YgdGhlIHZhbHVlIG9mIHggdG8gemVyb1xyXG4gICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICogQHJldHVybnMgeCwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDAsIG90aGVyd2lzZSAwXHJcbiAgICovXHJcbiAgc3RhdGljIGNsYW1wTG93MCh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIE1hdGhVdGlscy5jbGFtcExvdyh4LCAwKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjbGFtcE1hZ25pdHVkZSh2OiBWZWMyLCBtOiBudW1iZXIpOiBWZWMyIHtcclxuICAgIGlmICh2Lm1hZ1NxKCkgPiBtICogbSkge1xyXG4gICAgICByZXR1cm4gdi5zY2FsZVRvKG0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHY7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2hhbmdlUmFuZ2UoXHJcbiAgICB4OiBudW1iZXIsXHJcbiAgICBtaW46IG51bWJlcixcclxuICAgIG1heDogbnVtYmVyLFxyXG4gICAgbmV3TWluOiBudW1iZXIsXHJcbiAgICBuZXdNYXg6IG51bWJlcixcclxuICApOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubGVycChuZXdNaW4sIG5ld01heCwgdGhpcy5pbnZMZXJwKG1pbiwgbWF4LCB4KSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaW5lYXIgSW50ZXJwb2xhdGlvblxyXG4gICAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZSBmb3IgdGhlIGludGVycG9sYXRpb24gYm91bmRcclxuICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxyXG4gICAqIEBwYXJhbSB0IFRoZSB0aW1lIHdlIGFyZSBpbnRlcnBvbGF0aW5nIHRvXHJcbiAgICogQHJldHVybnMgVGhlIHZhbHVlIGJldHdlZW4gYSBhbmQgYiBhdCB0aW1lIHRcclxuICAgKi9cclxuICBzdGF0aWMgbGVycChhOiBudW1iZXIsIGI6IG51bWJlciwgdDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBhICsgdCAqIChiIC0gYSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnZlcnNlIExpbmVhciBJbnRlcnBvbGF0aW9uLiBGaW5kcyB0aGUgdGltZSBhdCB3aGljaCBhIHZhbHVlIGJldHdlZW4gYSBhbmQgYiB3b3VsZCBvY2N1clxyXG4gICAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZSBmb3IgdGhlIGludGVycG9sYXRpb24gYm91bmRcclxuICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxyXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgY3VycmVudCB2YWx1ZVxyXG4gICAqIEByZXR1cm5zIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSBjdXJyZW50IHZhbHVlIG9jY3VycyBiZXR3ZWVuIGEgYW5kIGJcclxuICAgKi9cclxuICBzdGF0aWMgaW52TGVycChhOiBudW1iZXIsIGI6IG51bWJlciwgdmFsdWU6IG51bWJlcikge1xyXG4gICAgcmV0dXJuICh2YWx1ZSAtIGEpIC8gKGIgLSBhKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEN1dHMgb2ZmIGRlY2ltYWwgcG9pbnRzIG9mIGEgbnVtYmVyIGFmdGVyIGEgc3BlY2lmaWVkIHBsYWNlXHJcbiAgICogQHBhcmFtIG51bSBUaGUgbnVtYmVyIHRvIGZsb29yXHJcbiAgICogQHBhcmFtIHBsYWNlIFRoZSBsYXN0IGRlY2ltYWwgcGxhY2Ugb2YgdGhlIG5ldyBudW1iZXJcclxuICAgKiBAcmV0dXJucyBUaGUgZmxvb3JlZCBudW1iZXJcclxuICAgKi9cclxuICBzdGF0aWMgZmxvb3JUb1BsYWNlKG51bTogbnVtYmVyLCBwbGFjZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGlmIChwbGFjZSA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihudW0pO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBmYWN0b3IgPSAxMDtcclxuICAgIHdoaWxlIChwbGFjZSA+IDEpIHtcclxuICAgICAgZmFjdG9yICE9IDEwO1xyXG4gICAgICBwbGFjZS0tO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBNYXRoLmZsb29yKG51bSAqIGZhY3RvcikgLyBmYWN0b3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbnVtYmVyIGZyb20gYSBoZXggc3RyaW5nXHJcbiAgICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGhleCBudW1iZXJcclxuICAgKiBAcmV0dXJucyB0aGUgbnVtYmVyIGluIGRlY2ltYWwgcmVwcmVzZW50ZWQgYnkgdGhlIGhleCBzdHJpbmdcclxuICAgKi9cclxuICBzdGF0aWMgZnJvbUhleChzdHI6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxNik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgYXMgYSBoZXhhZGVjaW1hbFxyXG4gICAqIEBwYXJhbSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGhleFxyXG4gICAqIEBwYXJhbSBtaW5MZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgcmV0dXJuZWQgaGV4IHN0cmluZyAoYWRkcyB6ZXJvIHBhZGRpbmcgaWYgbmVlZGVkKVxyXG4gICAqIEByZXR1cm5zIFRoZSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlciBhcyBhIHN0cmluZ1xyXG4gICAqL1xyXG4gIHN0YXRpYyB0b0hleChudW06IG51bWJlciwgbWluTGVuZ3RoOiBudW1iZXIgPSBudWxsKTogc3RyaW5nIHtcclxuICAgIGxldCBmYWN0b3IgPSAxO1xyXG4gICAgd2hpbGUgKGZhY3RvciAqIDE2IDwgbnVtKSB7XHJcbiAgICAgIGZhY3RvciAqPSAxNjtcclxuICAgIH1cclxuICAgIGxldCBoZXhTdHIgPSBcIlwiO1xyXG4gICAgd2hpbGUgKGZhY3RvciA+PSAxKSB7XHJcbiAgICAgIGxldCBkaWdpdCA9IE1hdGguZmxvb3IobnVtIC8gZmFjdG9yKTtcclxuICAgICAgaGV4U3RyICs9IE1hdGhVdGlscy50b0hleERpZ2l0KGRpZ2l0KTtcclxuICAgICAgbnVtIC09IGRpZ2l0ICogZmFjdG9yO1xyXG4gICAgICBmYWN0b3IgLz0gMTY7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1pbkxlbmd0aCAhPT0gbnVsbCkge1xyXG4gICAgICB3aGlsZSAoaGV4U3RyLmxlbmd0aCA8IG1pbkxlbmd0aCkge1xyXG4gICAgICAgIGhleFN0ciA9IFwiMFwiICsgaGV4U3RyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGhleFN0cjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIGEgZGlnaXQgdG8gaGV4YWRlY2ltYWwuIEluIHRoaXMgY2FzZSwgYSBkaWdpdCBpcyBiZXR3ZWVuIDAgYW5kIDE1IGluY2x1c2l2ZVxyXG4gICAqIEBwYXJhbSBudW0gVGhlIGRpZ2l0IHRvIGNvbnZlcnQgdG8gaGV4YWRlY2ltYWxcclxuICAgKiBAcmV0dXJucyBUaGUgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkaWdpdCBhcyBhIHN0cmluZ1xyXG4gICAqL1xyXG4gIHN0YXRpYyB0b0hleERpZ2l0KG51bTogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGlmIChudW0gPCAxMCkge1xyXG4gICAgICByZXR1cm4gXCJcIiArIG51bTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgbnVtIC0gMTApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuL0NvbG9yXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4vTWF0aFV0aWxzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJpbmdVdGlscyB7XHJcbiAgc3RhdGljIHRvV2ViR0xDb29yZHMoXHJcbiAgICBwb2ludDogVmVjMixcclxuICAgIG9yaWdpbjogVmVjMixcclxuICAgIHdvcmxkU2l6ZTogVmVjMixcclxuICApOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICBNYXRoVXRpbHMuY2hhbmdlUmFuZ2UocG9pbnQueCwgb3JpZ2luLngsIG9yaWdpbi54ICsgd29ybGRTaXplLngsIC0xLCAxKSxcclxuICAgICAgTWF0aFV0aWxzLmNoYW5nZVJhbmdlKHBvaW50LnksIG9yaWdpbi55LCBvcmlnaW4ueSArIHdvcmxkU2l6ZS55LCAxLCAtMSksXHJcbiAgICBdKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyB0b1dlYkdMU2NhbGUoc2l6ZTogVmVjMiwgd29ybGRTaXplOiBWZWMyKTogRmxvYXQzMkFycmF5IHtcclxuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgKDIgKiBzaXplLngpIC8gd29ybGRTaXplLngsXHJcbiAgICAgICgyICogc2l6ZS55KSAvIHdvcmxkU2l6ZS55LFxyXG4gICAgXSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgdG9XZWJHTENvbG9yKGNvbG9yOiBDb2xvcik6IEZsb2F0MzJBcnJheSB7XHJcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgIE1hdGhVdGlscy5jaGFuZ2VSYW5nZShjb2xvci5yLCAwLCAyNTUsIDAsIDEpLFxyXG4gICAgICBNYXRoVXRpbHMuY2hhbmdlUmFuZ2UoY29sb3IuZywgMCwgMjU1LCAwLCAxKSxcclxuICAgICAgTWF0aFV0aWxzLmNoYW5nZVJhbmdlKGNvbG9yLmIsIDAsIDI1NSwgMCwgMSksXHJcbiAgICAgIGNvbG9yLmEsXHJcbiAgICBdKTtcclxuICB9XHJcbn1cclxuIiwiLyoqIFNvbWUgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBzdHJpbmdzICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmluZ1V0aWxzIHtcclxuICAvKipcclxuICAgKiBFeHRyYWN0cyB0aGUgcGF0aCBmcm9tIGEgZmlsZXBhdGggdGhhdCBpbmNsdWRlcyB0aGUgZmlsZVxyXG4gICAqIEBwYXJhbSBmaWxlUGF0aCB0aGUgZmlsZXBhdGggdG8gZXh0cmFjdCB0aGUgcGF0aCBmcm9tXHJcbiAgICogQHJldHVybnMgVGhlIHBhdGggcG9ydGlvbiBvZiB0aGUgZmlsZXBhdGggcHJvdmlkZWRcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0UGF0aEZyb21GaWxlUGF0aChmaWxlUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGxldCBzcGxpdFBhdGggPSBmaWxlUGF0aC5zcGxpdChcIi9cIik7XHJcbiAgICBzcGxpdFBhdGgucG9wKCk7XHJcbiAgICBzcGxpdFBhdGgucHVzaChcIlwiKTtcclxuICAgIHJldHVybiBzcGxpdFBhdGguam9pbihcIi9cIik7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBWZWMyIGZyb20gXCIuL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcblxyXG5leHBvcnQgZW51bSBBY3Rpb24ge1xyXG4gIExlZnQgPSBcImxlZnRcIixcclxuICBSaWdodCA9IFwicmlnaHRcIixcclxuICBKdW1wID0gXCJqdW1wXCIsXHJcbiAgQXR0YWNrID0gXCJhdHRhY2tcIixcclxuICBEYXNoID0gXCJkYXNoXCIsXHJcbiAgUGF1c2UgPSBcInBhdXNlXCIsXHJcbiAgVXAgPSBcInVwXCIsXHJcbiAgRG93biA9IFwiZG93blwiLFxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgRXZlbnRzID0ge1xyXG4gIE1BSU5fTUVOVTogXCJNQUlOX01FTlVcIixcclxuXHJcbiAgUExBWUVSX0RBTUFHRTogXCJQTEFZRVJfREFNQUdFXCIsXHJcbiAgUExBWUVSX0hFQUw6IFwiUExBWUVSX0hFQUxcIixcclxuICBQTEFZRVJfREVBVEg6IFwiUExBWUVSX0RFQVRIXCIsXHJcblxyXG4gIEVORU1ZX0RFQVRIOiBcIkVORU1ZX0RFQVRIXCIsXHJcbiAgRU5FTVlfREFNQUdFOiBcIkVORU1ZX0RBTUFHRVwiLFxyXG5cclxuICBMRVZFTF9FTkQ6IFwiTEVWRUxfRU5EXCIsXHJcbiAgRU5URVJfTEVWRUxfRU5EOiBcIkVOVEVSX0xFVkVMX0VORFwiLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IFBoeXNpY3NHcm91cHMgPSB7XHJcbiAgUExBWUVSX1BIWVM6IFwiUExBWUVSX1BIWVNcIixcclxuICBFTkVNWV9QSFlTOiBcIkVORU1ZX1BIWVNcIixcclxuICBISVRCT1hfUEhZUzogXCJISVRCT1hfUEhZU1wiLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IFNwcml0ZVNpemVzID0ge1xyXG4gIFNPVUw6IG5ldyBWZWMyKDE4LCAyNCksXHJcbiAgUExBWUVSOiBuZXcgVmVjMigxOCwgMjQpLFxyXG59O1xyXG4iLCJpbXBvcnQgR2FtZSBmcm9tIFwiLi9Xb2xmaWUyRC9Mb29wL0dhbWVcIjtcclxuaW1wb3J0IE1haW5NZW51IGZyb20gXCIuL0F1dG9wc3kvU2NlbmVzL01haW5NZW51XCI7XHJcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gXCIuL2dsb2JhbHNcIjtcclxuXHJcbi8vIFRoZSBtYWluIGZ1bmN0aW9uIGlzIHlvdXIgZW50cnlwb2ludCBpbnRvIFdvbGZpZTJELiBTcGVjaWZ5IHlvdXIgZmlyc3Qgc2NlbmUgYW5kIGFueSBvcHRpb25zIGhlcmUuXHJcbihmdW5jdGlvbiBtYWluKCkge1xyXG4gIC8vIFJ1biBhbnkgdGVzdHNcclxuICBydW5UZXN0cygpO1xyXG5cclxuICAvLyBTZXQgdXAgb3B0aW9ucyBmb3Igb3VyIGdhbWVcclxuICBsZXQgb3B0aW9ucyA9IHtcclxuICAgIGNhbnZhc1NpemU6IHsgeDogMTIwMCwgeTogODAwIH0sIC8vIFRoZSBzaXplIG9mIHRoZSBnYW1lXHJcbiAgICBjbGVhckNvbG9yOiB7IHI6IDM0LCBnOiAyOCwgYjogNDEgfSwgLy8gVGhlIGNvbG9yIHRoZSBnYW1lIGNsZWFycyB0b1xyXG4gICAgaW5wdXRzOiBbXHJcbiAgICAgIHsgbmFtZTogQWN0aW9uLkxlZnQsIGtleXM6IFtcImFcIl0gfSxcclxuICAgICAgeyBuYW1lOiBBY3Rpb24uUmlnaHQsIGtleXM6IFtcImRcIl0gfSxcclxuICAgICAgeyBuYW1lOiBBY3Rpb24uVXAsIGtleXM6IFtcIndcIl0gfSxcclxuICAgICAgeyBuYW1lOiBBY3Rpb24uRG93biwga2V5czogW1wic1wiXSB9LFxyXG4gICAgICB7IG5hbWU6IEFjdGlvbi5KdW1wLCBrZXlzOiBbXCJzcGFjZVwiXSB9LFxyXG4gICAgICB7IG5hbWU6IEFjdGlvbi5BdHRhY2ssIGtleXM6IFtcImpcIl0gfSxcclxuICAgICAgeyBuYW1lOiBBY3Rpb24uRGFzaCwga2V5czogW1wic2hpZnRcIl0gfSxcclxuICAgICAgeyBuYW1lOiBBY3Rpb24uUGF1c2UsIGtleXM6IFtcImVzY2FwZVwiXSB9LFxyXG4gICAgXSxcclxuICAgIHVzZVdlYkdMOiBmYWxzZSwgLy8gVGVsbCB0aGUgZ2FtZSB3ZSB3YW50IHRvIHVzZSB3ZWJnbFxyXG4gICAgc2hvd0RlYnVnOiBmYWxzZSwgLy8gV2hldGhlciB0byBzaG93IGRlYnVnIG1lc3NhZ2VzLiBZb3UgY2FuIGNoYW5nZSB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnRcclxuICB9O1xyXG5cclxuICAvLyBDcmVhdGUgYSBnYW1lIHdpdGggdGhlIG9wdGlvbnMgc3BlY2lmaWVkXHJcbiAgY29uc3QgZ2FtZSA9IG5ldyBHYW1lKG9wdGlvbnMpO1xyXG5cclxuICAvLyBTdGFydCBvdXIgZ2FtZVxyXG4gIGdhbWUuc3RhcnQoTWFpbk1lbnUsIHt9KTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIHJ1blRlc3RzKCkge31cclxuIl19
